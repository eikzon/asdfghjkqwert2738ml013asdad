/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k="".trim,l={},m="1.11.0",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray||function(a){return"array"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return a-parseFloat(a)>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,"constructor")&&!j.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(l.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:k&&!k.call("\ufeff\xa0")?function(a){return null==a?"":k.call(a)}:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||n.guid++,e):void 0},now:function(){return+new Date},support:l}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s="sizzle"+-new Date,t=a.document,u=0,v=0,w=eb(),x=eb(),y=eb(),z=function(a,b){return a===b&&(j=!0),0},A="undefined",B=1<<31,C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=D.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",M=L.replace("w","w#"),N="\\["+K+"*("+L+")"+K+"*(?:([*^$|!~]?=)"+K+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+M+")|)|)"+K+"*\\]",O=":("+L+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+N.replace(3,8)+")*)|.*)\\)|)",P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(O),U=new RegExp("^"+M+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L.replace("w","w*")+")"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=/'|\\/g,ab=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),bb=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{G.apply(D=H.call(t.childNodes),t.childNodes),D[t.childNodes.length].nodeType}catch(cb){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function db(a,b,d,e){var f,g,h,i,j,m,p,q,u,v;if((b?b.ownerDocument||b:t)!==l&&k(b),b=b||l,d=d||[],!a||"string"!=typeof a)return d;if(1!==(i=b.nodeType)&&9!==i)return[];if(n&&!e){if(f=Z.exec(a))if(h=f[1]){if(9===i){if(g=b.getElementById(h),!g||!g.parentNode)return d;if(g.id===h)return d.push(g),d}else if(b.ownerDocument&&(g=b.ownerDocument.getElementById(h))&&r(b,g)&&g.id===h)return d.push(g),d}else{if(f[2])return G.apply(d,b.getElementsByTagName(a)),d;if((h=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(h)),d}if(c.qsa&&(!o||!o.test(a))){if(q=p=s,u=b,v=9===i&&a,1===i&&"object"!==b.nodeName.toLowerCase()){m=ob(a),(p=b.getAttribute("id"))?q=p.replace(_,"\\$&"):b.setAttribute("id",q),q="[id='"+q+"'] ",j=m.length;while(j--)m[j]=q+pb(m[j]);u=$.test(a)&&mb(b.parentNode)||b,v=m.join(",")}if(v)try{return G.apply(d,u.querySelectorAll(v)),d}catch(w){}finally{p||b.removeAttribute("id")}}}return xb(a.replace(P,"$1"),b,d,e)}function eb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function fb(a){return a[s]=!0,a}function gb(a){var b=l.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function hb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function ib(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||B)-(~a.sourceIndex||B);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function jb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function kb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function lb(a){return fb(function(b){return b=+b,fb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function mb(a){return a&&typeof a.getElementsByTagName!==A&&a}c=db.support={},f=db.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},k=db.setDocument=function(a){var b,e=a?a.ownerDocument||a:t,g=e.defaultView;return e!==l&&9===e.nodeType&&e.documentElement?(l=e,m=e.documentElement,n=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){k()},!1):g.attachEvent&&g.attachEvent("onunload",function(){k()})),c.attributes=gb(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=gb(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(e.getElementsByClassName)&&gb(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=gb(function(a){return m.appendChild(a).id=s,!e.getElementsByName||!e.getElementsByName(s).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==A&&n){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){var c=typeof a.getAttributeNode!==A&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==A?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==A&&n?b.getElementsByClassName(a):void 0},p=[],o=[],(c.qsa=Y.test(e.querySelectorAll))&&(gb(function(a){a.innerHTML="<select t=''><option selected=''></option></select>",a.querySelectorAll("[t^='']").length&&o.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||o.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll(":checked").length||o.push(":checked")}),gb(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&o.push("name"+K+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||o.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),o.push(",.*:")})),(c.matchesSelector=Y.test(q=m.webkitMatchesSelector||m.mozMatchesSelector||m.oMatchesSelector||m.msMatchesSelector))&&gb(function(a){c.disconnectedMatch=q.call(a,"div"),q.call(a,"[s!='']:x"),p.push("!=",O)}),o=o.length&&new RegExp(o.join("|")),p=p.length&&new RegExp(p.join("|")),b=Y.test(m.compareDocumentPosition),r=b||Y.test(m.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},z=b?function(a,b){if(a===b)return j=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===t&&r(t,a)?-1:b===e||b.ownerDocument===t&&r(t,b)?1:i?I.call(i,a)-I.call(i,b):0:4&d?-1:1)}:function(a,b){if(a===b)return j=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],k=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:i?I.call(i,a)-I.call(i,b):0;if(f===g)return ib(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)k.unshift(c);while(h[d]===k[d])d++;return d?ib(h[d],k[d]):h[d]===t?-1:k[d]===t?1:0},e):l},db.matches=function(a,b){return db(a,null,null,b)},db.matchesSelector=function(a,b){if((a.ownerDocument||a)!==l&&k(a),b=b.replace(S,"='$1']"),!(!c.matchesSelector||!n||p&&p.test(b)||o&&o.test(b)))try{var d=q.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return db(b,l,null,[a]).length>0},db.contains=function(a,b){return(a.ownerDocument||a)!==l&&k(a),r(a,b)},db.attr=function(a,b){(a.ownerDocument||a)!==l&&k(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!n):void 0;return void 0!==f?f:c.attributes||!n?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},db.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},db.uniqueSort=function(a){var b,d=[],e=0,f=0;if(j=!c.detectDuplicates,i=!c.sortStable&&a.slice(0),a.sort(z),j){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return i=null,a},e=db.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=db.selectors={cacheLength:50,createPseudo:fb,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ab,bb),a[3]=(a[4]||a[5]||"").replace(ab,bb),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||db.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&db.error(a[0]),a},PSEUDO:function(a){var b,c=!a[5]&&a[2];return V.CHILD.test(a[0])?null:(a[3]&&void 0!==a[4]?a[2]=a[4]:c&&T.test(c)&&(b=ob(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ab,bb).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=w[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&w(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==A&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=db.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),t=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&t){k=q[s]||(q[s]={}),j=k[a]||[],n=j[0]===u&&j[1],m=j[0]===u&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[u,n,m];break}}else if(t&&(j=(b[s]||(b[s]={}))[a])&&j[0]===u)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(t&&((l[s]||(l[s]={}))[a]=[u,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||db.error("unsupported pseudo: "+a);return e[s]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?fb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:fb(function(a){var b=[],c=[],d=g(a.replace(P,"$1"));return d[s]?fb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:fb(function(a){return function(b){return db(a,b).length>0}}),contains:fb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:fb(function(a){return U.test(a||"")||db.error("unsupported lang: "+a),a=a.replace(ab,bb).toLowerCase(),function(b){var c;do if(c=n?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===m},focus:function(a){return a===l.activeElement&&(!l.hasFocus||l.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:lb(function(){return[0]}),last:lb(function(a,b){return[b-1]}),eq:lb(function(a,b,c){return[0>c?c+b:c]}),even:lb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:lb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:lb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:lb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=jb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=kb(b);function nb(){}nb.prototype=d.filters=d.pseudos,d.setFilters=new nb;function ob(a,b){var c,e,f,g,h,i,j,k=x[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=Q.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?db.error(a):x(a,i).slice(0)}function pb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function qb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=v++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[u,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[s]||(b[s]={}),(h=i[d])&&h[0]===u&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function rb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function sb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function tb(a,b,c,d,e,f){return d&&!d[s]&&(d=tb(d)),e&&!e[s]&&(e=tb(e,f)),fb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||wb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:sb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=sb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=sb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ub(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],i=g||d.relative[" "],j=g?1:0,k=qb(function(a){return a===b},i,!0),l=qb(function(a){return I.call(b,a)>-1},i,!0),m=[function(a,c,d){return!g&&(d||c!==h)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>j;j++)if(c=d.relative[a[j].type])m=[qb(rb(m),c)];else{if(c=d.filter[a[j].type].apply(null,a[j].matches),c[s]){for(e=++j;f>e;e++)if(d.relative[a[e].type])break;return tb(j>1&&rb(m),j>1&&pb(a.slice(0,j-1).concat({value:" "===a[j-2].type?"*":""})).replace(P,"$1"),c,e>j&&ub(a.slice(j,e)),f>e&&ub(a=a.slice(e)),f>e&&pb(a))}m.push(c)}return rb(m)}function vb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,i,j,k){var m,n,o,p=0,q="0",r=f&&[],s=[],t=h,v=f||e&&d.find.TAG("*",k),w=u+=null==t?1:Math.random()||.1,x=v.length;for(k&&(h=g!==l&&g);q!==x&&null!=(m=v[q]);q++){if(e&&m){n=0;while(o=a[n++])if(o(m,g,i)){j.push(m);break}k&&(u=w)}c&&((m=!o&&m)&&p--,f&&r.push(m))}if(p+=q,c&&q!==p){n=0;while(o=b[n++])o(r,s,g,i);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=E.call(j));s=sb(s)}G.apply(j,s),k&&!f&&s.length>0&&p+b.length>1&&db.uniqueSort(j)}return k&&(u=w,h=t),r};return c?fb(f):f}g=db.compile=function(a,b){var c,d=[],e=[],f=y[a+" "];if(!f){b||(b=ob(a)),c=b.length;while(c--)f=ub(b[c]),f[s]?d.push(f):e.push(f);f=y(a,vb(e,d))}return f};function wb(a,b,c){for(var d=0,e=b.length;e>d;d++)db(a,b[d],c);return c}function xb(a,b,e,f){var h,i,j,k,l,m=ob(a);if(!f&&1===m.length){if(i=m[0]=m[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&c.getById&&9===b.nodeType&&n&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(ab,bb),b)||[])[0],!b)return e;a=a.slice(i.shift().value.length)}h=V.needsContext.test(a)?0:i.length;while(h--){if(j=i[h],d.relative[k=j.type])break;if((l=d.find[k])&&(f=l(j.matches[0].replace(ab,bb),$.test(i[0].type)&&mb(b.parentNode)||b))){if(i.splice(h,1),a=f.length&&pb(i),!a)return G.apply(e,f),e;break}}}return g(a,m)(f,b,!n,e,$.test(a)&&mb(b.parentNode)||b),e}return c.sortStable=s.split("").sort(z).join("")===s,c.detectDuplicates=!!j,k(),c.sortDetached=gb(function(a){return 1&a.compareDocumentPosition(l.createElement("div"))}),gb(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||hb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&gb(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||hb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),gb(function(a){return null==a.getAttribute("disabled")})||hb(J,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),db}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return n.inArray(a,b)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;e>b;b++)if(n.contains(d[b],this))return!0}));for(b=0;e>b;b++)n.find(a,d[b],c);return c=this.pushStack(e>1?n.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=a.document,A=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,B=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:A.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:z,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=z.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return y.find(a);this.length=1,this[0]=d}return this.context=z,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};B.prototype=n.fn,y=n(z);var C=/^(?:parents|prev(?:Until|All))/,D={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!n(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b,c=n(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(n.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?n.inArray(this[0],n(a)):n.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function E(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return E(a,"nextSibling")},prev:function(a){return E(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return n.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(D[a]||(e=n.unique(e)),C.test(a)&&(e=e.reverse())),this.pushStack(e)}});var F=/\S+/g,G={};function H(a){var b=G[a]={};return n.each(a.match(F)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?G[a]||H(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&n.each(arguments,function(a,c){var d;while((d=n.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){if(a===!0?!--n.readyWait:!n.isReady){if(!z.body)return setTimeout(n.ready);n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(z,[n]),n.fn.trigger&&n(z).trigger("ready").off("ready"))}}});function J(){z.addEventListener?(z.removeEventListener("DOMContentLoaded",K,!1),a.removeEventListener("load",K,!1)):(z.detachEvent("onreadystatechange",K),a.detachEvent("onload",K))}function K(){(z.addEventListener||"load"===event.type||"complete"===z.readyState)&&(J(),n.ready())}n.ready.promise=function(b){if(!I)if(I=n.Deferred(),"complete"===z.readyState)setTimeout(n.ready);else if(z.addEventListener)z.addEventListener("DOMContentLoaded",K,!1),a.addEventListener("load",K,!1);else{z.attachEvent("onreadystatechange",K),a.attachEvent("onload",K);var c=!1;try{c=null==a.frameElement&&z.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!n.isReady){try{c.doScroll("left")}catch(a){return setTimeout(e,50)}J(),n.ready()}}()}return I.promise(b)};var L="undefined",M;for(M in n(l))break;l.ownLast="0"!==M,l.inlineBlockNeedsLayout=!1,n(function(){var a,b,c=z.getElementsByTagName("body")[0];c&&(a=z.createElement("div"),a.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",b=z.createElement("div"),c.appendChild(a).appendChild(b),typeof b.style.zoom!==L&&(b.style.cssText="border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1",(l.inlineBlockNeedsLayout=3===b.offsetWidth)&&(c.style.zoom=1)),c.removeChild(a),a=b=null)}),function(){var a=z.createElement("div");if(null==l.deleteExpando){l.deleteExpando=!0;try{delete a.test}catch(b){l.deleteExpando=!1}}a=null}(),n.acceptData=function(a){var b=n.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b};var N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(O,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}n.data(a,b,c)}else c=void 0}return c}function Q(a){var b;for(b in a)if(("data"!==b||!n.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;return!0}function R(a,b,d,e){if(n.acceptData(a)){var f,g,h=n.expando,i=a.nodeType,j=i?n.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||n.guid++:h),j[k]||(j[k]=i?{}:{toJSON:n.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=n.extend(j[k],b):j[k].data=n.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[n.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[n.camelCase(b)])):f=g,f
}}function S(a,b,c){if(n.acceptData(a)){var d,e,f=a.nodeType,g=f?n.cache:a,h=f?a[n.expando]:n.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){n.isArray(b)?b=b.concat(n.map(b,n.camelCase)):b in d?b=[b]:(b=n.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!Q(d):!n.isEmptyObject(d))return}(c||(delete g[h].data,Q(g[h])))&&(f?n.cleanData([a],!0):l.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}n.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?n.cache[a[n.expando]]:a[n.expando],!!a&&!Q(a)},data:function(a,b,c){return R(a,b,c)},removeData:function(a,b){return S(a,b)},_data:function(a,b,c){return R(a,b,c,!0)},_removeData:function(a,b){return S(a,b,!0)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=n.data(f),1===f.nodeType&&!n._data(f,"parsedAttrs"))){c=g.length;while(c--)d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d]));n._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){n.data(this,a)}):arguments.length>1?this.each(function(){n.data(this,a,b)}):f?P(f,a,n.data(f,a)):void 0},removeData:function(a){return this.each(function(){n.removeData(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=n._data(a,b),c&&(!d||n.isArray(c)?d=n._data(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return n._data(a,c)||n._data(a,c,{empty:n.Callbacks("once memory").add(function(){n._removeData(a,b+"queue"),n._removeData(a,c)})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=n._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var T=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,U=["Top","Right","Bottom","Left"],V=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},W=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},X=/^(?:checkbox|radio)$/i;!function(){var a=z.createDocumentFragment(),b=z.createElement("div"),c=z.createElement("input");if(b.setAttribute("className","t"),b.innerHTML="  <link/><table></table><a href='/a'>a</a>",l.leadingWhitespace=3===b.firstChild.nodeType,l.tbody=!b.getElementsByTagName("tbody").length,l.htmlSerialize=!!b.getElementsByTagName("link").length,l.html5Clone="<:nav></:nav>"!==z.createElement("nav").cloneNode(!0).outerHTML,c.type="checkbox",c.checked=!0,a.appendChild(c),l.appendChecked=c.checked,b.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,a.appendChild(b),b.innerHTML="<input type='radio' checked='checked' name='t'/>",l.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,l.noCloneEvent=!0,b.attachEvent&&(b.attachEvent("onclick",function(){l.noCloneEvent=!1}),b.cloneNode(!0).click()),null==l.deleteExpando){l.deleteExpando=!0;try{delete b.test}catch(d){l.deleteExpando=!1}}a=b=c=null}(),function(){var b,c,d=z.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(l[b+"Bubbles"]=c in a)||(d.setAttribute(c,"t"),l[b+"Bubbles"]=d.attributes[c].expando===!1);d=null}();var Y=/^(?:input|select|textarea)$/i,Z=/^key/,$=/^(?:mouse|contextmenu)|click/,_=/^(?:focusinfocus|focusoutblur)$/,ab=/^([^.]*)(?:\.(.+)|)$/;function bb(){return!0}function cb(){return!1}function db(){try{return z.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=n.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof n===L||a&&n.event.triggered===a.type?void 0:n.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(F)||[""],h=b.length;while(h--)f=ab.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=n.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=n.event.special[o]||{},l=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},i),(m=g[o])||(m=g[o]=[],m.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,l):m.push(l),n.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n.hasData(a)&&n._data(a);if(r&&(k=r.events)){b=(b||"").match(F)||[""],j=b.length;while(j--)if(h=ab.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=m.length;while(f--)g=m[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(m.splice(f,1),g.selector&&m.delegateCount--,l.remove&&l.remove.call(a,g));i&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(k)&&(delete r.handle,n._removeData(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,m,o=[d||z],p=j.call(b,"type")?b.type:b,q=j.call(b,"namespace")?b.namespace.split("."):[];if(h=l=d=d||z,3!==d.nodeType&&8!==d.nodeType&&!_.test(p+n.event.triggered)&&(p.indexOf(".")>=0&&(q=p.split("."),p=q.shift(),q.sort()),g=p.indexOf(":")<0&&"on"+p,b=b[n.expando]?b:new n.Event(p,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),k=n.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!n.isWindow(d)){for(i=k.delegateType||p,_.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||z)&&o.push(l.defaultView||l.parentWindow||a)}m=0;while((h=o[m++])&&!b.isPropagationStopped())b.type=m>1?i:k.bindType||p,f=(n._data(h,"events")||{})[b.type]&&n._data(h,"handle"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&n.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&n.acceptData(d)&&g&&d[p]&&!n.isWindow(d)){l=d[g],l&&(d[g]=null),n.event.triggered=p;try{d[p]()}catch(r){}n.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(n._data(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((n.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+" ",void 0===e[c]&&(e[c]=d.needsContext?n(c,this).index(i)>=0:n.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=$.test(e)?this.mouseHooks:Z.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||z),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||z,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==db()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===db()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return n.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=z.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]===L&&(a[d]=null),a.detachEvent(d,c))},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&(a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault())?bb:cb):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:cb,isPropagationStopped:cb,isImmediatePropagationStopped:cb,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=bb,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=bb,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=bb,this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.submitBubbles||(n.event.special.submit={setup:function(){return n.nodeName(this,"form")?!1:void n.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=n.nodeName(b,"input")||n.nodeName(b,"button")?b.form:void 0;c&&!n._data(c,"submitBubbles")&&(n.event.add(c,"submit._submit",function(a){a._submit_bubble=!0}),n._data(c,"submitBubbles",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&n.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){return n.nodeName(this,"form")?!1:void n.event.remove(this,"._submit")}}),l.changeBubbles||(n.event.special.change={setup:function(){return Y.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(n.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._just_changed=!0)}),n.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),n.event.simulate("change",this,a,!0)})),!1):void n.event.add(this,"beforeactivate._change",function(a){var b=a.target;Y.test(b.nodeName)&&!n._data(b,"changeBubbles")&&(n.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||n.event.simulate("change",this.parentNode,a,!0)}),n._data(b,"changeBubbles",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return n.event.remove(this,"._change"),!Y.test(this.nodeName)}}),l.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=n._data(d,b);e||d.addEventListener(a,c,!0),n._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=n._data(d,b)-1;e?n._data(d,b,e):(d.removeEventListener(a,c,!0),n._removeData(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=cb;else if(!d)return this;return 1===e&&(g=d,d=function(a){return n().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=cb),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});function eb(a){var b=fb.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var fb="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gb=/ jQuery\d+="(?:null|\d+)"/g,hb=new RegExp("<(?:"+fb+")[\\s/>]","i"),ib=/^\s+/,jb=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,kb=/<([\w:]+)/,lb=/<tbody/i,mb=/<|&#?\w+;/,nb=/<(?:script|style|link)/i,ob=/checked\s*(?:[^=]|=\s*.checked.)/i,pb=/^$|\/(?:java|ecma)script/i,qb=/^true\/(.*)/,rb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,sb={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:l.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},tb=eb(z),ub=tb.appendChild(z.createElement("div"));sb.optgroup=sb.option,sb.tbody=sb.tfoot=sb.colgroup=sb.caption=sb.thead,sb.th=sb.td;function vb(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==L?a.getElementsByTagName(b||"*"):typeof a.querySelectorAll!==L?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||n.nodeName(d,b)?f.push(d):n.merge(f,vb(d,b));return void 0===b||b&&n.nodeName(a,b)?n.merge([a],f):f}function wb(a){X.test(a.type)&&(a.defaultChecked=a.checked)}function xb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function yb(a){return a.type=(null!==n.find.attr(a,"type"))+"/"+a.type,a}function zb(a){var b=qb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ab(a,b){for(var c,d=0;null!=(c=a[d]);d++)n._data(c,"globalEval",!b||n._data(b[d],"globalEval"))}function Bb(a,b){if(1===b.nodeType&&n.hasData(a)){var c,d,e,f=n._data(a),g=n._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)n.event.add(b,c,h[c][d])}g.data&&(g.data=n.extend({},g.data))}}function Cb(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!l.noCloneEvent&&b[n.expando]){e=n._data(b);for(d in e.events)n.removeEvent(b,d,e.handle);b.removeAttribute(n.expando)}"script"===c&&b.text!==a.text?(yb(b).text=a.text,zb(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),l.html5Clone&&a.innerHTML&&!n.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&X.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}n.extend({clone:function(a,b,c){var d,e,f,g,h,i=n.contains(a.ownerDocument,a);if(l.html5Clone||n.isXMLDoc(a)||!hb.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(ub.innerHTML=a.outerHTML,ub.removeChild(f=ub.firstChild)),!(l.noCloneEvent&&l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(d=vb(f),h=vb(a),g=0;null!=(e=h[g]);++g)d[g]&&Cb(e,d[g]);if(b)if(c)for(h=h||vb(a),d=d||vb(f),g=0;null!=(e=h[g]);g++)Bb(e,d[g]);else Bb(a,f);return d=vb(f,"script"),d.length>0&&Ab(d,!i&&vb(a,"script")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k,m=a.length,o=eb(b),p=[],q=0;m>q;q++)if(f=a[q],f||0===f)if("object"===n.type(f))n.merge(p,f.nodeType?[f]:f);else if(mb.test(f)){h=h||o.appendChild(b.createElement("div")),i=(kb.exec(f)||["",""])[1].toLowerCase(),k=sb[i]||sb._default,h.innerHTML=k[1]+f.replace(jb,"<$1></$2>")+k[2],e=k[0];while(e--)h=h.lastChild;if(!l.leadingWhitespace&&ib.test(f)&&p.push(b.createTextNode(ib.exec(f)[0])),!l.tbody){f="table"!==i||lb.test(f)?"<table>"!==k[1]||lb.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)n.nodeName(j=f.childNodes[e],"tbody")&&!j.childNodes.length&&f.removeChild(j)}n.merge(p,h.childNodes),h.textContent="";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),l.appendChecked||n.grep(vb(p,"input"),wb),q=0;while(f=p[q++])if((!d||-1===n.inArray(f,d))&&(g=n.contains(f.ownerDocument,f),h=vb(o.appendChild(f),"script"),g&&Ab(h),c)){e=0;while(f=h[e++])pb.test(f.type||"")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=n.expando,j=n.cache,k=l.deleteExpando,m=n.event.special;null!=(d=a[h]);h++)if((b||n.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)m[e]?n.event.remove(d,e):n.removeEvent(d,e,g.handle);j[f]&&(delete j[f],k?delete d[i]:typeof d.removeAttribute!==L?d.removeAttribute(i):d[i]=null,c.push(f))}}}),n.fn.extend({text:function(a){return W(this,function(a){return void 0===a?n.text(this):this.empty().append((this[0]&&this[0].ownerDocument||z).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=xb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=xb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(vb(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&Ab(vb(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&n.cleanData(vb(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&n.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return W(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(gb,""):void 0;if(!("string"!=typeof a||nb.test(a)||!l.htmlSerialize&&hb.test(a)||!l.leadingWhitespace&&ib.test(a)||sb[(kb.exec(a)||["",""])[1].toLowerCase()])){a=a.replace(jb,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(vb(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(vb(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,k=this.length,m=this,o=k-1,p=a[0],q=n.isFunction(p);if(q||k>1&&"string"==typeof p&&!l.checkClone&&ob.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(k&&(i=n.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=n.map(vb(i,"script"),yb),f=g.length;k>j;j++)d=i,j!==o&&(d=n.clone(d,!0,!0),f&&n.merge(g,vb(d,"script"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,n.map(g,zb),j=0;f>j;j++)d=g[j],pb.test(d.type||"")&&!n._data(d,"globalEval")&&n.contains(h,d)&&(d.src?n._evalUrl&&n._evalUrl(d.src):n.globalEval((d.text||d.textContent||d.innerHTML||"").replace(rb,"")));i=c=null}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=0,e=[],g=n(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),n(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Db,Eb={};function Fb(b,c){var d=n(c.createElement(b)).appendTo(c.body),e=a.getDefaultComputedStyle?a.getDefaultComputedStyle(d[0]).display:n.css(d[0],"display");return d.detach(),e}function Gb(a){var b=z,c=Eb[a];return c||(c=Fb(a,b),"none"!==c&&c||(Db=(Db||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Db[0].contentWindow||Db[0].contentDocument).document,b.write(),b.close(),c=Fb(a,b),Db.detach()),Eb[a]=c),c}!function(){var a,b,c=z.createElement("div"),d="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";c.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=c.getElementsByTagName("a")[0],a.style.cssText="float:left;opacity:.5",l.opacity=/^0.5/.test(a.style.opacity),l.cssFloat=!!a.style.cssFloat,c.style.backgroundClip="content-box",c.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===c.style.backgroundClip,a=c=null,l.shrinkWrapBlocks=function(){var a,c,e,f;if(null==b){if(a=z.getElementsByTagName("body")[0],!a)return;f="border:0;width:0;height:0;position:absolute;top:0;left:-9999px",c=z.createElement("div"),e=z.createElement("div"),a.appendChild(c).appendChild(e),b=!1,typeof e.style.zoom!==L&&(e.style.cssText=d+";width:1px;padding:1px;zoom:1",e.innerHTML="<div></div>",e.firstChild.style.width="5px",b=3!==e.offsetWidth),a.removeChild(c),a=c=e=null}return b}}();var Hb=/^margin/,Ib=new RegExp("^("+T+")(?!px)[a-z%]+$","i"),Jb,Kb,Lb=/^(top|right|bottom|left)$/;a.getComputedStyle?(Jb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)},Kb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Jb(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),Ib.test(g)&&Hb.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):z.documentElement.currentStyle&&(Jb=function(a){return a.currentStyle},Kb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Jb(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ib.test(g)&&!Lb.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function Mb(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h=z.createElement("div"),i="border:0;width:0;height:0;position:absolute;top:0;left:-9999px",j="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0";h.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",b=h.getElementsByTagName("a")[0],b.style.cssText="float:left;opacity:.5",l.opacity=/^0.5/.test(b.style.opacity),l.cssFloat=!!b.style.cssFloat,h.style.backgroundClip="content-box",h.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===h.style.backgroundClip,b=h=null,n.extend(l,{reliableHiddenOffsets:function(){if(null!=c)return c;var a,b,d,e=z.createElement("div"),f=z.getElementsByTagName("body")[0];if(f)return e.setAttribute("className","t"),e.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=z.createElement("div"),a.style.cssText=i,f.appendChild(a).appendChild(e),e.innerHTML="<table><tr><td></td><td>t</td></tr></table>",b=e.getElementsByTagName("td"),b[0].style.cssText="padding:0;margin:0;border:0;display:none",d=0===b[0].offsetHeight,b[0].style.display="",b[1].style.display="none",c=d&&0===b[0].offsetHeight,f.removeChild(a),e=f=null,c},boxSizing:function(){return null==d&&k(),d},boxSizingReliable:function(){return null==e&&k(),e},pixelPosition:function(){return null==f&&k(),f},reliableMarginRight:function(){var b,c,d,e;if(null==g&&a.getComputedStyle){if(b=z.getElementsByTagName("body")[0],!b)return;c=z.createElement("div"),d=z.createElement("div"),c.style.cssText=i,b.appendChild(c).appendChild(d),e=d.appendChild(z.createElement("div")),e.style.cssText=d.style.cssText=j,e.style.marginRight=e.style.width="0",d.style.width="1px",g=!parseFloat((a.getComputedStyle(e,null)||{}).marginRight),b.removeChild(c)}return g}});function k(){var b,c,h=z.getElementsByTagName("body")[0];h&&(b=z.createElement("div"),c=z.createElement("div"),b.style.cssText=i,h.appendChild(b).appendChild(c),c.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%",n.swap(h,null!=h.style.zoom?{zoom:1}:{},function(){d=4===c.offsetWidth}),e=!0,f=!1,g=!0,a.getComputedStyle&&(f="1%"!==(a.getComputedStyle(c,null)||{}).top,e="4px"===(a.getComputedStyle(c,null)||{width:"4px"}).width),h.removeChild(b),c=h=null)}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Nb=/alpha\([^)]*\)/i,Ob=/opacity\s*=\s*([^)]*)/,Pb=/^(none|table(?!-c[ea]).+)/,Qb=new RegExp("^("+T+")(.*)$","i"),Rb=new RegExp("^([+-])=("+T+")","i"),Sb={position:"absolute",visibility:"hidden",display:"block"},Tb={letterSpacing:0,fontWeight:400},Ub=["Webkit","O","Moz","ms"];function Vb(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ub.length;while(e--)if(b=Ub[e]+c,b in a)return b;return d}function Wb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=n._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&V(d)&&(f[g]=n._data(d,"olddisplay",Gb(d.nodeName)))):f[g]||(e=V(d),(c&&"none"!==c||!e)&&n._data(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function Xb(a,b,c){var d=Qb.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Yb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+U[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+U[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+U[f]+"Width",!0,e))):(g+=n.css(a,"padding"+U[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+U[f]+"Width",!0,e)));return g}function Zb(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=Jb(a),g=l.boxSizing()&&"border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=Kb(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ib.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Yb(a,b,c||(g?"border":"content"),d,f)+"px"}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Kb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":l.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;if(b=n.cssProps[h]||(n.cssProps[h]=Vb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=Rb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]="",i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Vb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Kb(a,b,d)),"normal"===f&&b in Tb&&(f=Tb[b]),""===c||c?(e=parseFloat(f),c===!0||n.isNumeric(e)?e||0:f):f}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?0===a.offsetWidth&&Pb.test(n.css(a,"display"))?n.swap(a,Sb,function(){return Zb(a,b,d)}):Zb(a,b,d):void 0},set:function(a,c,d){var e=d&&Jb(a);return Xb(a,c,d?Yb(a,b,d,l.boxSizing()&&"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),l.opacity||(n.cssHooks.opacity={get:function(a,b){return Ob.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=n.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===n.trim(f.replace(Nb,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Nb.test(f)?f.replace(Nb,e):f+" "+e)}}),n.cssHooks.marginRight=Mb(l.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},Kb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+U[d]+b]=f[d]||f[d-2]||f[0];return e}},Hb.test(a)||(n.cssHooks[a+b].set=Xb)}),n.fn.extend({css:function(a,b){return W(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Jb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)
},a,b,arguments.length>1)},show:function(){return Wb(this,!0)},hide:function(){return Wb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){V(this)?n(this).show():n(this).hide()})}});function $b(a,b,c,d,e){return new $b.prototype.init(a,b,c,d,e)}n.Tween=$b,$b.prototype={constructor:$b,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=$b.propHooks[this.prop];return a&&a.get?a.get(this):$b.propHooks._default.get(this)},run:function(a){var b,c=$b.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):$b.propHooks._default.set(this),this}},$b.prototype.init.prototype=$b.prototype,$b.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},$b.propHooks.scrollTop=$b.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=$b.prototype.init,n.fx.step={};var _b,ac,bc=/^(?:toggle|show|hide)$/,cc=new RegExp("^(?:([+-])=|)("+T+")([a-z%]*)$","i"),dc=/queueHooks$/,ec=[jc],fc={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=cc.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&cc.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function gc(){return setTimeout(function(){_b=void 0}),_b=n.now()}function hc(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=U[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function ic(a,b,c){for(var d,e=(fc[b]||[]).concat(fc["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function jc(a,b,c){var d,e,f,g,h,i,j,k,m=this,o={},p=a.style,q=a.nodeType&&V(a),r=n._data(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,m.always(function(){m.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=n.css(a,"display"),k=Gb(a.nodeName),"none"===j&&(j=k),"inline"===j&&"none"===n.css(a,"float")&&(l.inlineBlockNeedsLayout&&"inline"!==k?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",l.shrinkWrapBlocks()||m.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],bc.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||n.style(a,d)}if(!n.isEmptyObject(o)){r?"hidden"in r&&(q=r.hidden):r=n._data(a,"fxshow",{}),f&&(r.hidden=!q),q?n(a).show():m.done(function(){n(a).hide()}),m.done(function(){var b;n._removeData(a,"fxshow");for(b in o)n.style(a,b,o[b])});for(d in o)g=ic(q?r[d]:0,d,m),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function kc(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function lc(a,b,c){var d,e,f=0,g=ec.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=_b||gc(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:_b||gc(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(kc(k,j.opts.specialEasing);g>f;f++)if(d=ec[f].call(j,a,k,j.opts))return d;return n.map(k,ic,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(lc,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],fc[c]=fc[c]||[],fc[c].unshift(b)},prefilter:function(a,b){b?ec.unshift(a):ec.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(V).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=lc(this,n.extend({},a),f);(e||n._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=n._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&dc.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=n._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(hc(b,!0),a,d,e)}}),n.each({slideDown:hc("show"),slideUp:hc("hide"),slideToggle:hc("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=n.timers,c=0;for(_b=n.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||n.fx.stop(),_b=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){ac||(ac=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(ac),ac=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e=z.createElement("div");e.setAttribute("className","t"),e.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=e.getElementsByTagName("a")[0],c=z.createElement("select"),d=c.appendChild(z.createElement("option")),b=e.getElementsByTagName("input")[0],a.style.cssText="top:1px",l.getSetAttribute="t"!==e.className,l.style=/top/.test(a.getAttribute("style")),l.hrefNormalized="/a"===a.getAttribute("href"),l.checkOn=!!b.value,l.optSelected=d.selected,l.enctype=!!z.createElement("form").enctype,c.disabled=!0,l.optDisabled=!d.disabled,b=z.createElement("input"),b.setAttribute("value",""),l.input=""===b.getAttribute("value"),b.value="t",b.setAttribute("type","radio"),l.radioValue="t"===b.value,a=b=c=d=e=null}();var mc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(mc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.text(a)}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(l.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)if(d=e[g],n.inArray(n.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var nc,oc,pc=n.expr.attrHandle,qc=/^(?:checked|selected)$/i,rc=l.getSetAttribute,sc=l.input;n.fn.extend({attr:function(a,b){return W(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===L?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?oc:nc)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(F);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)?sc&&rc||!qc.test(c)?a[d]=!1:a[n.camelCase("default-"+c)]=a[d]=!1:n.attr(a,c,""),a.removeAttribute(rc?c:d)},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),oc={set:function(a,b,c){return b===!1?n.removeAttr(a,c):sc&&rc||!qc.test(c)?a.setAttribute(!rc&&n.propFix[c]||c,c):a[n.camelCase("default-"+c)]=a[c]=!0,c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=pc[b]||n.find.attr;pc[b]=sc&&rc||!qc.test(b)?function(a,b,d){var e,f;return d||(f=pc[b],pc[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,pc[b]=f),e}:function(a,b,c){return c?void 0:a[n.camelCase("default-"+b)]?b.toLowerCase():null}}),sc&&rc||(n.attrHooks.value={set:function(a,b,c){return n.nodeName(a,"input")?void(a.defaultValue=b):nc&&nc.set(a,b,c)}}),rc||(nc={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},pc.id=pc.name=pc.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},n.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:nc.set},n.attrHooks.contenteditable={set:function(a,b,c){nc.set(a,""===b?!1:b,c)}},n.each(["width","height"],function(a,b){n.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),l.style||(n.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var tc=/^(?:input|select|textarea|button|object)$/i,uc=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return W(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return a=n.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):tc.test(a.nodeName)||uc.test(a.nodeName)&&a.href?0:-1}}}}),l.hrefNormalized||n.each(["href","src"],function(a,b){n.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this}),l.enctype||(n.propFix.enctype="encoding");var vc=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j="string"==typeof a&&a;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(F)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(vc," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||"string"==typeof a&&a;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||"").match(F)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(vc," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(F)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===L||"boolean"===c)&&(this.className&&n._data(this,"__className__",this.className),this.className=this.className||a===!1?"":n._data(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(vc," ").indexOf(b)>=0)return!0;return!1}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var wc=n.now(),xc=/\?/,yc=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;n.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=n.trim(b+"");return e&&!n.trim(e.replace(yc,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():n.error("Invalid JSON: "+b)},n.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,"text/xml")):(c=new ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var zc,Ac,Bc=/#.*$/,Cc=/([?&])_=[^&]*/,Dc=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Ec=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Fc=/^(?:GET|HEAD)$/,Gc=/^\/\//,Hc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Ic={},Jc={},Kc="*/".concat("*");try{Ac=location.href}catch(Lc){Ac=z.createElement("a"),Ac.href="",Ac=Ac.href}zc=Hc.exec(Ac.toLowerCase())||[];function Mc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(F)||[];if(n.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nc(a,b,c,d){var e={},f=a===Jc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Oc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&n.extend(!0,a,c),a}function Pc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Qc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ac,type:"GET",isLocal:Ec.test(zc[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Oc(Oc(a,n.ajaxSettings),b):Oc(n.ajaxSettings,a)},ajaxPrefilter:Mc(Ic),ajaxTransport:Mc(Jc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Dc.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||Ac)+"").replace(Bc,"").replace(Gc,zc[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(F)||[""],null==k.crossDomain&&(c=Hc.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===zc[1]&&c[2]===zc[2]&&(c[3]||("http:"===c[1]?"80":"443"))===(zc[3]||("http:"===zc[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),Nc(Ic,k,b,v),2===t)return v;h=k.global,h&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!Fc.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(xc.test(e)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=Cc.test(e)?e.replace(Cc,"$1_="+wc++):e+(xc.test(e)?"&":"?")+"_="+wc++)),k.ifModified&&(n.lastModified[e]&&v.setRequestHeader("If-Modified-Since",n.lastModified[e]),n.etag[e]&&v.setRequestHeader("If-None-Match",n.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+Kc+"; q=0.01":""):k.accepts["*"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Nc(Jc,k,b,v)){v.readyState=1,h&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Pc(k,v,c)),u=Qc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[e]=w),w=v.getResponseHeader("etag"),w&&(n.etag[e]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){if(n.isFunction(a))return this.each(function(b){n(this).wrapAll(a.call(this,b))});if(this[0]){var b=n(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!l.reliableHiddenOffsets()&&"none"===(a.style&&a.style.display||n.css(a,"display"))},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var Rc=/%20/g,Sc=/\[\]$/,Tc=/\r?\n/g,Uc=/^(?:submit|button|image|reset|file)$/i,Vc=/^(?:input|select|textarea|keygen)/i;function Wc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||Sc.test(a)?d(a,e):Wc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Wc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Wc(c,a[c],b,e);return d.join("&").replace(Rc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Vc.test(this.nodeName)&&!Uc.test(a)&&(this.checked||!X.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(Tc,"\r\n")}}):{name:b.name,value:c.replace(Tc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&$c()||_c()}:$c;var Xc=0,Yc={},Zc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on("unload",function(){for(var a in Yc)Yc[a](void 0,!0)}),l.cors=!!Zc&&"withCredentials"in Zc,Zc=l.ajax=!!Zc,Zc&&n.ajaxTransport(function(a){if(!a.crossDomain||l.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Xc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+"");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Yc[g],b=void 0,f.onreadystatechange=n.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,"string"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=""}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Yc[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function $c(){try{return new a.XMLHttpRequest}catch(b){}}function _c(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=z.head||n("head")[0]||z.documentElement;return{send:function(d,e){b=z.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var ad=[],bd=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=ad.pop()||n.expando+"_"+wc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(bd.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&bd.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(bd,"$1"+e):b.jsonp!==!1&&(b.url+=(xc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,ad.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||z;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var cd=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&cd)return cd.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=a.slice(h,a.length),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(f="POST"),g.length>0&&n.ajax({url:a,type:f,dataType:"html",data:b}).done(function(a){e=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var dd=a.document.documentElement;function ed(a){return n.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&n.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,n.contains(b,e)?(typeof e.getBoundingClientRect!==L&&(d=e.getBoundingClientRect()),c=ed(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===n.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(c=a.offset()),c.top+=n.css(a[0],"borderTopWidth",!0),c.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-c.top-n.css(d,"marginTop",!0),left:b.left-c.left-n.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||dd;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||dd})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);n.fn[a]=function(d){return W(this,function(a,d,e){var f=ed(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?n(f).scrollLeft():e,c?e:n(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=Mb(l.pixelPosition,function(a,c){return c?(c=Kb(a,b),Ib.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return W(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var fd=a.jQuery,gd=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=gd),b&&a.jQuery===n&&(a.jQuery=fd),n},typeof b===L&&(a.jQuery=a.$=n),n});

$(document).ready(function () {
  $.ajaxSetup({
    headers: {
      'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
  });

  $('.js-cart-product').on('click', function() {
    $quantity  = $(this).closest('.group-quantity').find('.js-quantity');
    $cartId    = $(this).data('cart-id');
    $productId = $(this).data('product-id');

    $.ajax({
      type: 'POST',
      url: $(this).data('url'),
      data: {
        _method: 'PUT',
        id: $cartId,
        fk_product_id: $productId,
        ct_quantity: $quantity
      },
      success: function(result) {
        window.location.reload();
      }
    });
  });

  $('.js-delete-cart').on('click', function() {
    $.ajax({
      type: 'GET',
      url: $(this).data('url'),
      data: {
        _method: 'DELETE'
      },
      success: function(result) {
        window.location.reload();
      }
    });
  });

  $('.js-option-provinces').on('change', function() {
    $provinceName = $('.js-option-provinces').val();

    $.ajax({
      type: 'POST',
      url: $(this).data('url'),
      data: {
        _method: 'POST',
        province: $provinceName
      },
      success: function(result) {
        $('.js-option-amphure').html(result['amphures']);
        $('.js-option-district').html(result['district']);
      }
    });
  });

  $('.js-option-amphure').on('change', function() {
    $amphureName = $('.js-option-amphure').val();

    $.ajax({
      type: 'POST',
      url: $(this).data('url'),
      data: {
        _method: 'POST',
        amphure: $amphureName
      },
      success: function(result) {
        $('.js-option-district').html(result['district']);
      }
    });
  });
});
$(document).ready(function () {
  $.ajaxSetup({
    headers: {
      'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content')
    }
  });

  $('.js-order-create').on('click', function() {
    $first_name        = $('input[name="oa_first_name"]').val();
    $last_name         = $('input[name="oa_last_name"]').val();
    $tel               = $('input[name="oa_tel"]').val();
    $address           = $('input[name="oa_address"]').val();
    $province          = $('select[name="oa_province"]').val();
    $district          = $('select[name="oa_district"]').val();
    $sub_district      = $('select[name="oa_sub_district"]').val();
    $postcode          = $('input[name="oa_postcode"]').val();
    $isbilling_address = $('input[name="oa_isbilling_address"]:checked').val();
    $billign_address   = $('textarea[name="oa_billign_address"]').val();

    if($first_name == '') {
      $('input[name="oa_first_name"]').focus();
    }
    else if($last_name == '') {
      $('input[name="oa_last_name"]').focus();
    }
    else if($tel == '') {
      $('input[name="oa_tel"]').focus();
    }
    else if($address == '') {
      $('input[name="oa_address"]').focus();
    }
    else if($province == 0) {
      $('select[name="oa_province"]').focus();
    }
    else if($district == 0) {
      $('select[name="oa_district"]').focus();
    }
    else if($sub_district == 0) {
      $('select[name="oa_sub_district"]').focus();
    }
    else if($postcode == '' || $postcode.length < 5) {
      $('input[name="oa_postcode"]').focus();
    }
    // else if($('input[name="oa_isbilling_address"]').is(':checked')) {
    //   $('#js-checkout').submit();
    // }
    // else if($billign_address == '') {
    //   $('textarea[name="oa_billign_address"]').focus();
    // }
    else
    {
      $('#js-checkout').submit();
    }
  });
});

/*!
 * fancyBox - jQuery Plugin
 * version: 2.1.5 (Fri, 14 Jun 2013)
 * @requires jQuery v1.6 or later
 *
 * Examples at http://fancyapps.com/fancybox/
 * License: www.fancyapps.com/fancybox/#license
 *
 * Copyright 2012 Janis Skarnelis - janis@fancyapps.com
 *
 */

(function (window, document, $, undefined) {
	"use strict";

	var H = $("html"),
		W = $(window),
		D = $(document),
		F = $.fancybox = function () {
			F.open.apply( this, arguments );
		},
		IE =  navigator.userAgent.match(/msie/i),
		didUpdate	= null,
		isTouch		= document.createTouch !== undefined,

		isQuery	= function(obj) {
			return obj && obj.hasOwnProperty && obj instanceof $;
		},
		isString = function(str) {
			return str && $.type(str) === "string";
		},
		isPercentage = function(str) {
			return isString(str) && str.indexOf('%') > 0;
		},
		isScrollable = function(el) {
			return (el && !(el.style.overflow && el.style.overflow === 'hidden') && ((el.clientWidth && el.scrollWidth > el.clientWidth) || (el.clientHeight && el.scrollHeight > el.clientHeight)));
		},
		getScalar = function(orig, dim) {
			var value = parseInt(orig, 10) || 0;

			if (dim && isPercentage(orig)) {
				value = F.getViewport()[ dim ] / 100 * value;
			}

			return Math.ceil(value);
		},
		getValue = function(value, dim) {
			return getScalar(value, dim) + 'px';
		};

	$.extend(F, {
		// The current version of fancyBox
		version: '2.1.5',

		defaults: {
			padding : 15,
			margin  : 20,

			width     : 800,
			height    : 600,
			minWidth  : 100,
			minHeight : 100,
			maxWidth  : 9999,
			maxHeight : 9999,
			pixelRatio: 1, // Set to 2 for retina display support

			autoSize   : true,
			autoHeight : false,
			autoWidth  : false,

			autoResize  : true,
			autoCenter  : !isTouch,
			fitToView   : true,
			aspectRatio : false,
			topRatio    : 0.5,
			leftRatio   : 0.5,

			scrolling : 'auto', // 'auto', 'yes' or 'no'
			wrapCSS   : '',

			arrows     : true,
			closeBtn   : true,
			closeClick : false,
			nextClick  : false,
			mouseWheel : true,
			autoPlay   : false,
			playSpeed  : 3000,
			preload    : 3,
			modal      : false,
			loop       : true,

			ajax  : {
				dataType : 'html',
				headers  : { 'X-fancyBox': true }
			},
			iframe : {
				scrolling : 'auto',
				preload   : true
			},
			swf : {
				wmode: 'transparent',
				allowfullscreen   : 'true',
				allowscriptaccess : 'always'
			},

			keys  : {
				next : {
					13 : 'left', // enter
					34 : 'up',   // page down
					39 : 'left', // right arrow
					40 : 'up'    // down arrow
				},
				prev : {
					8  : 'right',  // backspace
					33 : 'down',   // page up
					37 : 'right',  // left arrow
					38 : 'down'    // up arrow
				},
				close  : [27], // escape key
				play   : [32], // space - start/stop slideshow
				toggle : [70]  // letter "f" - toggle fullscreen
			},

			direction : {
				next : 'left',
				prev : 'right'
			},

			scrollOutside  : true,

			// Override some properties
			index   : 0,
			type    : null,
			href    : null,
			content : null,
			title   : null,

			// HTML templates
			tpl: {
				wrap     : '<div class="fancybox-wrap" tabIndex="-1"><div class="fancybox-skin"><div class="fancybox-outer"><div class="fancybox-inner"></div></div></div></div>',
				image    : '<img class="fancybox-image" src="{href}" alt="" />',
				iframe   : '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen' + (IE ? ' allowtransparency="true"' : '') + '></iframe>',
				error    : '<p class="fancybox-error">The requested content cannot be loaded.<br/>Please try again later.</p>',
				closeBtn : '<a title="Close" class="fancybox-item fancybox-close" href="javascript:;"></a>',
				next     : '<a title="Next" class="fancybox-nav fancybox-next" href="javascript:;"><span></span></a>',
				prev     : '<a title="Previous" class="fancybox-nav fancybox-prev" href="javascript:;"><span></span></a>'
			},

			// Properties for each animation type
			// Opening fancyBox
			openEffect  : 'fade', // 'elastic', 'fade' or 'none'
			openSpeed   : 250,
			openEasing  : 'swing',
			openOpacity : true,
			openMethod  : 'zoomIn',

			// Closing fancyBox
			closeEffect  : 'fade', // 'elastic', 'fade' or 'none'
			closeSpeed   : 250,
			closeEasing  : 'swing',
			closeOpacity : true,
			closeMethod  : 'zoomOut',

			// Changing next gallery item
			nextEffect : 'elastic', // 'elastic', 'fade' or 'none'
			nextSpeed  : 250,
			nextEasing : 'swing',
			nextMethod : 'changeIn',

			// Changing previous gallery item
			prevEffect : 'elastic', // 'elastic', 'fade' or 'none'
			prevSpeed  : 250,
			prevEasing : 'swing',
			prevMethod : 'changeOut',

			// Enable default helpers
			helpers : {
				overlay : true,
				title   : true
			},

			// Callbacks
			onCancel     : $.noop, // If canceling
			beforeLoad   : $.noop, // Before loading
			afterLoad    : $.noop, // After loading
			beforeShow   : $.noop, // Before changing in current item
			afterShow    : $.noop, // After opening
			beforeChange : $.noop, // Before changing gallery item
			beforeClose  : $.noop, // Before closing
			afterClose   : $.noop  // After closing
		},

		//Current state
		group    : {}, // Selected group
		opts     : {}, // Group options
		previous : null,  // Previous element
		coming   : null,  // Element being loaded
		current  : null,  // Currently loaded element
		isActive : false, // Is activated
		isOpen   : false, // Is currently open
		isOpened : false, // Have been fully opened at least once

		wrap  : null,
		skin  : null,
		outer : null,
		inner : null,

		player : {
			timer    : null,
			isActive : false
		},

		// Loaders
		ajaxLoad   : null,
		imgPreload : null,

		// Some collections
		transitions : {},
		helpers     : {},

		/*
		 *	Static methods
		 */

		open: function (group, opts) {
			if (!group) {
				return;
			}

			if (!$.isPlainObject(opts)) {
				opts = {};
			}

			// Close if already active
			if (false === F.close(true)) {
				return;
			}

			// Normalize group
			if (!$.isArray(group)) {
				group = isQuery(group) ? $(group).get() : [group];
			}

			// Recheck if the type of each element is `object` and set content type (image, ajax, etc)
			$.each(group, function(i, element) {
				var obj = {},
					href,
					title,
					content,
					type,
					rez,
					hrefParts,
					selector;

				if ($.type(element) === "object") {
					// Check if is DOM element
					if (element.nodeType) {
						element = $(element);
					}

					if (isQuery(element)) {
						obj = {
							href    : element.data('fancybox-href') || element.attr('href'),
							title   : element.data('fancybox-title') || element.attr('title'),
							isDom   : true,
							element : element
						};

						if ($.metadata) {
							$.extend(true, obj, element.metadata());
						}

					} else {
						obj = element;
					}
				}

				href  = opts.href  || obj.href || (isString(element) ? element : null);
				title = opts.title !== undefined ? opts.title : obj.title || '';

				content = opts.content || obj.content;
				type    = content ? 'html' : (opts.type  || obj.type);

				if (!type && obj.isDom) {
					type = element.data('fancybox-type');

					if (!type) {
						rez  = element.prop('class').match(/fancybox\.(\w+)/);
						type = rez ? rez[1] : null;
					}
				}

				if (isString(href)) {
					// Try to guess the content type
					if (!type) {
						if (F.isImage(href)) {
							type = 'image';

						} else if (F.isSWF(href)) {
							type = 'swf';

						} else if (href.charAt(0) === '#') {
							type = 'inline';

						} else if (isString(element)) {
							type    = 'html';
							content = element;
						}
					}

					// Split url into two pieces with source url and content selector, e.g,
					// "/mypage.html #my_id" will load "/mypage.html" and display element having id "my_id"
					if (type === 'ajax') {
						hrefParts = href.split(/\s+/, 2);
						href      = hrefParts.shift();
						selector  = hrefParts.shift();
					}
				}

				if (!content) {
					if (type === 'inline') {
						if (href) {
							content = $( isString(href) ? href.replace(/.*(?=#[^\s]+$)/, '') : href ); //strip for ie7

						} else if (obj.isDom) {
							content = element;
						}

					} else if (type === 'html') {
						content = href;

					} else if (!type && !href && obj.isDom) {
						type    = 'inline';
						content = element;
					}
				}

				$.extend(obj, {
					href     : href,
					type     : type,
					content  : content,
					title    : title,
					selector : selector
				});

				group[ i ] = obj;
			});

			// Extend the defaults
			F.opts = $.extend(true, {}, F.defaults, opts);

			// All options are merged recursive except keys
			if (opts.keys !== undefined) {
				F.opts.keys = opts.keys ? $.extend({}, F.defaults.keys, opts.keys) : false;
			}

			F.group = group;

			return F._start(F.opts.index);
		},

		// Cancel image loading or abort ajax request
		cancel: function () {
			var coming = F.coming;

			if (!coming || false === F.trigger('onCancel')) {
				return;
			}

			F.hideLoading();

			if (F.ajaxLoad) {
				F.ajaxLoad.abort();
			}

			F.ajaxLoad = null;

			if (F.imgPreload) {
				F.imgPreload.onload = F.imgPreload.onerror = null;
			}

			if (coming.wrap) {
				coming.wrap.stop(true, true).trigger('onReset').remove();
			}

			F.coming = null;

			// If the first item has been canceled, then clear everything
			if (!F.current) {
				F._afterZoomOut( coming );
			}
		},

		// Start closing animation if is open; remove immediately if opening/closing
		close: function (event) {
			F.cancel();

			if (false === F.trigger('beforeClose')) {
				return;
			}

			F.unbindEvents();

			if (!F.isActive) {
				return;
			}

			if (!F.isOpen || event === true) {
				$('.fancybox-wrap').stop(true).trigger('onReset').remove();

				F._afterZoomOut();

			} else {
				F.isOpen = F.isOpened = false;
				F.isClosing = true;

				$('.fancybox-item, .fancybox-nav').remove();

				F.wrap.stop(true, true).removeClass('fancybox-opened');

				F.transitions[ F.current.closeMethod ]();
			}
		},

		// Manage slideshow:
		//   $.fancybox.play(); - toggle slideshow
		//   $.fancybox.play( true ); - start
		//   $.fancybox.play( false ); - stop
		play: function ( action ) {
			var clear = function () {
					clearTimeout(F.player.timer);
				},
				set = function () {
					clear();

					if (F.current && F.player.isActive) {
						F.player.timer = setTimeout(F.next, F.current.playSpeed);
					}
				},
				stop = function () {
					clear();

					D.unbind('.player');

					F.player.isActive = false;

					F.trigger('onPlayEnd');
				},
				start = function () {
					if (F.current && (F.current.loop || F.current.index < F.group.length - 1)) {
						F.player.isActive = true;

						D.bind({
							'onCancel.player beforeClose.player' : stop,
							'onUpdate.player'   : set,
							'beforeLoad.player' : clear
						});

						set();

						F.trigger('onPlayStart');
					}
				};

			if (action === true || (!F.player.isActive && action !== false)) {
				start();
			} else {
				stop();
			}
		},

		// Navigate to next gallery item
		next: function ( direction ) {
			var current = F.current;

			if (current) {
				if (!isString(direction)) {
					direction = current.direction.next;
				}

				F.jumpto(current.index + 1, direction, 'next');
			}
		},

		// Navigate to previous gallery item
		prev: function ( direction ) {
			var current = F.current;

			if (current) {
				if (!isString(direction)) {
					direction = current.direction.prev;
				}

				F.jumpto(current.index - 1, direction, 'prev');
			}
		},

		// Navigate to gallery item by index
		jumpto: function ( index, direction, router ) {
			var current = F.current;

			if (!current) {
				return;
			}

			index = getScalar(index);

			F.direction = direction || current.direction[ (index >= current.index ? 'next' : 'prev') ];
			F.router    = router || 'jumpto';

			if (current.loop) {
				if (index < 0) {
					index = current.group.length + (index % current.group.length);
				}

				index = index % current.group.length;
			}

			if (current.group[ index ] !== undefined) {
				F.cancel();

				F._start(index);
			}
		},

		// Center inside viewport and toggle position type to fixed or absolute if needed
		reposition: function (e, onlyAbsolute) {
			var current = F.current,
				wrap    = current ? current.wrap : null,
				pos;

			if (wrap) {
				pos = F._getPosition(onlyAbsolute);

				if (e && e.type === 'scroll') {
					delete pos.position;

					wrap.stop(true, true).animate(pos, 200);

				} else {
					wrap.css(pos);

					current.pos = $.extend({}, current.dim, pos);
				}
			}
		},

		update: function (e) {
			var type = (e && e.type),
				anyway = !type || type === 'orientationchange';

			if (anyway) {
				clearTimeout(didUpdate);

				didUpdate = null;
			}

			if (!F.isOpen || didUpdate) {
				return;
			}

			didUpdate = setTimeout(function() {
				var current = F.current;

				if (!current || F.isClosing) {
					return;
				}

				F.wrap.removeClass('fancybox-tmp');

				if (anyway || type === 'load' || (type === 'resize' && current.autoResize)) {
					F._setDimension();
				}

				if (!(type === 'scroll' && current.canShrink)) {
					F.reposition(e);
				}

				F.trigger('onUpdate');

				didUpdate = null;

			}, (anyway && !isTouch ? 0 : 300));
		},

		// Shrink content to fit inside viewport or restore if resized
		toggle: function ( action ) {
			if (F.isOpen) {
				F.current.fitToView = $.type(action) === "boolean" ? action : !F.current.fitToView;

				// Help browser to restore document dimensions
				if (isTouch) {
					F.wrap.removeAttr('style').addClass('fancybox-tmp');

					F.trigger('onUpdate');
				}

				F.update();
			}
		},

		hideLoading: function () {
			D.unbind('.loading');

			$('#fancybox-loading').remove();
		},

		showLoading: function () {
			var el, viewport;

			F.hideLoading();

			el = $('<div id="fancybox-loading"><div></div></div>').click(F.cancel).appendTo('body');

			// If user will press the escape-button, the request will be canceled
			D.bind('keydown.loading', function(e) {
				if ((e.which || e.keyCode) === 27) {
					e.preventDefault();

					F.cancel();
				}
			});

			if (!F.defaults.fixed) {
				viewport = F.getViewport();

				el.css({
					position : 'absolute',
					top  : (viewport.h * 0.5) + viewport.y,
					left : (viewport.w * 0.5) + viewport.x
				});
			}
		},

		getViewport: function () {
			var locked = (F.current && F.current.locked) || false,
				rez    = {
					x: W.scrollLeft(),
					y: W.scrollTop()
				};

			if (locked) {
				rez.w = locked[0].clientWidth;
				rez.h = locked[0].clientHeight;

			} else {
				// See http://bugs.jquery.com/ticket/6724
				rez.w = isTouch && window.innerWidth  ? window.innerWidth  : W.width();
				rez.h = isTouch && window.innerHeight ? window.innerHeight : W.height();
			}

			return rez;
		},

		// Unbind the keyboard / clicking actions
		unbindEvents: function () {
			if (F.wrap && isQuery(F.wrap)) {
				F.wrap.unbind('.fb');
			}

			D.unbind('.fb');
			W.unbind('.fb');
		},

		bindEvents: function () {
			var current = F.current,
				keys;

			if (!current) {
				return;
			}

			// Changing document height on iOS devices triggers a 'resize' event,
			// that can change document height... repeating infinitely
			W.bind('orientationchange.fb' + (isTouch ? '' : ' resize.fb') + (current.autoCenter && !current.locked ? ' scroll.fb' : ''), F.update);

			keys = current.keys;

			if (keys) {
				D.bind('keydown.fb', function (e) {
					var code   = e.which || e.keyCode,
						target = e.target || e.srcElement;

					// Skip esc key if loading, because showLoading will cancel preloading
					if (code === 27 && F.coming) {
						return false;
					}

					// Ignore key combinations and key events within form elements
					if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey && !(target && (target.type || $(target).is('[contenteditable]')))) {
						$.each(keys, function(i, val) {
							if (current.group.length > 1 && val[ code ] !== undefined) {
								F[ i ]( val[ code ] );

								e.preventDefault();
								return false;
							}

							if ($.inArray(code, val) > -1) {
								F[ i ] ();

								e.preventDefault();
								return false;
							}
						});
					}
				});
			}

			if ($.fn.mousewheel && current.mouseWheel) {
				F.wrap.bind('mousewheel.fb', function (e, delta, deltaX, deltaY) {
					var target = e.target || null,
						parent = $(target),
						canScroll = false;

					while (parent.length) {
						if (canScroll || parent.is('.fancybox-skin') || parent.is('.fancybox-wrap')) {
							break;
						}

						canScroll = isScrollable( parent[0] );
						parent    = $(parent).parent();
					}

					if (delta !== 0 && !canScroll) {
						if (F.group.length > 1 && !current.canShrink) {
							if (deltaY > 0 || deltaX > 0) {
								F.prev( deltaY > 0 ? 'down' : 'left' );

							} else if (deltaY < 0 || deltaX < 0) {
								F.next( deltaY < 0 ? 'up' : 'right' );
							}

							e.preventDefault();
						}
					}
				});
			}
		},

		trigger: function (event, o) {
			var ret, obj = o || F.coming || F.current;

			if (!obj) {
				return;
			}

			if ($.isFunction( obj[event] )) {
				ret = obj[event].apply(obj, Array.prototype.slice.call(arguments, 1));
			}

			if (ret === false) {
				return false;
			}

			if (obj.helpers) {
				$.each(obj.helpers, function (helper, opts) {
					if (opts && F.helpers[helper] && $.isFunction(F.helpers[helper][event])) {
						F.helpers[helper][event]($.extend(true, {}, F.helpers[helper].defaults, opts), obj);
					}
				});
			}

			D.trigger(event);
		},

		isImage: function (str) {
			return isString(str) && str.match(/(^data:image\/.*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg)((\?|#).*)?$)/i);
		},

		isSWF: function (str) {
			return isString(str) && str.match(/\.(swf)((\?|#).*)?$/i);
		},

		_start: function (index) {
			var coming = {},
				obj,
				href,
				type,
				margin,
				padding;

			index = getScalar( index );
			obj   = F.group[ index ] || null;

			if (!obj) {
				return false;
			}

			coming = $.extend(true, {}, F.opts, obj);

			// Convert margin and padding properties to array - top, right, bottom, left
			margin  = coming.margin;
			padding = coming.padding;

			if ($.type(margin) === 'number') {
				coming.margin = [margin, margin, margin, margin];
			}

			if ($.type(padding) === 'number') {
				coming.padding = [padding, padding, padding, padding];
			}

			// 'modal' propery is just a shortcut
			if (coming.modal) {
				$.extend(true, coming, {
					closeBtn   : false,
					closeClick : false,
					nextClick  : false,
					arrows     : false,
					mouseWheel : false,
					keys       : null,
					helpers: {
						overlay : {
							closeClick : false
						}
					}
				});
			}

			// 'autoSize' property is a shortcut, too
			if (coming.autoSize) {
				coming.autoWidth = coming.autoHeight = true;
			}

			if (coming.width === 'auto') {
				coming.autoWidth = true;
			}

			if (coming.height === 'auto') {
				coming.autoHeight = true;
			}

			/*
			 * Add reference to the group, so it`s possible to access from callbacks, example:
			 * afterLoad : function() {
			 *     this.title = 'Image ' + (this.index + 1) + ' of ' + this.group.length + (this.title ? ' - ' + this.title : '');
			 * }
			 */

			coming.group  = F.group;
			coming.index  = index;

			// Give a chance for callback or helpers to update coming item (type, title, etc)
			F.coming = coming;

			if (false === F.trigger('beforeLoad')) {
				F.coming = null;

				return;
			}

			type = coming.type;
			href = coming.href;

			if (!type) {
				F.coming = null;

				//If we can not determine content type then drop silently or display next/prev item if looping through gallery
				if (F.current && F.router && F.router !== 'jumpto') {
					F.current.index = index;

					return F[ F.router ]( F.direction );
				}

				return false;
			}

			F.isActive = true;

			if (type === 'image' || type === 'swf') {
				coming.autoHeight = coming.autoWidth = false;
				coming.scrolling  = 'visible';
			}

			if (type === 'image') {
				coming.aspectRatio = true;
			}

			if (type === 'iframe' && isTouch) {
				coming.scrolling = 'scroll';
			}

			// Build the neccessary markup
			coming.wrap = $(coming.tpl.wrap).addClass('fancybox-' + (isTouch ? 'mobile' : 'desktop') + ' fancybox-type-' + type + ' fancybox-tmp ' + coming.wrapCSS).appendTo( coming.parent || 'body' );

			$.extend(coming, {
				skin  : $('.fancybox-skin',  coming.wrap),
				outer : $('.fancybox-outer', coming.wrap),
				inner : $('.fancybox-inner', coming.wrap)
			});

			$.each(["Top", "Right", "Bottom", "Left"], function(i, v) {
				coming.skin.css('padding' + v, getValue(coming.padding[ i ]));
			});

			F.trigger('onReady');

			// Check before try to load; 'inline' and 'html' types need content, others - href
			if (type === 'inline' || type === 'html') {
				if (!coming.content || !coming.content.length) {
					return F._error( 'content' );
				}

			} else if (!href) {
				return F._error( 'href' );
			}

			if (type === 'image') {
				F._loadImage();

			} else if (type === 'ajax') {
				F._loadAjax();

			} else if (type === 'iframe') {
				F._loadIframe();

			} else {
				F._afterLoad();
			}
		},

		_error: function ( type ) {
			$.extend(F.coming, {
				type       : 'html',
				autoWidth  : true,
				autoHeight : true,
				minWidth   : 0,
				minHeight  : 0,
				scrolling  : 'no',
				hasError   : type,
				content    : F.coming.tpl.error
			});

			F._afterLoad();
		},

		_loadImage: function () {
			// Reset preload image so it is later possible to check "complete" property
			var img = F.imgPreload = new Image();

			img.onload = function () {
				this.onload = this.onerror = null;

				F.coming.width  = this.width / F.opts.pixelRatio;
				F.coming.height = this.height / F.opts.pixelRatio;

				F._afterLoad();
			};

			img.onerror = function () {
				this.onload = this.onerror = null;

				F._error( 'image' );
			};

			img.src = F.coming.href;

			if (img.complete !== true) {
				F.showLoading();
			}
		},

		_loadAjax: function () {
			var coming = F.coming;

			F.showLoading();

			F.ajaxLoad = $.ajax($.extend({}, coming.ajax, {
				url: coming.href,
				error: function (jqXHR, textStatus) {
					if (F.coming && textStatus !== 'abort') {
						F._error( 'ajax', jqXHR );

					} else {
						F.hideLoading();
					}
				},
				success: function (data, textStatus) {
					if (textStatus === 'success') {
						coming.content = data;

						F._afterLoad();
					}
				}
			}));
		},

		_loadIframe: function() {
			var coming = F.coming,
				iframe = $(coming.tpl.iframe.replace(/\{rnd\}/g, new Date().getTime()))
					.attr('scrolling', isTouch ? 'auto' : coming.iframe.scrolling)
					.attr('src', coming.href);

			// This helps IE
			$(coming.wrap).bind('onReset', function () {
				try {
					$(this).find('iframe').hide().attr('src', '//about:blank').end().empty();
				} catch (e) {}
			});

			if (coming.iframe.preload) {
				F.showLoading();

				iframe.one('load', function() {
					$(this).data('ready', 1);

					// iOS will lose scrolling if we resize
					if (!isTouch) {
						$(this).bind('load.fb', F.update);
					}

					// Without this trick:
					//   - iframe won't scroll on iOS devices
					//   - IE7 sometimes displays empty iframe
					$(this).parents('.fancybox-wrap').width('100%').removeClass('fancybox-tmp').show();

					F._afterLoad();
				});
			}

			coming.content = iframe.appendTo( coming.inner );

			if (!coming.iframe.preload) {
				F._afterLoad();
			}
		},

		_preloadImages: function() {
			var group   = F.group,
				current = F.current,
				len     = group.length,
				cnt     = current.preload ? Math.min(current.preload, len - 1) : 0,
				item,
				i;

			for (i = 1; i <= cnt; i += 1) {
				item = group[ (current.index + i ) % len ];

				if (item.type === 'image' && item.href) {
					new Image().src = item.href;
				}
			}
		},

		_afterLoad: function () {
			var coming   = F.coming,
				previous = F.current,
				placeholder = 'fancybox-placeholder',
				current,
				content,
				type,
				scrolling,
				href,
				embed;

			F.hideLoading();

			if (!coming || F.isActive === false) {
				return;
			}

			if (false === F.trigger('afterLoad', coming, previous)) {
				coming.wrap.stop(true).trigger('onReset').remove();

				F.coming = null;

				return;
			}

			if (previous) {
				F.trigger('beforeChange', previous);

				previous.wrap.stop(true).removeClass('fancybox-opened')
					.find('.fancybox-item, .fancybox-nav')
					.remove();
			}

			F.unbindEvents();

			current   = coming;
			content   = coming.content;
			type      = coming.type;
			scrolling = coming.scrolling;

			$.extend(F, {
				wrap  : current.wrap,
				skin  : current.skin,
				outer : current.outer,
				inner : current.inner,
				current  : current,
				previous : previous
			});

			href = current.href;

			switch (type) {
				case 'inline':
				case 'ajax':
				case 'html':
					if (current.selector) {
						content = $('<div>').html(content).find(current.selector);

					} else if (isQuery(content)) {
						if (!content.data(placeholder)) {
							content.data(placeholder, $('<div class="' + placeholder + '"></div>').insertAfter( content ).hide() );
						}

						content = content.show().detach();

						current.wrap.bind('onReset', function () {
							if ($(this).find(content).length) {
								content.hide().replaceAll( content.data(placeholder) ).data(placeholder, false);
							}
						});
					}
				break;

				case 'image':
					content = current.tpl.image.replace('{href}', href);
				break;

				case 'swf':
					content = '<object id="fancybox-swf" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="100%" height="100%"><param name="movie" value="' + href + '"></param>';
					embed   = '';

					$.each(current.swf, function(name, val) {
						content += '<param name="' + name + '" value="' + val + '"></param>';
						embed   += ' ' + name + '="' + val + '"';
					});

					content += '<embed src="' + href + '" type="application/x-shockwave-flash" width="100%" height="100%"' + embed + '></embed></object>';
				break;
			}

			if (!(isQuery(content) && content.parent().is(current.inner))) {
				current.inner.append( content );
			}

			// Give a chance for helpers or callbacks to update elements
			F.trigger('beforeShow');

			// Set scrolling before calculating dimensions
			current.inner.css('overflow', scrolling === 'yes' ? 'scroll' : (scrolling === 'no' ? 'hidden' : scrolling));

			// Set initial dimensions and start position
			F._setDimension();

			F.reposition();

			F.isOpen = false;
			F.coming = null;

			F.bindEvents();

			if (!F.isOpened) {
				$('.fancybox-wrap').not( current.wrap ).stop(true).trigger('onReset').remove();

			} else if (previous.prevMethod) {
				F.transitions[ previous.prevMethod ]();
			}

			F.transitions[ F.isOpened ? current.nextMethod : current.openMethod ]();

			F._preloadImages();
		},

		_setDimension: function () {
			var viewport   = F.getViewport(),
				steps      = 0,
				canShrink  = false,
				canExpand  = false,
				wrap       = F.wrap,
				skin       = F.skin,
				inner      = F.inner,
				current    = F.current,
				width      = current.width,
				height     = current.height,
				minWidth   = current.minWidth,
				minHeight  = current.minHeight,
				maxWidth   = current.maxWidth,
				maxHeight  = current.maxHeight,
				scrolling  = current.scrolling,
				scrollOut  = current.scrollOutside ? current.scrollbarWidth : 0,
				margin     = current.margin,
				wMargin    = getScalar(margin[1] + margin[3]),
				hMargin    = getScalar(margin[0] + margin[2]),
				wPadding,
				hPadding,
				wSpace,
				hSpace,
				origWidth,
				origHeight,
				origMaxWidth,
				origMaxHeight,
				ratio,
				width_,
				height_,
				maxWidth_,
				maxHeight_,
				iframe,
				body;

			// Reset dimensions so we could re-check actual size
			wrap.add(skin).add(inner).width('auto').height('auto').removeClass('fancybox-tmp');

			wPadding = getScalar(skin.outerWidth(true)  - skin.width());
			hPadding = getScalar(skin.outerHeight(true) - skin.height());

			// Any space between content and viewport (margin, padding, border, title)
			wSpace = wMargin + wPadding;
			hSpace = hMargin + hPadding;

			origWidth  = isPercentage(width)  ? (viewport.w - wSpace) * getScalar(width)  / 100 : width;
			origHeight = isPercentage(height) ? (viewport.h - hSpace) * getScalar(height) / 100 : height;

			if (current.type === 'iframe') {
				iframe = current.content;

				if (current.autoHeight && iframe.data('ready') === 1) {
					try {
						if (iframe[0].contentWindow.document.location) {
							inner.width( origWidth ).height(9999);

							body = iframe.contents().find('body');

							if (scrollOut) {
								body.css('overflow-x', 'hidden');
							}

							origHeight = body.outerHeight(true);
						}

					} catch (e) {}
				}

			} else if (current.autoWidth || current.autoHeight) {
				inner.addClass( 'fancybox-tmp' );

				// Set width or height in case we need to calculate only one dimension
				if (!current.autoWidth) {
					inner.width( origWidth );
				}

				if (!current.autoHeight) {
					inner.height( origHeight );
				}

				if (current.autoWidth) {
					origWidth = inner.width();
				}

				if (current.autoHeight) {
					origHeight = inner.height();
				}

				inner.removeClass( 'fancybox-tmp' );
			}

			width  = getScalar( origWidth );
			height = getScalar( origHeight );

			ratio  = origWidth / origHeight;

			// Calculations for the content
			minWidth  = getScalar(isPercentage(minWidth) ? getScalar(minWidth, 'w') - wSpace : minWidth);
			maxWidth  = getScalar(isPercentage(maxWidth) ? getScalar(maxWidth, 'w') - wSpace : maxWidth);

			minHeight = getScalar(isPercentage(minHeight) ? getScalar(minHeight, 'h') - hSpace : minHeight);
			maxHeight = getScalar(isPercentage(maxHeight) ? getScalar(maxHeight, 'h') - hSpace : maxHeight);

			// These will be used to determine if wrap can fit in the viewport
			origMaxWidth  = maxWidth;
			origMaxHeight = maxHeight;

			if (current.fitToView) {
				maxWidth  = Math.min(viewport.w - wSpace, maxWidth);
				maxHeight = Math.min(viewport.h - hSpace, maxHeight);
			}

			maxWidth_  = viewport.w - wMargin;
			maxHeight_ = viewport.h - hMargin;

			if (current.aspectRatio) {
				if (width > maxWidth) {
					width  = maxWidth;
					height = getScalar(width / ratio);
				}

				if (height > maxHeight) {
					height = maxHeight;
					width  = getScalar(height * ratio);
				}

				if (width < minWidth) {
					width  = minWidth;
					height = getScalar(width / ratio);
				}

				if (height < minHeight) {
					height = minHeight;
					width  = getScalar(height * ratio);
				}

			} else {
				width = Math.max(minWidth, Math.min(width, maxWidth));

				if (current.autoHeight && current.type !== 'iframe') {
					inner.width( width );

					height = inner.height();
				}

				height = Math.max(minHeight, Math.min(height, maxHeight));
			}

			// Try to fit inside viewport (including the title)
			if (current.fitToView) {
				inner.width( width ).height( height );

				wrap.width( width + wPadding );

				// Real wrap dimensions
				width_  = wrap.width();
				height_ = wrap.height();

				if (current.aspectRatio) {
					while ((width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight) {
						if (steps++ > 19) {
							break;
						}

						height = Math.max(minHeight, Math.min(maxHeight, height - 10));
						width  = getScalar(height * ratio);

						if (width < minWidth) {
							width  = minWidth;
							height = getScalar(width / ratio);
						}

						if (width > maxWidth) {
							width  = maxWidth;
							height = getScalar(width / ratio);
						}

						inner.width( width ).height( height );

						wrap.width( width + wPadding );

						width_  = wrap.width();
						height_ = wrap.height();
					}

				} else {
					width  = Math.max(minWidth,  Math.min(width,  width  - (width_  - maxWidth_)));
					height = Math.max(minHeight, Math.min(height, height - (height_ - maxHeight_)));
				}
			}

			if (scrollOut && scrolling === 'auto' && height < origHeight && (width + wPadding + scrollOut) < maxWidth_) {
				width += scrollOut;
			}

			inner.width( width ).height( height );

			wrap.width( width + wPadding );

			width_  = wrap.width();
			height_ = wrap.height();

			canShrink = (width_ > maxWidth_ || height_ > maxHeight_) && width > minWidth && height > minHeight;
			canExpand = current.aspectRatio ? (width < origMaxWidth && height < origMaxHeight && width < origWidth && height < origHeight) : ((width < origMaxWidth || height < origMaxHeight) && (width < origWidth || height < origHeight));

			$.extend(current, {
				dim : {
					width	: getValue( width_ ),
					height	: getValue( height_ )
				},
				origWidth  : origWidth,
				origHeight : origHeight,
				canShrink  : canShrink,
				canExpand  : canExpand,
				wPadding   : wPadding,
				hPadding   : hPadding,
				wrapSpace  : height_ - skin.outerHeight(true),
				skinSpace  : skin.height() - height
			});

			if (!iframe && current.autoHeight && height > minHeight && height < maxHeight && !canExpand) {
				inner.height('auto');
			}
		},

		_getPosition: function (onlyAbsolute) {
			var current  = F.current,
				viewport = F.getViewport(),
				margin   = current.margin,
				width    = F.wrap.width()  + margin[1] + margin[3],
				height   = F.wrap.height() + margin[0] + margin[2],
				rez      = {
					position: 'absolute',
					top  : margin[0],
					left : margin[3]
				};

			if (current.autoCenter && current.fixed && !onlyAbsolute && height <= viewport.h && width <= viewport.w) {
				rez.position = 'fixed';

			} else if (!current.locked) {
				rez.top  += viewport.y;
				rez.left += viewport.x;
			}

			rez.top  = getValue(Math.max(rez.top,  rez.top  + ((viewport.h - height) * current.topRatio)));
			rez.left = getValue(Math.max(rez.left, rez.left + ((viewport.w - width)  * current.leftRatio)));

			return rez;
		},

		_afterZoomIn: function () {
			var current = F.current;

			if (!current) {
				return;
			}

			F.isOpen = F.isOpened = true;

			F.wrap.css('overflow', 'visible').addClass('fancybox-opened');

			F.update();

			// Assign a click event
			if ( current.closeClick || (current.nextClick && F.group.length > 1) ) {
				F.inner.css('cursor', 'pointer').bind('click.fb', function(e) {
					if (!$(e.target).is('a') && !$(e.target).parent().is('a')) {
						e.preventDefault();

						F[ current.closeClick ? 'close' : 'next' ]();
					}
				});
			}

			// Create a close button
			if (current.closeBtn) {
				$(current.tpl.closeBtn).appendTo(F.skin).bind('click.fb', function(e) {
					e.preventDefault();

					F.close();
				});
			}

			// Create navigation arrows
			if (current.arrows && F.group.length > 1) {
				if (current.loop || current.index > 0) {
					$(current.tpl.prev).appendTo(F.outer).bind('click.fb', F.prev);
				}

				if (current.loop || current.index < F.group.length - 1) {
					$(current.tpl.next).appendTo(F.outer).bind('click.fb', F.next);
				}
			}

			F.trigger('afterShow');

			// Stop the slideshow if this is the last item
			if (!current.loop && current.index === current.group.length - 1) {
				F.play( false );

			} else if (F.opts.autoPlay && !F.player.isActive) {
				F.opts.autoPlay = false;

				F.play();
			}
		},

		_afterZoomOut: function ( obj ) {
			obj = obj || F.current;

			$('.fancybox-wrap').trigger('onReset').remove();

			$.extend(F, {
				group  : {},
				opts   : {},
				router : false,
				current   : null,
				isActive  : false,
				isOpened  : false,
				isOpen    : false,
				isClosing : false,
				wrap   : null,
				skin   : null,
				outer  : null,
				inner  : null
			});

			F.trigger('afterClose', obj);
		}
	});

	/*
	 *	Default transitions
	 */

	F.transitions = {
		getOrigPosition: function () {
			var current  = F.current,
				element  = current.element,
				orig     = current.orig,
				pos      = {},
				width    = 50,
				height   = 50,
				hPadding = current.hPadding,
				wPadding = current.wPadding,
				viewport = F.getViewport();

			if (!orig && current.isDom && element.is(':visible')) {
				orig = element.find('img:first');

				if (!orig.length) {
					orig = element;
				}
			}

			if (isQuery(orig)) {
				pos = orig.offset();

				if (orig.is('img')) {
					width  = orig.outerWidth();
					height = orig.outerHeight();
				}

			} else {
				pos.top  = viewport.y + (viewport.h - height) * current.topRatio;
				pos.left = viewport.x + (viewport.w - width)  * current.leftRatio;
			}

			if (F.wrap.css('position') === 'fixed' || current.locked) {
				pos.top  -= viewport.y;
				pos.left -= viewport.x;
			}

			pos = {
				top     : getValue(pos.top  - hPadding * current.topRatio),
				left    : getValue(pos.left - wPadding * current.leftRatio),
				width   : getValue(width  + wPadding),
				height  : getValue(height + hPadding)
			};

			return pos;
		},

		step: function (now, fx) {
			var ratio,
				padding,
				value,
				prop       = fx.prop,
				current    = F.current,
				wrapSpace  = current.wrapSpace,
				skinSpace  = current.skinSpace;

			if (prop === 'width' || prop === 'height') {
				ratio = fx.end === fx.start ? 1 : (now - fx.start) / (fx.end - fx.start);

				if (F.isClosing) {
					ratio = 1 - ratio;
				}

				padding = prop === 'width' ? current.wPadding : current.hPadding;
				value   = now - padding;

				F.skin[ prop ](  getScalar( prop === 'width' ?  value : value - (wrapSpace * ratio) ) );
				F.inner[ prop ]( getScalar( prop === 'width' ?  value : value - (wrapSpace * ratio) - (skinSpace * ratio) ) );
			}
		},

		zoomIn: function () {
			var current  = F.current,
				startPos = current.pos,
				effect   = current.openEffect,
				elastic  = effect === 'elastic',
				endPos   = $.extend({opacity : 1}, startPos);

			// Remove "position" property that breaks older IE
			delete endPos.position;

			if (elastic) {
				startPos = this.getOrigPosition();

				if (current.openOpacity) {
					startPos.opacity = 0.1;
				}

			} else if (effect === 'fade') {
				startPos.opacity = 0.1;
			}

			F.wrap.css(startPos).animate(endPos, {
				duration : effect === 'none' ? 0 : current.openSpeed,
				easing   : current.openEasing,
				step     : elastic ? this.step : null,
				complete : F._afterZoomIn
			});
		},

		zoomOut: function () {
			var current  = F.current,
				effect   = current.closeEffect,
				elastic  = effect === 'elastic',
				endPos   = {opacity : 0.1};

			if (elastic) {
				endPos = this.getOrigPosition();

				if (current.closeOpacity) {
					endPos.opacity = 0.1;
				}
			}

			F.wrap.animate(endPos, {
				duration : effect === 'none' ? 0 : current.closeSpeed,
				easing   : current.closeEasing,
				step     : elastic ? this.step : null,
				complete : F._afterZoomOut
			});
		},

		changeIn: function () {
			var current   = F.current,
				effect    = current.nextEffect,
				startPos  = current.pos,
				endPos    = { opacity : 1 },
				direction = F.direction,
				distance  = 200,
				field;

			startPos.opacity = 0.1;

			if (effect === 'elastic') {
				field = direction === 'down' || direction === 'up' ? 'top' : 'left';

				if (direction === 'down' || direction === 'right') {
					startPos[ field ] = getValue(getScalar(startPos[ field ]) - distance);
					endPos[ field ]   = '+=' + distance + 'px';

				} else {
					startPos[ field ] = getValue(getScalar(startPos[ field ]) + distance);
					endPos[ field ]   = '-=' + distance + 'px';
				}
			}

			// Workaround for http://bugs.jquery.com/ticket/12273
			if (effect === 'none') {
				F._afterZoomIn();

			} else {
				F.wrap.css(startPos).animate(endPos, {
					duration : current.nextSpeed,
					easing   : current.nextEasing,
					complete : F._afterZoomIn
				});
			}
		},

		changeOut: function () {
			var previous  = F.previous,
				effect    = previous.prevEffect,
				endPos    = { opacity : 0.1 },
				direction = F.direction,
				distance  = 200;

			if (effect === 'elastic') {
				endPos[ direction === 'down' || direction === 'up' ? 'top' : 'left' ] = ( direction === 'up' || direction === 'left' ? '-' : '+' ) + '=' + distance + 'px';
			}

			previous.wrap.animate(endPos, {
				duration : effect === 'none' ? 0 : previous.prevSpeed,
				easing   : previous.prevEasing,
				complete : function () {
					$(this).trigger('onReset').remove();
				}
			});
		}
	};

	/*
	 *	Overlay helper
	 */

	F.helpers.overlay = {
		defaults : {
			closeClick : true,      // if true, fancyBox will be closed when user clicks on the overlay
			speedOut   : 200,       // duration of fadeOut animation
			showEarly  : true,      // indicates if should be opened immediately or wait until the content is ready
			css        : {},        // custom CSS properties
			locked     : !isTouch,  // if true, the content will be locked into overlay
			fixed      : true       // if false, the overlay CSS position property will not be set to "fixed"
		},

		overlay : null,      // current handle
		fixed   : false,     // indicates if the overlay has position "fixed"
		el      : $('html'), // element that contains "the lock"

		// Public methods
		create : function(opts) {
			opts = $.extend({}, this.defaults, opts);

			if (this.overlay) {
				this.close();
			}

			this.overlay = $('<div class="fancybox-overlay"></div>').appendTo( F.coming ? F.coming.parent : opts.parent );
			this.fixed   = false;

			if (opts.fixed && F.defaults.fixed) {
				this.overlay.addClass('fancybox-overlay-fixed');

				this.fixed = true;
			}
		},

		open : function(opts) {
			var that = this;

			opts = $.extend({}, this.defaults, opts);

			if (this.overlay) {
				this.overlay.unbind('.overlay').width('auto').height('auto');

			} else {
				this.create(opts);
			}

			if (!this.fixed) {
				W.bind('resize.overlay', $.proxy( this.update, this) );

				this.update();
			}

			if (opts.closeClick) {
				this.overlay.bind('click.overlay', function(e) {
					if ($(e.target).hasClass('fancybox-overlay')) {
						if (F.isActive) {
							F.close();
						} else {
							that.close();
						}

						return false;
					}
				});
			}

			this.overlay.css( opts.css ).show();
		},

		close : function() {
			var scrollV, scrollH;

			W.unbind('resize.overlay');

			if (this.el.hasClass('fancybox-lock')) {
				$('.fancybox-margin').removeClass('fancybox-margin');

				scrollV = W.scrollTop();
				scrollH = W.scrollLeft();

				this.el.removeClass('fancybox-lock');

				W.scrollTop( scrollV ).scrollLeft( scrollH );
			}

			$('.fancybox-overlay').remove().hide();

			$.extend(this, {
				overlay : null,
				fixed   : false
			});
		},

		// Private, callbacks

		update : function () {
			var width = '100%', offsetWidth;

			// Reset width/height so it will not mess
			this.overlay.width(width).height('100%');

			// jQuery does not return reliable result for IE
			if (IE) {
				offsetWidth = Math.max(document.documentElement.offsetWidth, document.body.offsetWidth);

				if (D.width() > offsetWidth) {
					width = D.width();
				}

			} else if (D.width() > W.width()) {
				width = D.width();
			}

			this.overlay.width(width).height(D.height());
		},

		// This is where we can manipulate DOM, because later it would cause iframes to reload
		onReady : function (opts, obj) {
			var overlay = this.overlay;

			$('.fancybox-overlay').stop(true, true);

			if (!overlay) {
				this.create(opts);
			}

			if (opts.locked && this.fixed && obj.fixed) {
				if (!overlay) {
					this.margin = D.height() > W.height() ? $('html').css('margin-right').replace("px", "") : false;
				}

				obj.locked = this.overlay.append( obj.wrap );
				obj.fixed  = false;
			}

			if (opts.showEarly === true) {
				this.beforeShow.apply(this, arguments);
			}
		},

		beforeShow : function(opts, obj) {
			var scrollV, scrollH;

			if (obj.locked) {
				if (this.margin !== false) {
					$('*').filter(function(){
						return ($(this).css('position') === 'fixed' && !$(this).hasClass("fancybox-overlay") && !$(this).hasClass("fancybox-wrap") );
					}).addClass('fancybox-margin');

					this.el.addClass('fancybox-margin');
				}

				scrollV = W.scrollTop();
				scrollH = W.scrollLeft();

				this.el.addClass('fancybox-lock');

				W.scrollTop( scrollV ).scrollLeft( scrollH );
			}

			this.open(opts);
		},

		onUpdate : function() {
			if (!this.fixed) {
				this.update();
			}
		},

		afterClose: function (opts) {
			// Remove overlay if exists and fancyBox is not opening
			// (e.g., it is not being open using afterClose callback)
			//if (this.overlay && !F.isActive) {
			if (this.overlay && !F.coming) {
				this.overlay.fadeOut(opts.speedOut, $.proxy( this.close, this ));
			}
		}
	};

	/*
	 *	Title helper
	 */

	F.helpers.title = {
		defaults : {
			type     : 'float', // 'float', 'inside', 'outside' or 'over',
			position : 'bottom' // 'top' or 'bottom'
		},

		beforeShow: function (opts) {
			var current = F.current,
				text    = current.title,
				type    = opts.type,
				title,
				target;

			if ($.isFunction(text)) {
				text = text.call(current.element, current);
			}

			if (!isString(text) || $.trim(text) === '') {
				return;
			}

			title = $('<div class="fancybox-title fancybox-title-' + type + '-wrap">' + text + '</div>');

			switch (type) {
				case 'inside':
					target = F.skin;
				break;

				case 'outside':
					target = F.wrap;
				break;

				case 'over':
					target = F.inner;
				break;

				default: // 'float'
					target = F.skin;

					title.appendTo('body');

					if (IE) {
						title.width( title.width() );
					}

					title.wrapInner('<span class="child"></span>');

					//Increase bottom margin so this title will also fit into viewport
					F.current.margin[2] += Math.abs( getScalar(title.css('margin-bottom')) );
				break;
			}

			title[ (opts.position === 'top' ? 'prependTo'  : 'appendTo') ](target);
		}
	};

	// jQuery plugin initialization
	$.fn.fancybox = function (options) {
		var index,
			that     = $(this),
			selector = this.selector || '',
			run      = function(e) {
				var what = $(this).blur(), idx = index, relType, relVal;

				if (!(e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) && !what.is('.fancybox-wrap')) {
					relType = options.groupAttr || 'data-fancybox-group';
					relVal  = what.attr(relType);

					if (!relVal) {
						relType = 'rel';
						relVal  = what.get(0)[ relType ];
					}

					if (relVal && relVal !== '' && relVal !== 'nofollow') {
						what = selector.length ? $(selector) : that;
						what = what.filter('[' + relType + '="' + relVal + '"]');
						idx  = what.index(this);
					}

					options.index = idx;

					// Stop an event from bubbling if everything is fine
					if (F.open(what, options) !== false) {
						e.preventDefault();
					}
				}
			};

		options = options || {};
		index   = options.index || 0;

		if (!selector || options.live === false) {
			that.unbind('click.fb-start').bind('click.fb-start', run);

		} else {
			D.undelegate(selector, 'click.fb-start').delegate(selector + ":not('.fancybox-item, .fancybox-nav')", 'click.fb-start', run);
		}

		this.filter('[data-fancybox-start=1]').trigger('click');

		return this;
	};

	// Tests that need a body at doc ready
	D.ready(function() {
		var w1, w2;

		if ( $.scrollbarWidth === undefined ) {
			// http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth
			$.scrollbarWidth = function() {
				var parent = $('<div style="width:50px;height:50px;overflow:auto"><div/></div>').appendTo('body'),
					child  = parent.children(),
					width  = child.innerWidth() - child.height( 99 ).innerWidth();

				parent.remove();

				return width;
			};
		}

		if ( $.support.fixedPosition === undefined ) {
			$.support.fixedPosition = (function() {
				var elem  = $('<div style="position:fixed;top:20px;"></div>').appendTo('body'),
					fixed = ( elem[0].offsetTop === 20 || elem[0].offsetTop === 15 );

				elem.remove();

				return fixed;
			}());
		}

		$.extend(F.defaults, {
			scrollbarWidth : $.scrollbarWidth(),
			fixed  : $.support.fixedPosition,
			parent : $('body')
		});

		//Get real width of page scroll-bar
		w1 = $(window).width();

		H.addClass('fancybox-lock-test');

		w2 = $(window).width();

		H.removeClass('fancybox-lock-test');

		$("<style type='text/css'>.fancybox-margin{margin-right:" + (w2 - w1) + "px;}</style>").appendTo("head");
	});

}(window, document, jQuery));
jQuery(document).ready(function() {

	/*
	*   Examples - images
	*/
	
	$("a#example1").fancybox({
		'titleShow'     : false
	});
		
	$("a#example2").fancybox({
		'titleShow'     : false,
		'transitionIn'	: 'elastic',
		'transitionOut'	: 'elastic',
		'easingIn'      : 'easeOutBack',
		'easingOut'     : 'easeInBack'
	});
	
	$("a#example3").fancybox({
	    'titleShow'     : false,
		'transitionIn'	: 'none',
		'transitionOut'	: 'none'
	});
	
	$("a#example4").fancybox();
	
	$("a#example5").fancybox({
		'titlePosition'  : 'inside'
	});
	
	$("a#example6").fancybox({
		'titlePosition'  : 'over'
	});
	
	$("a[rel=example_group]").fancybox({
		'transitionIn'		: 'none',
		'transitionOut'		: 'none',
		'titlePosition' 	: 'over',
		'titleFormat'       : function(title, currentArray, currentIndex, currentOpts) {
		    return '<span id="fancybox-title-over">Image ' +  (currentIndex + 1) + ' / ' + currentArray.length + ' ' + title + '</span>';
		}
	});
	
	/*
	*   Examples - various
	*/
	
	$(".various").fancybox({
		'transitionIn'	: 'none',
		'transitionOut'	: 'none'
	});
	
	$("#various1").fancybox({
		'titlePosition'		: 'inside',
		'transitionIn'		: 'none',
		'transitionOut'		: 'none'
	});
	
	$("#various2").fancybox({
		'modal' : true
	});
	
	$("#various3").fancybox({
		ajax : {
		    type	: "POST",
		    data	: 'mydata=test'
		}
	});

	$("#various4").fancybox({
		ajax : {
		    type	: "POST"
		}
	});
			
	$("#various5").fancybox({
		//'width'				: '75%',
		//'height'			: '75%',
        'autoScale'     	: true,
        'transitionIn'		: 'none',
		'transitionOut'		: 'none',
		'type'				: 'iframe'
	});
	
	$(".popuper").fancybox({
		//'width'				: '75%',
		//'height'			: '75%',
        'autoScale'     	: true,
        'transitionIn'		: 'none',
		'transitionOut'		: 'none',
		'type'				: 'iframe'
	});
	
	$("#various6").fancybox({
	    'padding'           : 0,
        'autoScale'     	: false,
        'transitionIn'		: 'none',
		'transitionOut'		: 'none'
	});
	
	$("#various7").fancybox({
		onStart		:	function() {
			return window.confirm('Continue?');
		},
		onCancel	:	function() {
			alert('Canceled!');
		},
		onComplete	:	function() {
            alert('Completed!');
		},
		onCleanup	:	function() {
            return window.confirm('Close?');
		},
		onClosed	:	function() {
            alert('Closed!');
		}
	});
	
	$("#various8, #various9").fancybox();
	
	/*
	*   Examples - manual call
	*/

	$("#manual1").click(function() {
		$.fancybox({
			//'orig'			: $(this),
			'padding'		: 0,
			'href'			: 'http://farm3.static.flickr.com/2687/4220681515_cc4f42d6b9.jpg',
			'title'   		: 'Lorem ipsum dolor sit amet',
			'transitionIn'	: 'elastic',
			'transitionOut'	: 'elastic'
		});
    });
    
    $("#manual2").click(function() {
		$.fancybox([
			'http://farm5.static.flickr.com/4044/4286199901_33844563eb.jpg',
			'http://farm3.static.flickr.com/2687/4220681515_cc4f42d6b9.jpg',
			{
				'href'	: 'http://farm5.static.flickr.com/4005/4213562882_851e92f326.jpg',
				'title'	: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit'
			}
		], {
			'padding'			: 0,
			'transitionIn'		: 'none',
			'transitionOut'		: 'none',
			'type'              : 'image',
			'changeFade'        : 0
		});
	});
			
	/*
	*   Tips & Tricks
	*/
	
	$("#tip3").fancybox({
	    'transitionIn'	: 'none',
		'transitionOut'	: 'none',
		'titlePosition'	: 'over',
		'onComplete'	: function() {
			$("#fancybox-wrap").hover(function() {
				$("#fancybox-title").show();
			}, function() {
				$("#fancybox-title").hide();
			});
		}
	});

	$("#tip4").click(function() {
		$.fancybox({
			'padding'		: 0,
			'autoScale'		: false,
			'transitionIn'	: 'none',
			'transitionOut'	: 'none',
			'title'			: this.title,
			'width'			: 680,
			'height'		: 495,
			'href'			: this.href.replace(new RegExp("watch\\?v=", "i"), 'v/'),
			'type'			: 'swf',
			'swf'			: {
			    'wmode'				: 'transparent',
				'allowfullscreen'	: 'true'
			}
		});

		return false;
	});

    $("#tip5").fancybox({
		'scrolling' : 'no',
		'titleShow'	: false,
		'onClosed'	: function() {
		    $("#login_error").hide();
		}
	});
    
	$("#login_form").bind("submit", function() {
	
	    if ($("#login_name").val().length < 1 || $("#login_pass").val().length < 1) {
	        $("#login_error").show();
	        $.fancybox.resize();
	        return false;
	    }
	    
	    $.fancybox.showActivity();

		$.ajax({
			type	: "POST",
			cache	: false,
			url		: "/data/login.php",
			data	: $(this).serializeArray(),
			success: function(data) {
				$.fancybox(data);
			}
		});

		return false;
	});
	
	$("#tip6").fancybox({
		'transitionIn'		: 'none',
		'transitionOut'		: 'none',
		'autoScale'     	: false,
		'type'				: 'iframe',
		'width'				: 500,
		'height'			: 500,
		'scrolling'   		: 'no'
	});
	
	function formatTitle(title, currentArray, currentIndex, currentOpts) {
	    return '<div id="tip7-title"><span><a href="javascript:;" onclick="$.fancybox.close();"><img src="/data/closelabel.gif" /></a></span>' + (title && title.length ? '<b>' + title + '</b>' : '' ) + 'Image ' + (currentIndex + 1) + ' of ' + currentArray.length + '</div>';
	}

	$(".tip7").fancybox({
	    'showCloseButton'   : false,
		'titlePosition' 	: 'inside',
		'titleFormat'		: formatTitle
	});
	
	
	// Next JS snippets are only for fancybox.net
	
	/*
	*   Donate link
	*/
	$("a#donate").bind("click", function() {
		$("#donate_form").submit();
		return false;
	});

	/*
	*   Zebra-stripping table
	*/
	
	$("table.options tr:even").addClass('even');

});

// Menu Mobile
$(window).load(function(){
   	$(".menum").hide();
   	$(".mobilemenu").show();
    $('.mobilemenu').click(function(){
		$(".menum").slideToggle();
    });
});

// Top Nav Member Shopping Cart
function DropDown(el) {
  this.dd = el;
  this.initEvents();
}
DropDown.prototype = {
  initEvents : function() {
    var obj = this;

    obj.dd.on('click', function(event){
      $(this).toggleClass('active');
      event.stopPropagation();
    });
  }
}
$(function() {
  var dd = new DropDown( $('#dd') );
  $(document).click(function() {
    $('.shopping-dropdown').removeClass('active');
  });
});

$(function(){
  $('.js-variant-change-option').change(function(){
    window.location = $(this).data('url') + '/product/' + $(this).val();
  });
});

!function(t,e,i,n){var a=e.document,o=t(a),r=t(e),s=Array.prototype,l=1.41,c=true,h=3e4,u=false,f=navigator.userAgent.toLowerCase(),d=e.location.hash.replace(/#\//,""),p=e.location.protocol,g=Math,m=function(){},v=function(){return false},y=function(){var t=3,e=a.createElement("div"),i=e.getElementsByTagName("i");do{e.innerHTML="<!--[if gt IE "+ ++t+"]><i></i><![endif]-->"}while(i[0]);return t>4?t:a.documentMode||n}(),_=function(){return{html:a.documentElement,body:a.body,head:a.getElementsByTagName("head")[0],title:a.title}},b=e.parent!==e.self,w="data ready thumbnail loadstart loadfinish image play pause progress "+"fullscreen_enter fullscreen_exit idle_enter idle_exit rescale "+"lightbox_open lightbox_close lightbox_image",x=function(){var e=[];t.each(w.split(" "),function(t,i){e.push(i);if(/_/.test(i)){e.push(i.replace(/_/g,""))}});return e}(),T=function(e){var i;if(typeof e!=="object"){return e}t.each(e,function(n,a){if(/^[a-z]+_/.test(n)){i="";t.each(n.split("_"),function(t,e){i+=t>0?e.substr(0,1).toUpperCase()+e.substr(1):e});e[i]=a;delete e[n]}});return e},k=function(e){if(t.inArray(e,x)>-1){return i[e.toUpperCase()]}return e},C={youtube:{reg:/https?:\/\/(?:[a-zA_Z]{2,3}.)?(?:youtube\.com\/watch\?)((?:[\w\d\-\_\=]+&amp;(?:amp;)?)*v(?:&lt;[A-Z]+&gt;)?=([0-9a-zA-Z\-\_]+))/i,embed:function(){return"http://www.youtube.com/embed/"+this.id},getUrl:function(){return p+"//gdata.youtube.com/feeds/api/videos/"+this.id+"?v=2&alt=json-in-script&callback=?"},get_thumb:function(t){return t.entry.media$group.media$thumbnail[2].url},get_image:function(t){if(t.entry.yt$hd){return p+"//img.youtube.com/vi/"+this.id+"/maxresdefault.jpg"}return t.entry.media$group.media$thumbnail[3].url}},vimeo:{reg:/https?:\/\/(?:www\.)?(vimeo\.com)\/(?:hd#)?([0-9]+)/i,embed:function(){return"http://player.vimeo.com/video/"+this.id},getUrl:function(){return p+"//vimeo.com/api/v2/video/"+this.id+".json?callback=?"},get_thumb:function(t){return t[0].thumbnail_medium},get_image:function(t){return t[0].thumbnail_large}},dailymotion:{reg:/https?:\/\/(?:www\.)?(dailymotion\.com)\/video\/([^_]+)/,embed:function(){return p+"//www.dailymotion.com/embed/video/"+this.id},getUrl:function(){return"https://api.dailymotion.com/video/"+this.id+"?fields=thumbnail_240_url,thumbnail_720_url&callback=?"},get_thumb:function(t){return t.thumbnail_240_url},get_image:function(t){return t.thumbnail_720_url}},_inst:[]},I=function(e,i){for(var n=0;n<C._inst.length;n++){if(C._inst[n].id===i&&C._inst[n].type==e){return C._inst[n]}}this.type=e;this.id=i;this.readys=[];C._inst.push(this);var a=this;t.extend(this,C[e]);t.getJSON(this.getUrl(),function(e){a.data=e;t.each(a.readys,function(t,e){e(a.data)});a.readys=[]});this.getMedia=function(t,e,i){i=i||m;var n=this;var a=function(i){e(n["get_"+t](i))};try{if(n.data){a(n.data)}else{n.readys.push(a)}}catch(o){i()}}},S=function(t){var e;for(var i in C){e=t&&C[i].reg&&t.match(C[i].reg);if(e&&e.length){return{id:e[2],provider:i}}}return false},A={support:function(){var t=_().html;return!b&&(t.requestFullscreen||t.msRequestFullscreen||t.mozRequestFullScreen||t.webkitRequestFullScreen)}(),callback:m,enter:function(t,e,i){this.instance=t;this.callback=e||m;i=i||_().html;if(i.requestFullscreen){i.requestFullscreen()}else if(i.msRequestFullscreen){i.msRequestFullscreen()}else if(i.mozRequestFullScreen){i.mozRequestFullScreen()}else if(i.webkitRequestFullScreen){i.webkitRequestFullScreen()}},exit:function(t){this.callback=t||m;if(a.exitFullscreen){a.exitFullscreen()}else if(a.msExitFullscreen){a.msExitFullscreen()}else if(a.mozCancelFullScreen){a.mozCancelFullScreen()}else if(a.webkitCancelFullScreen){a.webkitCancelFullScreen()}},instance:null,listen:function(){if(!this.support){return}var t=function(){if(!A.instance){return}var t=A.instance._fullscreen;if(a.fullscreen||a.mozFullScreen||a.webkitIsFullScreen||a.msFullscreenElement&&a.msFullscreenElement!==null){t._enter(A.callback)}else{t._exit(A.callback)}};a.addEventListener("fullscreenchange",t,false);a.addEventListener("MSFullscreenChange",t,false);a.addEventListener("mozfullscreenchange",t,false);a.addEventListener("webkitfullscreenchange",t,false)}},E=[],D=[],$=false,L=false,P=[],z=[],F=function(e){z.push(e);t.each(P,function(t,i){if(i._options.theme==e.name||!i._initialized&&!i._options.theme){i.theme=e;i._init.call(i)}})},H=function(){return{clearTimer:function(e){t.each(i.get(),function(){this.clearTimer(e)})},addTimer:function(e){t.each(i.get(),function(){this.addTimer(e)})},array:function(t){return s.slice.call(t,0)},create:function(t,e){e=e||"div";var i=a.createElement(e);i.className=t;return i},removeFromArray:function(e,i){t.each(e,function(t,n){if(n==i){e.splice(t,1);return false}});return e},getScriptPath:function(e){e=e||t("script:last").attr("src");var i=e.split("/");if(i.length==1){return""}i.pop();return i.join("/")+"/"},animate:function(){var n=function(t){var i="transition WebkitTransition MozTransition OTransition".split(" "),n;if(e.opera){return false}for(n=0;i[n];n++){if(typeof t[i[n]]!=="undefined"){return i[n]}}return false}((a.body||a.documentElement).style);var o={MozTransition:"transitionend",OTransition:"oTransitionEnd",WebkitTransition:"webkitTransitionEnd",transition:"transitionend"}[n];var r={_default:[.25,.1,.25,1],galleria:[.645,.045,.355,1],galleriaIn:[.55,.085,.68,.53],galleriaOut:[.25,.46,.45,.94],ease:[.25,0,.25,1],linear:[.25,.25,.75,.75],"ease-in":[.42,0,1,1],"ease-out":[0,0,.58,1],"ease-in-out":[.42,0,.58,1]};var s=function(e,i,n){var a={};n=n||"transition";t.each("webkit moz ms o".split(" "),function(){a["-"+this+"-"+n]=i});e.css(a)};var l=function(t){s(t,"none","transition");if(i.WEBKIT&&i.TOUCH){s(t,"translate3d(0,0,0)","transform");if(t.data("revert")){t.css(t.data("revert"));t.data("revert",null)}}};var c,h,u,f,d,p,g;return function(a,v,y){y=t.extend({duration:400,complete:m,stop:false},y);a=t(a);if(!y.duration){a.css(v);y.complete.call(a[0]);return}if(!n){a.animate(v,y);return}if(y.stop){a.off(o);l(a)}c=false;t.each(v,function(t,e){g=a.css(t);if(H.parseValue(g)!=H.parseValue(e)){c=true}a.css(t,g)});if(!c){e.setTimeout(function(){y.complete.call(a[0])},y.duration);return}h=[];u=y.easing in r?r[y.easing]:r._default;f=" "+y.duration+"ms"+" cubic-bezier("+u.join(",")+")";e.setTimeout(function(e,n,a,o){return function(){e.one(n,function(t){return function(){l(t);y.complete.call(t[0])}}(e));if(i.WEBKIT&&i.TOUCH){d={};p=[0,0,0];t.each(["left","top"],function(t,i){if(i in a){p[t]=H.parseValue(a[i])-H.parseValue(e.css(i))+"px";d[i]=a[i];delete a[i]}});if(p[0]||p[1]){e.data("revert",d);h.push("-webkit-transform"+o);s(e,"translate3d("+p.join(",")+")","transform")}}t.each(a,function(t,e){h.push(t+o)});s(e,h.join(","));e.css(a)}}(a,o,v,f),2)}}(),removeAlpha:function(t){if(t instanceof jQuery){t=t[0]}if(y<9&&t){var e=t.style,i=t.currentStyle,n=i&&i.filter||e.filter||"";if(/alpha/.test(n)){e.filter=n.replace(/alpha\([^)]*\)/i,"")}}},forceStyles:function(e,i){e=t(e);if(e.attr("style")){e.data("styles",e.attr("style")).removeAttr("style")}e.css(i)},revertStyles:function(){t.each(H.array(arguments),function(e,i){i=t(i);i.removeAttr("style");i.attr("style","");if(i.data("styles")){i.attr("style",i.data("styles")).data("styles",null)}})},moveOut:function(t){H.forceStyles(t,{position:"absolute",left:-1e4})},moveIn:function(){H.revertStyles.apply(H,H.array(arguments))},hide:function(e,i,n){n=n||m;var a=t(e);e=a[0];if(!a.data("opacity")){a.data("opacity",a.css("opacity"))}var o={opacity:0};if(i){var r=y<9&&e?function(){H.removeAlpha(e);e.style.visibility="hidden";n.call(e)}:n;H.animate(e,o,{duration:i,complete:r,stop:true})}else{if(y<9&&e){H.removeAlpha(e);e.style.visibility="hidden"}else{a.css(o)}}},show:function(e,i,n){n=n||m;var a=t(e);e=a[0];var o=parseFloat(a.data("opacity"))||1,r={opacity:o};if(i){if(y<9){a.css("opacity",0);e.style.visibility="visible"}var s=y<9&&e?function(){if(r.opacity==1){H.removeAlpha(e)}n.call(e)}:n;H.animate(e,r,{duration:i,complete:s,stop:true})}else{if(y<9&&r.opacity==1&&e){H.removeAlpha(e);e.style.visibility="visible"}else{a.css(r)}}},wait:function(n){i._waiters=i._waiters||[];n=t.extend({until:v,success:m,error:function(){i.raise("Could not complete wait function.")},timeout:3e3},n);var a=H.timestamp(),o,r,s,l=function(){r=H.timestamp();o=r-a;H.removeFromArray(i._waiters,s);if(n.until(o)){n.success();return false}if(typeof n.timeout=="number"&&r>=a+n.timeout){n.error();return false}i._waiters.push(s=e.setTimeout(l,10))};i._waiters.push(s=e.setTimeout(l,10))},toggleQuality:function(t,e){if(y!==7&&y!==8||!t||t.nodeName.toUpperCase()!="IMG"){return}if(typeof e==="undefined"){e=t.style.msInterpolationMode==="nearest-neighbor"}t.style.msInterpolationMode=e?"bicubic":"nearest-neighbor"},insertStyleTag:function(e,i){if(i&&t("#"+i).length){return}var n=a.createElement("style");if(i){n.id=i}_().head.appendChild(n);if(n.styleSheet){n.styleSheet.cssText=e}else{var o=a.createTextNode(e);n.appendChild(o)}},loadScript:function(e,i){var n=false,a=t("<scr"+"ipt>").attr({src:e,async:true}).get(0);a.onload=a.onreadystatechange=function(){if(!n&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){n=true;a.onload=a.onreadystatechange=null;if(typeof i==="function"){i.call(this,this)}}};_().head.appendChild(a)},parseValue:function(t){if(typeof t==="number"){return t}else if(typeof t==="string"){var e=t.match(/\-?\d|\./g);return e&&e.constructor===Array?e.join("")*1:0}else{return 0}},timestamp:function(){return(new Date).getTime()},loadCSS:function(e,o,r){var s,l;t("link[rel=stylesheet]").each(function(){if(new RegExp(e).test(this.href)){s=this;return false}});if(typeof o==="function"){r=o;o=n}r=r||m;if(s){r.call(s,s);return s}l=a.styleSheets.length;if(t("#"+o).length){t("#"+o).attr("href",e);l--}else{s=t("<link>").attr({rel:"stylesheet",href:e,id:o}).get(0);var c=t('link[rel="stylesheet"], style');if(c.length){c.get(0).parentNode.insertBefore(s,c[0])}else{_().head.appendChild(s)}if(y&&l>=31){i.raise("You have reached the browser stylesheet limit (31)",true);return}}if(typeof r==="function"){var h=t("<s>").attr("id","galleria-loader").hide().appendTo(_().body);H.wait({until:function(){return h.height()==1},success:function(){h.remove();r.call(s,s)},error:function(){h.remove();i.raise("Theme CSS could not load after 20 sec. "+(i.QUIRK?"Your browser is in Quirks Mode, please add a correct doctype.":"Please download the latest theme at http://galleria.io/customer/."),true)},timeout:5e3})}return s}}}(),O=function(e){var i=".galleria-videoicon{width:60px;height:60px;position:absolute;top:50%;left:50%;z-index:1;"+"margin:-30px 0 0 -30px;cursor:pointer;background:#000;background:rgba(0,0,0,.8);border-radius:3px;-webkit-transition:all 150ms}"+".galleria-videoicon i{width:0px;height:0px;border-style:solid;border-width:10px 0 10px 16px;display:block;"+"border-color:transparent transparent transparent #ffffff;margin:20px 0 0 22px}.galleria-image:hover .galleria-videoicon{background:#000}";H.insertStyleTag(i,"galleria-videoicon");return t(H.create("galleria-videoicon")).html("<i></i>").appendTo(e).click(function(){t(this).siblings("img").mouseup()})},M=function(){var e=function(e,i,n,a){var o=this.getOptions("easing"),r=this.getStageWidth(),s={left:r*(e.rewind?-1:1)},l={left:0};if(n){s.opacity=0;l.opacity=1}else{s.opacity=1}t(e.next).css(s);H.animate(e.next,l,{duration:e.speed,complete:function(t){return function(){i();t.css({left:0})}}(t(e.next).add(e.prev)),queue:false,easing:o});if(a){e.rewind=!e.rewind}if(e.prev){s={left:0};l={left:r*(e.rewind?1:-1)};if(n){s.opacity=1;l.opacity=0}t(e.prev).css(s);H.animate(e.prev,l,{duration:e.speed,queue:false,easing:o,complete:function(){t(this).css("opacity",0)}})}};return{active:false,init:function(t,e,i){if(M.effects.hasOwnProperty(t)){M.effects[t].call(this,e,i)}},effects:{fade:function(e,i){t(e.next).css({opacity:0,left:0});H.animate(e.next,{opacity:1},{duration:e.speed,complete:i});if(e.prev){t(e.prev).css("opacity",1).show();H.animate(e.prev,{opacity:0},{duration:e.speed})}},flash:function(e,i){t(e.next).css({opacity:0,left:0});if(e.prev){H.animate(e.prev,{opacity:0},{duration:e.speed/2,complete:function(){H.animate(e.next,{opacity:1},{duration:e.speed,complete:i})}})}else{H.animate(e.next,{opacity:1},{duration:e.speed,complete:i})}},pulse:function(e,i){if(e.prev){t(e.prev).hide()}t(e.next).css({opacity:0,left:0}).show();H.animate(e.next,{opacity:1},{duration:e.speed,complete:i})},slide:function(t,i){e.apply(this,H.array(arguments))},fadeslide:function(t,i){e.apply(this,H.array(arguments).concat([true]))},doorslide:function(t,i){e.apply(this,H.array(arguments).concat([false,true]))}}}}();A.listen();t.event.special["click:fast"]={propagate:true,add:function(i){var n=function(t){if(t.touches&&t.touches.length){var e=t.touches[0];return{x:e.pageX,y:e.pageY}}};var a={touched:false,touchdown:false,coords:{x:0,y:0},evObj:{}};t(this).data({clickstate:a,timer:0}).on("touchstart.fast",function(i){e.clearTimeout(t(this).data("timer"));t(this).data("clickstate",{touched:true,touchdown:true,coords:n(i.originalEvent),evObj:i})}).on("touchmove.fast",function(e){var i=n(e.originalEvent),a=t(this).data("clickstate"),o=Math.max(Math.abs(a.coords.x-i.x),Math.abs(a.coords.y-i.y));if(o>6){t(this).data("clickstate",t.extend(a,{touchdown:false}))}}).on("touchend.fast",function(n){var o=t(this),r=o.data("clickstate");if(r.touchdown){i.handler.call(this,n)}o.data("timer",e.setTimeout(function(){o.data("clickstate",a)},400))}).on("click.fast",function(e){var n=t(this).data("clickstate");if(n.touched){return false}t(this).data("clickstate",a);i.handler.call(this,e)})},remove:function(){t(this).off("touchstart.fast touchmove.fast touchend.fast click.fast")}};r.on("orientationchange",function(){t(this).resize()});i=function(){var s=this;this._options={};this._playing=false;this._playtime=5e3;this._active=null;this._queue={length:0};this._data=[];this._dom={};this._thumbnails=[];this._layers=[];this._initialized=false;this._firstrun=false;this._stageWidth=0;this._stageHeight=0;this._target=n;this._binds=[];this._id=parseInt(g.random()*1e4,10);var l="container stage images image-nav image-nav-left image-nav-right "+"info info-text info-title info-description "+"thumbnails thumbnails-list thumbnails-container thumb-nav-left thumb-nav-right "+"loader counter tooltip",c="current total";t.each(l.split(" "),function(t,e){s._dom[e]=H.create("galleria-"+e)});t.each(c.split(" "),function(t,e){s._dom[e]=H.create("galleria-"+e,"span")});var h=this._keyboard={keys:{UP:38,DOWN:40,LEFT:37,RIGHT:39,RETURN:13,ESCAPE:27,BACKSPACE:8,SPACE:32},map:{},bound:false,press:function(t){var e=t.keyCode||t.which;if(e in h.map&&typeof h.map[e]==="function"){h.map[e].call(s,t)}},attach:function(t){var e,i;for(e in t){if(t.hasOwnProperty(e)){i=e.toUpperCase();if(i in h.keys){h.map[h.keys[i]]=t[e]}else{h.map[i]=t[e]}}}if(!h.bound){h.bound=true;o.on("keydown",h.press)}},detach:function(){h.bound=false;h.map={};o.off("keydown",h.press)}};var u=this._controls={0:n,1:n,active:0,swap:function(){u.active=u.active?0:1},getActive:function(){return s._options.swipe?u.slides[s._active]:u[u.active]},getNext:function(){return s._options.swipe?u.slides[s.getNext(s._active)]:u[1-u.active]},slides:[],frames:[],layers:[]};var d=this._carousel={next:s.$("thumb-nav-right"),prev:s.$("thumb-nav-left"),width:0,current:0,max:0,hooks:[],update:function(){var e=0,i=0,n=[0];t.each(s._thumbnails,function(a,o){if(o.ready){e+=o.outerWidth||t(o.container).outerWidth(true);var r=t(o.container).width();e+=r-g.floor(r);n[a+1]=e;i=g.max(i,o.outerHeight||t(o.container).outerHeight(true))}});s.$("thumbnails").css({width:e,height:i});d.max=e;d.hooks=n;d.width=s.$("thumbnails-list").width();d.setClasses();s.$("thumbnails-container").toggleClass("galleria-carousel",e>d.width);d.width=s.$("thumbnails-list").width()},bindControls:function(){var t;d.next.on("click:fast",function(e){e.preventDefault();if(s._options.carouselSteps==="auto"){for(t=d.current;t<d.hooks.length;t++){if(d.hooks[t]-d.hooks[d.current]>d.width){d.set(t-2);break}}}else{d.set(d.current+s._options.carouselSteps)}});d.prev.on("click:fast",function(e){e.preventDefault();if(s._options.carouselSteps==="auto"){for(t=d.current;t>=0;t--){if(d.hooks[d.current]-d.hooks[t]>d.width){d.set(t+2);break}else if(t===0){d.set(0);break}}}else{d.set(d.current-s._options.carouselSteps)}})},set:function(t){t=g.max(t,0);while(d.hooks[t-1]+d.width>=d.max&&t>=0){t--}d.current=t;d.animate()},getLast:function(t){return(t||d.current)-1},follow:function(t){if(t===0||t===d.hooks.length-2){d.set(t);return}var e=d.current;while(d.hooks[e]-d.hooks[d.current]<d.width&&e<=d.hooks.length){e++}if(t-1<d.current){d.set(t-1)}else if(t+2>e){d.set(t-e+d.current+2)}},setClasses:function(){d.prev.toggleClass("disabled",!d.current);d.next.toggleClass("disabled",d.hooks[d.current]+d.width>=d.max)},animate:function(e){d.setClasses();var i=d.hooks[d.current]*-1;if(isNaN(i)){return}s.$("thumbnails").css("left",function(){return t(this).css("left")});H.animate(s.get("thumbnails"),{left:i},{duration:s._options.carouselSpeed,easing:s._options.easing,queue:false})}};var p=this._tooltip={initialized:false,open:false,timer:"tooltip"+s._id,swapTimer:"swap"+s._id,init:function(){p.initialized=true;var t=".galleria-tooltip{padding:3px 8px;max-width:50%;background:#ffe;color:#000;z-index:3;position:absolute;font-size:11px;line-height:1.3;"+"opacity:0;box-shadow:0 0 2px rgba(0,0,0,.4);-moz-box-shadow:0 0 2px rgba(0,0,0,.4);-webkit-box-shadow:0 0 2px rgba(0,0,0,.4);}";H.insertStyleTag(t,"galleria-tooltip");s.$("tooltip").css({opacity:.8,visibility:"visible",display:"none"})},move:function(t){var e=s.getMousePosition(t).x,i=s.getMousePosition(t).y,n=s.$("tooltip"),a=e,o=i,r=n.outerHeight(true)+1,l=n.outerWidth(true),c=r+15;var h=s.$("container").width()-l-2,u=s.$("container").height()-r-2;if(!isNaN(a)&&!isNaN(o)){a+=10;o-=r+8;a=g.max(0,g.min(h,a));o=g.max(0,g.min(u,o));if(i<c){o=c}n.css({left:a,top:o})}},bind:function(e,n){if(i.TOUCH){return}if(!p.initialized){p.init()}var a=function(){s.$("container").off("mousemove",p.move);s.clearTimer(p.timer);s.$("tooltip").stop().animate({opacity:0},200,function(){s.$("tooltip").hide();s.addTimer(p.swapTimer,function(){p.open=false},1e3)})};var o=function(e,i){p.define(e,i);t(e).hover(function(){s.clearTimer(p.swapTimer);s.$("container").off("mousemove",p.move).on("mousemove",p.move).trigger("mousemove");p.show(e);s.addTimer(p.timer,function(){s.$("tooltip").stop().show().animate({opacity:1});p.open=true},p.open?0:500)},a).click(a)};if(typeof n==="string"){o(e in s._dom?s.get(e):e,n)}else{t.each(e,function(t,e){o(s.get(t),e)})}},show:function(i){i=t(i in s._dom?s.get(i):i);var n=i.data("tt"),a=function(t){e.setTimeout(function(t){return function(){p.move(t)}}(t),10);i.off("mouseup",a)};n=typeof n==="function"?n():n;if(!n){return}s.$("tooltip").html(n.replace(/\s/,"&#160;"));i.on("mouseup",a)},define:function(e,i){if(typeof i!=="function"){var n=i;i=function(){return n}}e=t(e in s._dom?s.get(e):e).data("tt",i);p.show(e)}};var m=this._fullscreen={scrolled:0,crop:n,active:false,prev:t(),beforeEnter:function(t){t()},beforeExit:function(t){t()},keymap:s._keyboard.map,parseCallback:function(e,i){return M.active?function(){if(typeof e=="function"){e.call(s)}var n=s._controls.getActive(),a=s._controls.getNext();s._scaleImage(a);s._scaleImage(n);if(i&&s._options.trueFullscreen){t(n.container).add(a.container).trigger("transitionend")}}:e},enter:function(t){m.beforeEnter(function(){t=m.parseCallback(t,true);if(s._options.trueFullscreen&&A.support){m.active=true;H.forceStyles(s.get("container"),{width:"100%",height:"100%"});s.rescale();if(i.MAC){if(!(i.SAFARI&&/version\/[1-5]/.test(f))){s.$("container").css("opacity",0).addClass("fullscreen");e.setTimeout(function(){m.scale();s.$("container").css("opacity",1)},50)}else{s.$("stage").css("opacity",0);e.setTimeout(function(){m.scale();s.$("stage").css("opacity",1)},4)}}else{s.$("container").addClass("fullscreen")}r.resize(m.scale);A.enter(s,t,s.get("container"))}else{m.scrolled=r.scrollTop();if(!i.TOUCH){e.scrollTo(0,0)}m._enter(t)}})},_enter:function(o){m.active=true;if(b){m.iframe=function(){var n,o=a.referrer,r=a.createElement("a"),s=e.location;r.href=o;if(r.protocol!=s.protocol||r.hostname!=s.hostname||r.port!=s.port){i.raise("Parent fullscreen not available. Iframe protocol, domains and ports must match.");return false}m.pd=e.parent.document;t(m.pd).find("iframe").each(function(){var t=this.contentDocument||this.contentWindow.document;if(t===a){n=this;return false}});return n}()}H.hide(s.getActiveImage());if(b&&m.iframe){m.iframe.scrolled=t(e.parent).scrollTop();e.parent.scrollTo(0,0)}var l=s.getData(),c=s._options,h=!s._options.trueFullscreen||!A.support,u={height:"100%",overflow:"hidden",margin:0,padding:0};if(h){s.$("container").addClass("fullscreen");m.prev=s.$("container").prev();if(!m.prev.length){m.parent=s.$("container").parent()}s.$("container").appendTo("body");H.forceStyles(s.get("container"),{position:i.TOUCH?"absolute":"fixed",top:0,left:0,width:"100%",height:"100%",zIndex:1e4});H.forceStyles(_().html,u);H.forceStyles(_().body,u)}if(b&&m.iframe){H.forceStyles(m.pd.documentElement,u);H.forceStyles(m.pd.body,u);H.forceStyles(m.iframe,t.extend(u,{width:"100%",height:"100%",top:0,left:0,position:"fixed",zIndex:1e4,border:"none"}))}m.keymap=t.extend({},s._keyboard.map);s.attachKeyboard({escape:s.exitFullscreen,right:s.next,left:s.prev});m.crop=c.imageCrop;if(c.fullscreenCrop!=n){c.imageCrop=c.fullscreenCrop}if(l&&l.big&&l.image!==l.big){var f=new i.Picture,d=f.isCached(l.big),p=s.getIndex(),g=s._thumbnails[p];s.trigger({type:i.LOADSTART,cached:d,rewind:false,index:p,imageTarget:s.getActiveImage(),thumbTarget:g,galleriaData:l});f.load(l.big,function(e){s._scaleImage(e,{complete:function(e){s.trigger({type:i.LOADFINISH,cached:d,index:p,rewind:false,imageTarget:e.image,thumbTarget:g});var n=s._controls.getActive().image;if(n){t(n).width(e.image.width).height(e.image.height).attr("style",t(e.image).attr("style")).attr("src",e.image.src)}}})});var v=s.getNext(p),y=new i.Picture,w=s.getData(v);y.preload(s.isFullscreen()&&w.big?w.big:w.image)}s.rescale(function(){s.addTimer(false,function(){if(h){H.show(s.getActiveImage())}if(typeof o==="function"){o.call(s)}s.rescale()},100);s.trigger(i.FULLSCREEN_ENTER)});if(!h){H.show(s.getActiveImage())}else{r.resize(m.scale)}},scale:function(){s.rescale()},exit:function(t){m.beforeExit(function(){t=m.parseCallback(t);if(s._options.trueFullscreen&&A.support){A.exit(t)}else{m._exit(t)}})},_exit:function(t){m.active=false;var n=!s._options.trueFullscreen||!A.support,a=s.$("container").removeClass("fullscreen");if(m.parent){m.parent.prepend(a)}else{a.insertAfter(m.prev)}if(n){H.hide(s.getActiveImage());H.revertStyles(s.get("container"),_().html,_().body);if(!i.TOUCH){e.scrollTo(0,m.scrolled)}var o=s._controls.frames[s._controls.active];if(o&&o.image){o.image.src=o.image.src}}if(b&&m.iframe){H.revertStyles(m.pd.documentElement,m.pd.body,m.iframe);if(m.iframe.scrolled){e.parent.scrollTo(0,m.iframe.scrolled)}}s.detachKeyboard();s.attachKeyboard(m.keymap);s._options.imageCrop=m.crop;var l=s.getData().big,c=s._controls.getActive().image;if(!s.getData().iframe&&c&&l&&l==c.src){e.setTimeout(function(t){return function(){c.src=t}}(s.getData().image),1)}s.rescale(function(){s.addTimer(false,function(){if(n){H.show(s.getActiveImage())}if(typeof t==="function"){t.call(s)}r.trigger("resize")},50);s.trigger(i.FULLSCREEN_EXIT)});r.off("resize",m.scale)}};var v=this._idle={trunk:[],bound:false,active:false,add:function(e,n,a,o){if(!e||i.TOUCH){return}if(!v.bound){v.addEvent()}e=t(e);if(typeof a=="boolean"){o=a;a={}}a=a||{};var r={},s;for(s in n){if(n.hasOwnProperty(s)){r[s]=e.css(s)}}e.data("idle",{from:t.extend(r,a),to:n,complete:true,busy:false});if(!o){v.addTimer()}else{e.css(n)}v.trunk.push(e)},remove:function(e){e=t(e);t.each(v.trunk,function(t,i){if(i&&i.length&&!i.not(e).length){e.css(e.data("idle").from);v.trunk.splice(t,1)}});if(!v.trunk.length){v.removeEvent();s.clearTimer(v.timer)}},addEvent:function(){v.bound=true;s.$("container").on("mousemove click",v.showAll);if(s._options.idleMode=="hover"){s.$("container").on("mouseleave",v.hide)}},removeEvent:function(){v.bound=false;s.$("container").on("mousemove click",v.showAll);if(s._options.idleMode=="hover"){s.$("container").off("mouseleave",v.hide)}},addTimer:function(){if(s._options.idleMode=="hover"){return}s.addTimer("idle",function(){v.hide()},s._options.idleTime)},hide:function(){if(!s._options.idleMode||s.getIndex()===false){return}s.trigger(i.IDLE_ENTER);var e=v.trunk.length;t.each(v.trunk,function(t,i){var n=i.data("idle");if(!n){return}i.data("idle").complete=false;H.animate(i,n.to,{duration:s._options.idleSpeed,complete:function(){if(t==e-1){v.active=false}}})})},showAll:function(){s.clearTimer("idle");t.each(v.trunk,function(t,e){v.show(e)})},show:function(e){var n=e.data("idle");if(!v.active||!n.busy&&!n.complete){n.busy=true;s.trigger(i.IDLE_EXIT);s.clearTimer("idle");H.animate(e,n.from,{duration:s._options.idleSpeed/2,complete:function(){v.active=true;t(e).data("idle").busy=false;t(e).data("idle").complete=true}})}v.addTimer()}};var w=this._lightbox={width:0,height:0,initialized:false,active:null,image:null,elems:{},keymap:false,init:function(){if(w.initialized){return}w.initialized=true;var e="overlay box content shadow title info close prevholder prev nextholder next counter image",n={},a=s._options,o="",r="position:absolute;",l="lightbox-",c={overlay:"position:fixed;display:none;opacity:"+a.overlayOpacity+";filter:alpha(opacity="+a.overlayOpacity*100+");top:0;left:0;width:100%;height:100%;background:"+a.overlayBackground+";z-index:99990",box:"position:fixed;display:none;width:400px;height:400px;top:50%;left:50%;margin-top:-200px;margin-left:-200px;z-index:99991",shadow:r+"background:#000;width:100%;height:100%;",content:r+"background-color:#fff;top:10px;left:10px;right:10px;bottom:10px;overflow:hidden",info:r+"bottom:10px;left:10px;right:10px;color:#444;font:11px/13px arial,sans-serif;height:13px",close:r+"top:10px;right:10px;height:20px;width:20px;background:#fff;text-align:center;cursor:pointer;color:#444;font:16px/22px arial,sans-serif;z-index:99999",image:r+"top:10px;left:10px;right:10px;bottom:30px;overflow:hidden;display:block;",prevholder:r+"width:50%;top:0;bottom:40px;cursor:pointer;",nextholder:r+"width:50%;top:0;bottom:40px;right:-1px;cursor:pointer;",prev:r+"top:50%;margin-top:-20px;height:40px;width:30px;background:#fff;left:20px;display:none;text-align:center;color:#000;font:bold 16px/36px arial,sans-serif",next:r+"top:50%;margin-top:-20px;height:40px;width:30px;background:#fff;right:20px;left:auto;display:none;font:bold 16px/36px arial,sans-serif;text-align:center;color:#000",title:"float:left",counter:"float:right;margin-left:8px;"},h=function(e){return e.hover(function(){t(this).css("color","#bbb")},function(){t(this).css("color","#444")})},u={};var f="";if(y>7){f=y<9?"background:#000;filter:alpha(opacity=0);":"background:rgba(0,0,0,0);"}else{f="z-index:99999"}c.nextholder+=f;c.prevholder+=f;t.each(c,function(t,e){o+=".galleria-"+l+t+"{"+e+"}"});o+=".galleria-"+l+"box.iframe .galleria-"+l+"prevholder,"+".galleria-"+l+"box.iframe .galleria-"+l+"nextholder{"+"width:100px;height:100px;top:50%;margin-top:-70px}";H.insertStyleTag(o,"galleria-lightbox");t.each(e.split(" "),function(t,e){s.addElement("lightbox-"+e);n[e]=w.elems[e]=s.get("lightbox-"+e)});w.image=new i.Picture;t.each({box:"shadow content close prevholder nextholder",info:"title counter",content:"info image",prevholder:"prev",nextholder:"next"},function(e,i){var n=[];t.each(i.split(" "),function(t,e){n.push(l+e)});u[l+e]=n});s.append(u);t(n.image).append(w.image.container);t(_().body).append(n.overlay,n.box);h(t(n.close).on("click:fast",w.hide).html("&#215;"));t.each(["Prev","Next"],function(e,a){var o=t(n[a.toLowerCase()]).html(/v/.test(a)?"&#8249;&#160;":"&#160;&#8250;"),r=t(n[a.toLowerCase()+"holder"]);r.on("click:fast",function(){w["show"+a]()});if(y<8||i.TOUCH){o.show();return}r.hover(function(){o.show()},function(t){o.stop().fadeOut(200)})});t(n.overlay).on("click:fast",w.hide);if(i.IPAD){s._options.lightboxTransitionSpeed=0}},rescale:function(e){var n=g.min(r.width()-40,w.width),a=g.min(r.height()-60,w.height),o=g.min(n/w.width,a/w.height),l=g.round(w.width*o)+40,c=g.round(w.height*o)+60,h={width:l,height:c,"margin-top":g.ceil(c/2)*-1,"margin-left":g.ceil(l/2)*-1};if(e){t(w.elems.box).css(h)}else{t(w.elems.box).animate(h,{duration:s._options.lightboxTransitionSpeed,easing:s._options.easing,complete:function(){var e=w.image,n=s._options.lightboxFadeSpeed;s.trigger({type:i.LIGHTBOX_IMAGE,imageTarget:e.image});t(e.container).show();t(e.image).animate({opacity:1},n);H.show(w.elems.info,n)}})}},hide:function(){w.image.image=null;r.off("resize",w.rescale);t(w.elems.box).hide().find("iframe").remove();H.hide(w.elems.info);s.detachKeyboard();s.attachKeyboard(w.keymap);w.keymap=false;H.hide(w.elems.overlay,200,function(){t(this).hide().css("opacity",s._options.overlayOpacity);s.trigger(i.LIGHTBOX_CLOSE)})},showNext:function(){w.show(s.getNext(w.active))},showPrev:function(){w.show(s.getPrev(w.active))},show:function(n){w.active=n=typeof n==="number"?n:s.getIndex()||0;if(!w.initialized){w.init()}s.trigger(i.LIGHTBOX_OPEN);if(!w.keymap){w.keymap=t.extend({},s._keyboard.map);s.attachKeyboard({escape:w.hide,right:w.showNext,left:w.showPrev})}r.off("resize",w.rescale);var a=s.getData(n),o=s.getDataLength(),l=s.getNext(n),c,h,u;H.hide(w.elems.info);try{for(u=s._options.preload;u>0;u--){h=new i.Picture;c=s.getData(l);h.preload(c.big?c.big:c.image);l=s.getNext(l)}}catch(f){}w.image.isIframe=a.iframe&&!a.image;t(w.elems.box).toggleClass("iframe",w.image.isIframe);t(w.image.container).find(".galleria-videoicon").remove();w.image.load(a.big||a.image||a.iframe,function(i){if(i.isIframe){var l=t(e).width(),c=t(e).height();if(i.video&&s._options.maxVideoSize){var h=g.min(s._options.maxVideoSize/l,s._options.maxVideoSize/c);if(h<1){l*=h;c*=h}}w.width=l;w.height=c}else{w.width=i.original.width;w.height=i.original.height}t(i.image).css({width:i.isIframe?"100%":"100.1%",height:i.isIframe?"100%":"100.1%",top:0,bottom:0,zIndex:99998,opacity:0,visibility:"visible"}).parent().height("100%");w.elems.title.innerHTML=a.title||"";w.elems.counter.innerHTML=n+1+" / "+o;r.resize(w.rescale);w.rescale();if(a.image&&a.iframe){t(w.elems.box).addClass("iframe");if(a.video){var u=O(i.container).hide();e.setTimeout(function(){u.fadeIn(200)},200)}t(i.image).css("cursor","pointer").mouseup(function(e,i){return function(n){t(w.image.container).find(".galleria-videoicon").remove();n.preventDefault();i.isIframe=true;i.load(e.iframe+(e.video?"&autoplay=1":""),{width:"100%",height:y<8?t(w.image.container).height():"100%"})}}(a,i))}});t(w.elems.overlay).show().css("visibility","visible");t(w.elems.box).show()}};var x=this._timer={trunk:{},add:function(t,i,n,a){t=t||(new Date).getTime();a=a||false;this.clear(t);if(a){var o=i;i=function(){o();x.add(t,i,n)}}this.trunk[t]=e.setTimeout(i,n)},clear:function(t){var i=function(t){e.clearTimeout(this.trunk[t]);delete this.trunk[t]},n;if(!!t&&t in this.trunk){i.call(this,t)}else if(typeof t==="undefined"){for(n in this.trunk){if(this.trunk.hasOwnProperty(n)){i.call(this,n)}}}}};return this};i.prototype={constructor:i,init:function(e,a){a=T(a);this._original={target:e,options:a,data:null};this._target=this._dom.target=e.nodeName?e:t(e).get(0);this._original.html=this._target.innerHTML;D.push(this);if(!this._target){i.raise("Target not found",true);return}this._options={autoplay:false,carousel:true,carouselFollow:true,carouselSpeed:400,carouselSteps:"auto",clicknext:false,dailymotion:{foreground:"%23EEEEEE",highlight:"%235BCEC5",background:"%23222222",logo:0,hideInfos:1},dataConfig:function(t){return{}},dataSelector:"img",dataSort:false,dataSource:this._target,debug:n,dummy:n,easing:"galleria",extend:function(t){},fullscreenCrop:n,fullscreenDoubleTap:true,fullscreenTransition:n,height:0,idleMode:true,idleTime:3e3,idleSpeed:200,imageCrop:false,imageMargin:0,imagePan:false,imagePanSmoothness:12,imagePosition:"50%",imageTimeout:n,initialTransition:n,keepSource:false,layerFollow:true,lightbox:false,lightboxFadeSpeed:200,lightboxTransitionSpeed:200,linkSourceImages:true,maxScaleRatio:n,maxVideoSize:n,minScaleRatio:n,overlayOpacity:.85,overlayBackground:"#0b0b0b",pauseOnInteraction:true,popupLinks:false,preload:2,queue:true,responsive:true,show:0,showInfo:true,showCounter:true,showImagenav:true,swipe:"auto",theme:null,thumbCrop:true,thumbEventType:"click:fast",thumbMargin:0,thumbQuality:"auto",thumbDisplayOrder:true,thumbPosition:"50%",thumbnails:true,touchTransition:n,transition:"fade",transitionInitial:n,transitionSpeed:400,trueFullscreen:true,useCanvas:false,variation:"",videoPoster:true,vimeo:{title:0,byline:0,portrait:0,color:"aaaaaa"},wait:5e3,width:"auto",youtube:{modestbranding:1,autohide:1,color:"white",hd:1,rel:0,showinfo:0}};
this._options.initialTransition=this._options.initialTransition||this._options.transitionInitial;if(a){if(a.debug===false){c=false}if(typeof a.imageTimeout==="number"){h=a.imageTimeout}if(typeof a.dummy==="string"){u=a.dummy}if(typeof a.theme=="string"){this._options.theme=a.theme}}t(this._target).children().hide();if(i.QUIRK){i.raise("Your page is in Quirks mode, Galleria may not render correctly. Please validate your HTML and add a correct doctype.")}if(z.length){if(this._options.theme){for(var o=0;o<z.length;o++){if(this._options.theme===z[o].name){this.theme=z[o];break}}}else{this.theme=z[0]}}if(typeof this.theme=="object"){this._init()}else{P.push(this)}return this},_init:function(){var o=this,s=this._options;if(this._initialized){i.raise("Init failed: Gallery instance already initialized.");return this}this._initialized=true;if(!this.theme){i.raise("Init failed: No theme found.",true);return this}t.extend(true,s,this.theme.defaults,this._original.options,i.configure.options);s.swipe=function(t){if(t=="enforced"){return true}if(t===false||t=="disabled"){return false}return!!i.TOUCH}(s.swipe);if(s.swipe){s.clicknext=false;s.imagePan=false}!function(t){if(!("getContext"in t)){t=null;return}L=L||{elem:t,context:t.getContext("2d"),cache:{},length:0}}(a.createElement("canvas"));this.bind(i.DATA,function(){if(e.screen&&e.screen.width&&Array.prototype.forEach){this._data.forEach(function(t){var i="devicePixelRatio"in e?e.devicePixelRatio:1,n=g.max(e.screen.width,e.screen.height);if(n*i<1024){t.big=t.image}})}this._original.data=this._data;this.get("total").innerHTML=this.getDataLength();var t=this.$("container");if(o._options.height<2){o._userRatio=o._ratio=o._options.height}var n={width:0,height:0};var a=function(){return o.$("stage").height()};H.wait({until:function(){n=o._getWH();t.width(n.width).height(n.height);return a()&&n.width&&n.height>50},success:function(){o._width=n.width;o._height=n.height;o._ratio=o._ratio||n.height/n.width;if(i.WEBKIT){e.setTimeout(function(){o._run()},1)}else{o._run()}},error:function(){if(a()){i.raise("Could not extract sufficient width/height of the gallery container. Traced measures: width:"+n.width+"px, height: "+n.height+"px.",true)}else{i.raise("Could not extract a stage height from the CSS. Traced height: "+a()+"px.",true)}},timeout:typeof this._options.wait=="number"?this._options.wait:false})});this.append({"info-text":["info-title","info-description"],info:["info-text"],"image-nav":["image-nav-right","image-nav-left"],stage:["images","loader","counter","image-nav"],"thumbnails-list":["thumbnails"],"thumbnails-container":["thumb-nav-left","thumbnails-list","thumb-nav-right"],container:["stage","thumbnails-container","info","tooltip"]});H.hide(this.$("counter").append(this.get("current"),a.createTextNode(" / "),this.get("total")));this.setCounter("&#8211;");H.hide(o.get("tooltip"));this.$("container").addClass([i.TOUCH?"touch":"notouch",this._options.variation,"galleria-theme-"+this.theme.name].join(" "));if(!this._options.swipe){t.each(new Array(2),function(e){var n=new i.Picture;t(n.container).css({position:"absolute",top:0,left:0}).prepend(o._layers[e]=t(H.create("galleria-layer")).css({position:"absolute",top:0,left:0,right:0,bottom:0,zIndex:2})[0]);o.$("images").append(n.container);o._controls[e]=n;var a=new i.Picture;a.isIframe=true;t(a.container).attr("class","galleria-frame").css({position:"absolute",top:0,left:0,zIndex:4,background:"#000",display:"none"}).appendTo(n.container);o._controls.frames[e]=a})}this.$("images").css({position:"relative",top:0,left:0,width:"100%",height:"100%"});if(s.swipe){this.$("images").css({position:"absolute",top:0,left:0,width:0,height:"100%"});this.finger=new i.Finger(this.get("stage"),{onchange:function(t){o.pause().show(t)},oncomplete:function(e){var i=g.max(0,g.min(parseInt(e,10),o.getDataLength()-1)),n=o.getData(i);t(o._thumbnails[i].container).addClass("active").siblings(".active").removeClass("active");if(!n){return}o.$("images").find(".galleria-frame").css("opacity",0).hide().find("iframe").remove();if(o._options.carousel&&o._options.carouselFollow){o._carousel.follow(i)}}});this.bind(i.RESCALE,function(){this.finger.setup()});this.$("stage").on("click",function(i){var a=o.getData();if(!a){return}if(a.iframe){if(o.isPlaying()){o.pause()}var r=o._controls.frames[o._active],s=o._stageWidth,l=o._stageHeight;if(t(r.container).find("iframe").length){return}t(r.container).css({width:s,height:l,opacity:0}).show().animate({opacity:1},200);e.setTimeout(function(){r.load(a.iframe+(a.video?"&autoplay=1":""),{width:s,height:l},function(t){o.$("container").addClass("videoplay");t.scale({width:o._stageWidth,height:o._stageHeight,iframelimit:a.video?o._options.maxVideoSize:n})})},100);return}if(a.link){if(o._options.popupLinks){var c=e.open(a.link,"_blank")}else{e.location.href=a.link}return}});this.bind(i.IMAGE,function(e){o.setCounter(e.index);o.setInfo(e.index);var i=this.getNext(),n=this.getPrev();var a=[n,i];a.push(this.getNext(i),this.getPrev(n),o._controls.slides.length-1);var r=[];t.each(a,function(e,i){if(t.inArray(i,r)==-1){r.push(i)}});t.each(r,function(e,i){var n=o.getData(i),a=o._controls.slides[i],r=o.isFullscreen()&&n.big?n.big:n.image||n.iframe;if(n.iframe&&!n.image){a.isIframe=true}if(!a.ready){o._controls.slides[i].load(r,function(e){if(!e.isIframe){t(e.image).css("visibility","hidden")}o._scaleImage(e,{complete:function(e){if(!e.isIframe){t(e.image).css({opacity:0,visibility:"visible"}).animate({opacity:1},200)}}})})}})})}this.$("thumbnails, thumbnails-list").css({overflow:"hidden",position:"relative"});this.$("image-nav-right, image-nav-left").on("click:fast",function(t){if(s.pauseOnInteraction){o.pause()}var e=/right/.test(this.className)?"next":"prev";o[e]()}).on("click",function(t){t.preventDefault();if(s.clicknext||s.swipe){t.stopPropagation()}});t.each(["info","counter","image-nav"],function(t,e){if(s["show"+e.substr(0,1).toUpperCase()+e.substr(1).replace(/-/,"")]===false){H.moveOut(o.get(e.toLowerCase()))}});this.load();if(!s.keepSource&&!y){this._target.innerHTML=""}if(this.get("errors")){this.appendChild("target","errors")}this.appendChild("target","container");if(s.carousel){var l=0,c=s.show;this.bind(i.THUMBNAIL,function(){this.updateCarousel();if(++l==this.getDataLength()&&typeof c=="number"&&c>0){this._carousel.follow(c)}})}if(s.responsive){r.on("resize",function(){if(!o.isFullscreen()){o.resize()}})}if(s.fullscreenDoubleTap){this.$("stage").on("touchstart",function(){var t,e,i,n,a,r,s=function(t){return t.originalEvent.touches?t.originalEvent.touches[0]:t};o.$("stage").on("touchmove",function(){t=0});return function(l){if(/(-left|-right)/.test(l.target.className)){return}r=H.timestamp();e=s(l).pageX;i=s(l).pageY;if(l.originalEvent.touches.length<2&&r-t<300&&e-n<20&&i-a<20){o.toggleFullscreen();l.preventDefault();return}t=r;n=e;a=i}}())}t.each(i.on.binds,function(e,i){if(t.inArray(i.hash,o._binds)==-1){o.bind(i.type,i.callback)}});return this},addTimer:function(){this._timer.add.apply(this._timer,H.array(arguments));return this},clearTimer:function(){this._timer.clear.apply(this._timer,H.array(arguments));return this},_getWH:function(){var e=this.$("container"),i=this.$("target"),n=this,a={},o;t.each(["width","height"],function(t,r){if(n._options[r]&&typeof n._options[r]==="number"){a[r]=n._options[r]}else{o=[H.parseValue(e.css(r)),H.parseValue(i.css(r)),e[r](),i[r]()];if(!n["_"+r]){o.splice(o.length,H.parseValue(e.css("min-"+r)),H.parseValue(i.css("min-"+r)))}a[r]=g.max.apply(g,o)}});if(n._userRatio){a.height=a.width*n._userRatio}return a},_createThumbnails:function(n){this.get("total").innerHTML=this.getDataLength();var o,r,s,l,c=this,h=this._options,u=n?this._data.length-n.length:0,f=u,d=[],p=0,g=y<8?"http://upload.wikimedia.org/wikipedia/commons/c/c0/Blank.gif":"data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw%3D%3D",m=function(){var t=c.$("thumbnails").find(".active");if(!t.length){return false}return t.find("img").attr("src")}(),v=typeof h.thumbnails==="string"?h.thumbnails.toLowerCase():null,_=function(t){return a.defaultView&&a.defaultView.getComputedStyle?a.defaultView.getComputedStyle(r.container,null)[t]:l.css(t)},b=function(e,n,a){return function(){t(a).append(e);c.trigger({type:i.THUMBNAIL,thumbTarget:e,index:n,galleriaData:c.getData(n)})}},w=function(e){if(h.pauseOnInteraction){c.pause()}var i=t(e.currentTarget).data("index");if(c.getIndex()!==i){c.show(i)}e.preventDefault()},x=function(e,n){t(e.container).css("visibility","visible");c.trigger({type:i.THUMBNAIL,thumbTarget:e.image,index:e.data.order,galleriaData:c.getData(e.data.order)});if(typeof n=="function"){n.call(c,e)}},T=function(e,i){e.scale({width:e.data.width,height:e.data.height,crop:h.thumbCrop,margin:h.thumbMargin,canvas:h.useCanvas,position:h.thumbPosition,complete:function(e){var n=["left","top"],a=["Width","Height"],o,r,s=c.getData(e.index);t.each(a,function(i,a){o=a.toLowerCase();if(h.thumbCrop!==true||h.thumbCrop===o){r={};r[o]=e[o];t(e.container).css(r);r={};r[n[i]]=0;t(e.image).css(r)}e["outer"+a]=t(e.container)["outer"+a](true)});H.toggleQuality(e.image,h.thumbQuality===true||h.thumbQuality==="auto"&&e.original.width<e.width*3);if(h.thumbDisplayOrder&&!e.lazy){t.each(d,function(t,e){if(t===p&&e.ready&&!e.displayed){p++;e.displayed=true;x(e,i);return}})}else{x(e,i)}}})};if(!n){this._thumbnails=[];this.$("thumbnails").empty()}for(;this._data[u];u++){s=this._data[u];o=s.thumb||s.image;if((h.thumbnails===true||v=="lazy")&&(s.thumb||s.image)){r=new i.Picture(u);r.index=u;r.displayed=false;r.lazy=false;r.video=false;this.$("thumbnails").append(r.container);l=t(r.container);l.css("visibility","hidden");r.data={width:H.parseValue(_("width")),height:H.parseValue(_("height")),order:u,src:o};if(h.thumbCrop!==true){l.css({width:"auto",height:"auto"})}else{l.css({width:r.data.width,height:r.data.height})}if(v=="lazy"){l.addClass("lazy");r.lazy=true;r.load(g,{height:r.data.height,width:r.data.width})}else{r.load(o,T)}if(h.preload==="all"){r.preload(s.image)}}else if(s.iframe&&v!==null||v==="empty"||v==="numbers"){r={container:H.create("galleria-image"),image:H.create("img","span"),ready:true,data:{order:u}};if(v==="numbers"){t(r.image).text(u+1)}if(s.iframe){t(r.image).addClass("iframe")}this.$("thumbnails").append(r.container);e.setTimeout(b(r.image,u,r.container),50+u*20)}else{r={container:null,image:null}}t(r.container).add(h.keepSource&&h.linkSourceImages?s.original:null).data("index",u).on(h.thumbEventType,w).data("thumbload",T);if(m===o){t(r.container).addClass("active")}this._thumbnails.push(r)}d=this._thumbnails.slice(f);return this},lazyLoad:function(e,i){var n=e.constructor==Array?e:[e],a=this,o=0;t.each(n,function(e,r){if(r>a._thumbnails.length-1){return}var s=a._thumbnails[r],l=s.data,c=function(){if(++o==n.length&&typeof i=="function"){i.call(a)}},h=t(s.container).data("thumbload");if(s.video){h.call(a,s,c)}else{s.load(l.src,function(t){h.call(a,t,c)})}});return this},lazyLoadChunks:function(t,i){var n=this.getDataLength(),a=0,o=0,r=[],s=[],l=this;i=i||0;for(;a<n;a++){s.push(a);if(++o==t||a==n-1){r.push(s);o=0;s=[]}}var c=function(t){var n=r.shift();if(n){e.setTimeout(function(){l.lazyLoad(n,function(){c(true)})},i&&t?i:0)}};c(false);return this},_run:function(){var a=this;a._createThumbnails();H.wait({timeout:1e4,until:function(){if(i.OPERA){a.$("stage").css("display","inline-block")}a._stageWidth=a.$("stage").width();a._stageHeight=a.$("stage").height();return a._stageWidth&&a._stageHeight>50},success:function(){E.push(a);if(a._options.swipe){var o=a.$("images").width(a.getDataLength()*a._stageWidth);t.each(new Array(a.getDataLength()),function(e){var n=new i.Picture,r=a.getData(e);t(n.container).css({position:"absolute",top:0,left:a._stageWidth*e}).prepend(a._layers[e]=t(H.create("galleria-layer")).css({position:"absolute",top:0,left:0,right:0,bottom:0,zIndex:2})[0]).appendTo(o);if(r.video){O(n.container)}a._controls.slides.push(n);var s=new i.Picture;s.isIframe=true;t(s.container).attr("class","galleria-frame").css({position:"absolute",top:0,left:0,zIndex:4,background:"#000",display:"none"}).appendTo(n.container);a._controls.frames.push(s)});a.finger.setup()}H.show(a.get("counter"));if(a._options.carousel){a._carousel.bindControls()}if(a._options.autoplay){a.pause();if(typeof a._options.autoplay==="number"){a._playtime=a._options.autoplay}a._playing=true}if(a._firstrun){if(a._options.autoplay){a.trigger(i.PLAY)}if(typeof a._options.show==="number"){a.show(a._options.show)}return}a._firstrun=true;if(i.History){i.History.change(function(t){if(isNaN(t)){e.history.go(-1)}else{a.show(t,n,true)}})}a.trigger(i.READY);a.theme.init.call(a,a._options);t.each(i.ready.callbacks,function(t,e){if(typeof e=="function"){e.call(a,a._options)}});a._options.extend.call(a,a._options);if(/^[0-9]{1,4}$/.test(d)&&i.History){a.show(d,n,true)}else if(a._data[a._options.show]){a.show(a._options.show)}if(a._options.autoplay){a.trigger(i.PLAY)}},error:function(){i.raise("Stage width or height is too small to show the gallery. Traced measures: width:"+a._stageWidth+"px, height: "+a._stageHeight+"px.",true)}})},load:function(e,n,a){var o=this,r=this._options;this._data=[];this._thumbnails=[];this.$("thumbnails").empty();if(typeof n==="function"){a=n;n=null}e=e||r.dataSource;n=n||r.dataSelector;a=a||r.dataConfig;if(t.isPlainObject(e)){e=[e]}if(t.isArray(e)){if(this.validate(e)){this._data=e}else{i.raise("Load failed: JSON Array not valid.")}}else{n+=",.video,.iframe";t(e).find(n).each(function(e,i){i=t(i);var n={},r=i.parent(),s=r.attr("href"),l=r.attr("rel");if(s&&(i[0].nodeName=="IMG"||i.hasClass("video"))&&S(s)){n.video=s}else if(s&&i.hasClass("iframe")){n.iframe=s}else{n.image=n.big=s}if(l){n.big=l}t.each("big title description link layer image".split(" "),function(t,e){if(i.data(e)){n[e]=i.data(e).toString()}});if(!n.big){n.big=n.image}o._data.push(t.extend({title:i.attr("title")||"",thumb:i.attr("src"),image:i.attr("src"),big:i.attr("src"),description:i.attr("alt")||"",link:i.attr("longdesc"),original:i.get(0)},n,a(i)))})}if(typeof r.dataSort=="function"){s.sort.call(this._data,r.dataSort)}else if(r.dataSort=="random"){this._data.sort(function(){return g.round(g.random())-.5})}if(this.getDataLength()){this._parseData(function(){this.trigger(i.DATA)})}return this},_parseData:function(e){var i=this,a,o=false,r=function(){var n=true;t.each(i._data,function(t,e){if(e.loading){n=false;return false}});if(n&&!o){o=true;e.call(i)}};t.each(this._data,function(e,o){a=i._data[e];if("thumb"in o===false){a.thumb=o.image}if(!o.big){a.big=o.image}if("video"in o){var s=S(o.video);if(s){a.iframe=new I(s.provider,s.id).embed()+function(){if(typeof i._options[s.provider]=="object"){var e="?",n=[];t.each(i._options[s.provider],function(t,e){n.push(t+"="+e)});if(s.provider=="youtube"){n=["wmode=opaque"].concat(n)}return e+n.join("&")}return""}();if(!a.thumb||!a.image){t.each(["thumb","image"],function(t,e){if(e=="image"&&!i._options.videoPoster){a.image=n;return}var o=new I(s.provider,s.id);if(!a[e]){a.loading=true;o.getMedia(e,function(t,e){return function(i){t[e]=i;if(e=="image"&&!t.big){t.big=t.image}delete t.loading;r()}}(a,e))}})}}}});r();return this},destroy:function(){this.$("target").data("galleria",null);this.$("container").off("galleria");this.get("target").innerHTML=this._original.html;this.clearTimer();H.removeFromArray(D,this);H.removeFromArray(E,this);if(i._waiters.length){t.each(i._waiters,function(t,i){if(i)e.clearTimeout(i)})}return this},splice:function(){var t=this,i=H.array(arguments);e.setTimeout(function(){s.splice.apply(t._data,i);t._parseData(function(){t._createThumbnails()})},2);return t},push:function(){var t=this,i=H.array(arguments);if(i.length==1&&i[0].constructor==Array){i=i[0]}e.setTimeout(function(){s.push.apply(t._data,i);t._parseData(function(){t._createThumbnails(i)})},2);return t},_getActive:function(){return this._controls.getActive()},validate:function(t){return true},bind:function(t,e){t=k(t);this.$("container").on(t,this.proxy(e));return this},unbind:function(t){t=k(t);this.$("container").off(t);return this},trigger:function(e){e=typeof e==="object"?t.extend(e,{scope:this}):{type:k(e),scope:this};this.$("container").trigger(e);return this},addIdleState:function(t,e,i,n){this._idle.add.apply(this._idle,H.array(arguments));return this},removeIdleState:function(t){this._idle.remove.apply(this._idle,H.array(arguments));return this},enterIdleMode:function(){this._idle.hide();return this},exitIdleMode:function(){this._idle.showAll();return this},enterFullscreen:function(t){this._fullscreen.enter.apply(this,H.array(arguments));return this},exitFullscreen:function(t){this._fullscreen.exit.apply(this,H.array(arguments));return this},toggleFullscreen:function(t){this._fullscreen[this.isFullscreen()?"exit":"enter"].apply(this,H.array(arguments));return this},bindTooltip:function(t,e){this._tooltip.bind.apply(this._tooltip,H.array(arguments));return this},defineTooltip:function(t,e){this._tooltip.define.apply(this._tooltip,H.array(arguments));return this},refreshTooltip:function(t){this._tooltip.show.apply(this._tooltip,H.array(arguments));return this},openLightbox:function(){this._lightbox.show.apply(this._lightbox,H.array(arguments));return this},closeLightbox:function(){this._lightbox.hide.apply(this._lightbox,H.array(arguments));return this},hasVariation:function(e){return t.inArray(e,this._options.variation.split(/\s+/))>-1},getActiveImage:function(){var t=this._getActive();return t?t.image:n},getActiveThumb:function(){return this._thumbnails[this._active].image||n},getMousePosition:function(t){return{x:t.pageX-this.$("container").offset().left,y:t.pageY-this.$("container").offset().top}},addPan:function(e){if(this._options.imageCrop===false){return}e=t(e||this.getActiveImage());var i=this,n=e.width()/2,a=e.height()/2,o=parseInt(e.css("left"),10),r=parseInt(e.css("top"),10),s=o||0,l=r||0,c=0,h=0,u=false,f=H.timestamp(),d=0,p=0,m=function(t,i,n){if(t>0){p=g.round(g.max(t*-1,g.min(0,i)));if(d!==p){d=p;if(y===8){e.parent()["scroll"+n](p*-1)}else{var a={};a[n.toLowerCase()]=p;e.css(a)}}}},v=function(t){if(H.timestamp()-f<50){return}u=true;n=i.getMousePosition(t).x;a=i.getMousePosition(t).y},_=function(t){if(!u){return}c=e.width()-i._stageWidth;h=e.height()-i._stageHeight;o=n/i._stageWidth*c*-1;r=a/i._stageHeight*h*-1;s+=(o-s)/i._options.imagePanSmoothness;l+=(r-l)/i._options.imagePanSmoothness;m(h,l,"Top");m(c,s,"Left")};if(y===8){e.parent().scrollTop(l*-1).scrollLeft(s*-1);e.css({top:0,left:0})}this.$("stage").off("mousemove",v).on("mousemove",v);this.addTimer("pan"+i._id,_,50,true);return this},proxy:function(t,e){if(typeof t!=="function"){return m}e=e||this;return function(){return t.apply(e,H.array(arguments))}},getThemeName:function(){return this.theme.name},removePan:function(){this.$("stage").off("mousemove");this.clearTimer("pan"+this._id);return this},addElement:function(e){var i=this._dom;t.each(H.array(arguments),function(t,e){i[e]=H.create("galleria-"+e)});return this},attachKeyboard:function(t){this._keyboard.attach.apply(this._keyboard,H.array(arguments));return this},detachKeyboard:function(){this._keyboard.detach.apply(this._keyboard,H.array(arguments));return this},appendChild:function(t,e){this.$(t).append(this.get(e)||e);return this},prependChild:function(t,e){this.$(t).prepend(this.get(e)||e);return this},remove:function(t){this.$(H.array(arguments).join(",")).remove();return this},append:function(t){var e,i;for(e in t){if(t.hasOwnProperty(e)){if(t[e].constructor===Array){for(i=0;t[e][i];i++){this.appendChild(e,t[e][i])}}else{this.appendChild(e,t[e])}}}return this},_scaleImage:function(e,i){e=e||this._controls.getActive();if(!e){return}var n,a=function(e){t(e.container).children(":first").css({top:g.max(0,H.parseValue(e.image.style.top)),left:g.max(0,H.parseValue(e.image.style.left)),width:H.parseValue(e.image.width),height:H.parseValue(e.image.height)})};i=t.extend({width:this._stageWidth,height:this._stageHeight,crop:this._options.imageCrop,max:this._options.maxScaleRatio,min:this._options.minScaleRatio,margin:this._options.imageMargin,position:this._options.imagePosition,iframelimit:this._options.maxVideoSize},i);if(this._options.layerFollow&&this._options.imageCrop!==true){if(typeof i.complete=="function"){n=i.complete;i.complete=function(){n.call(e,e);a(e)}}else{i.complete=a}}else{t(e.container).children(":first").css({top:0,left:0})}e.scale(i);return this},updateCarousel:function(){this._carousel.update();return this},resize:function(e,i){if(typeof e=="function"){i=e;e=n}e=t.extend({width:0,height:0},e);var a=this,o=this.$("container");t.each(e,function(t,i){if(!i){o[t]("auto");e[t]=a._getWH()[t]}});t.each(e,function(t,e){o[t](e)});return this.rescale(i)},rescale:function(e,a,o){var r=this;if(typeof e==="function"){o=e;e=n}var s=function(){r._stageWidth=e||r.$("stage").width();r._stageHeight=a||r.$("stage").height();if(r._options.swipe){t.each(r._controls.slides,function(e,i){r._scaleImage(i);t(i.container).css("left",r._stageWidth*e)});r.$("images").css("width",r._stageWidth*r.getDataLength())}else{r._scaleImage()}if(r._options.carousel){r.updateCarousel()}var n=r._controls.frames[r._controls.active];if(n){r._controls.frames[r._controls.active].scale({width:r._stageWidth,height:r._stageHeight,iframelimit:r._options.maxVideoSize})}r.trigger(i.RESCALE);if(typeof o==="function"){o.call(r)}};s.call(r);return this},refreshImage:function(){this._scaleImage();if(this._options.imagePan){this.addPan()}return this},_preload:function(){if(this._options.preload){var t,e,n=this.getNext(),a;try{for(e=this._options.preload;e>0;e--){t=new i.Picture;a=this.getData(n);t.preload(this.isFullscreen()&&a.big?a.big:a.image);n=this.getNext(n)}}catch(o){}}},show:function(n,a,o){var r=this._options.swipe;if(!r&&(this._queue.length>3||n===false||!this._options.queue&&this._queue.stalled)){return}n=g.max(0,g.min(parseInt(n,10),this.getDataLength()-1));a=typeof a!=="undefined"?!!a:n<this.getIndex();o=o||false;if(!o&&i.History){i.History.set(n.toString());return}if(this.finger&&n!==this._active){this.finger.to=-(n*this.finger.width);this.finger.index=n}this._active=n;if(r){var l=this.getData(n),c=this;if(!l){return}var h=this.isFullscreen()&&l.big?l.big:l.image||l.iframe,u=this._controls.slides[n],f=u.isCached(h),d=this._thumbnails[n];var p={cached:f,index:n,rewind:a,imageTarget:u.image,thumbTarget:d.image,galleriaData:l};this.trigger(t.extend(p,{type:i.LOADSTART}));c.$("container").removeClass("videoplay");var m=function(){c._layers[n].innerHTML=c.getData().layer||"";c.trigger(t.extend(p,{type:i.LOADFINISH}));c._playCheck()};c._preload();e.setTimeout(function(){if(!u.ready||t(u.image).attr("src")!=h){if(l.iframe&&!l.image){u.isIframe=true}u.load(h,function(e){p.imageTarget=e.image;c._scaleImage(e,m).trigger(t.extend(p,{type:i.IMAGE}));m()})}else{c.trigger(t.extend(p,{type:i.IMAGE}));m()}},100)}else{s.push.call(this._queue,{index:n,rewind:a});if(!this._queue.stalled){this._show()}}return this},_show:function(){var a=this,o=this._queue[0],r=this.getData(o.index);if(!r){return}var l=this.isFullscreen()&&r.big?r.big:r.image||r.iframe,c=this._controls.getActive(),h=this._controls.getNext(),u=h.isCached(l),f=this._thumbnails[o.index],d=function(){t(h.image).trigger("mouseup")};a.$("container").toggleClass("iframe",!!r.isIframe).removeClass("videoplay");var p=function(o,r,l,c,h){return function(){var u;M.active=false;H.toggleQuality(r.image,a._options.imageQuality);a._layers[a._controls.active].innerHTML="";t(l.container).css({zIndex:0,opacity:0}).show();t(l.container).find("iframe, .galleria-videoicon").remove();t(a._controls.frames[a._controls.active].container).hide();t(r.container).css({zIndex:1,left:0,top:0}).show();a._controls.swap();if(a._options.imagePan){a.addPan(r.image)}if(o.iframe&&o.image||o.link||a._options.lightbox||a._options.clicknext){t(r.image).css({cursor:"pointer"}).on("mouseup",function(r){if(typeof r.which=="number"&&r.which>1){return}if(o.iframe){if(a.isPlaying()){a.pause()}var s=a._controls.frames[a._controls.active],l=a._stageWidth,c=a._stageHeight;t(s.container).css({width:l,height:c,opacity:0}).show().animate({opacity:1},200);e.setTimeout(function(){s.load(o.iframe+(o.video?"&autoplay=1":""),{width:l,height:c},function(t){a.$("container").addClass("videoplay");t.scale({width:a._stageWidth,height:a._stageHeight,iframelimit:o.video?a._options.maxVideoSize:n})})},100);return}if(a._options.clicknext&&!i.TOUCH){if(a._options.pauseOnInteraction){a.pause()}a.next();return}if(o.link){if(a._options.popupLinks){u=e.open(o.link,"_blank")}else{e.location.href=o.link}return}if(a._options.lightbox){a.openLightbox()}})}a._playCheck();a.trigger({type:i.IMAGE,index:c.index,imageTarget:r.image,thumbTarget:h.image,galleriaData:o});s.shift.call(a._queue);a._queue.stalled=false;if(a._queue.length){a._show()}}}(r,h,c,o,f);if(this._options.carousel&&this._options.carouselFollow){this._carousel.follow(o.index)}a._preload();H.show(h.container);h.isIframe=r.iframe&&!r.image;t(a._thumbnails[o.index].container).addClass("active").siblings(".active").removeClass("active");a.trigger({type:i.LOADSTART,cached:u,index:o.index,rewind:o.rewind,imageTarget:h.image,thumbTarget:f.image,galleriaData:r});a._queue.stalled=true;h.load(l,function(e){var s=t(a._layers[1-a._controls.active]).html(r.layer||"").hide();a._scaleImage(e,{complete:function(e){if("image"in c){H.toggleQuality(c.image,false)}H.toggleQuality(e.image,false);a.removePan();a.setInfo(o.index);a.setCounter(o.index);if(r.layer){s.show();if(r.iframe&&r.image||r.link||a._options.lightbox||a._options.clicknext){s.css("cursor","pointer").off("mouseup").mouseup(d)}}if(r.video&&r.image){O(e.container)}var l=a._options.transition;t.each({initial:c.image===null,touch:i.TOUCH,fullscreen:a.isFullscreen()},function(t,e){if(e&&a._options[t+"Transition"]!==n){l=a._options[t+"Transition"];return false}});if(l in M.effects===false){p()}else{var h={prev:c.container,next:e.container,rewind:o.rewind,speed:a._options.transitionSpeed||400};M.active=true;M.init.call(a,l,h,p)}a.trigger({type:i.LOADFINISH,cached:u,index:o.index,rewind:o.rewind,imageTarget:e.image,thumbTarget:a._thumbnails[o.index].image,galleriaData:a.getData(o.index)})}})})},getNext:function(t){t=typeof t==="number"?t:this.getIndex();return t===this.getDataLength()-1?0:t+1},getPrev:function(t){t=typeof t==="number"?t:this.getIndex();return t===0?this.getDataLength()-1:t-1},next:function(){if(this.getDataLength()>1){this.show(this.getNext(),false)}return this},prev:function(){if(this.getDataLength()>1){this.show(this.getPrev(),true)}return this},get:function(t){return t in this._dom?this._dom[t]:null},getData:function(t){return t in this._data?this._data[t]:this._data[this._active]},getDataLength:function(){return this._data.length},getIndex:function(){return typeof this._active==="number"?this._active:false},getStageHeight:function(){return this._stageHeight},getStageWidth:function(){return this._stageWidth},getOptions:function(t){return typeof t==="undefined"?this._options:this._options[t]},setOptions:function(e,i){if(typeof e==="object"){t.extend(this._options,e)}else{this._options[e]=i}return this},play:function(t){this._playing=true;this._playtime=t||this._playtime;this._playCheck();this.trigger(i.PLAY);return this},pause:function(){this._playing=false;this.trigger(i.PAUSE);return this},playToggle:function(t){return this._playing?this.pause():this.play(t)},isPlaying:function(){return this._playing},isFullscreen:function(){return this._fullscreen.active},_playCheck:function(){var t=this,e=0,n=20,a=H.timestamp(),o="play"+this._id;if(this._playing){this.clearTimer(o);var r=function(){e=H.timestamp()-a;if(e>=t._playtime&&t._playing){t.clearTimer(o);t.next();return}if(t._playing){t.trigger({type:i.PROGRESS,percent:g.ceil(e/t._playtime*100),seconds:g.floor(e/1e3),milliseconds:e});t.addTimer(o,r,n)}};t.addTimer(o,r,n)}},setPlaytime:function(t){this._playtime=t;return this},setIndex:function(t){this._active=t;return this},setCounter:function(t){if(typeof t==="number"){t++}else if(typeof t==="undefined"){t=this.getIndex()+1}this.get("current").innerHTML=t;if(y){var e=this.$("counter"),i=e.css("opacity");if(parseInt(i,10)===1){H.removeAlpha(e[0])}else{this.$("counter").css("opacity",i)}}return this},setInfo:function(e){var i=this,n=this.getData(e);t.each(["title","description"],function(t,e){var a=i.$("info-"+e);if(!!n[e]){a[n[e].length?"show":"hide"]().html(n[e])}else{a.empty().hide()}});return this},hasInfo:function(t){var e="title description".split(" "),i;for(i=0;e[i];i++){if(!!this.getData(t)[e[i]]){return true}}return false},jQuery:function(e){var i=this,n=[];t.each(e.split(","),function(e,a){a=t.trim(a);if(i.get(a)){n.push(a)}});var a=t(i.get(n.shift()));t.each(n,function(t,e){a=a.add(i.get(e))});return a},$:function(t){return this.jQuery.apply(this,H.array(arguments))}};t.each(x,function(t,e){var n=/_/.test(e)?e.replace(/_/g,""):e;i[e.toUpperCase()]="galleria."+n});t.extend(i,{IE9:y===9,IE8:y===8,IE7:y===7,IE6:y===6,IE:y,WEBKIT:/webkit/.test(f),CHROME:/chrome/.test(f),SAFARI:/safari/.test(f)&&!/chrome/.test(f),QUIRK:y&&a.compatMode&&a.compatMode==="BackCompat",MAC:/mac/.test(navigator.platform.toLowerCase()),OPERA:!!e.opera,IPHONE:/iphone/.test(f),IPAD:/ipad/.test(f),ANDROID:/android/.test(f),TOUCH:"ontouchstart"in a});i.addTheme=function(n){if(!n.name){i.raise("No theme name specified")}if(typeof n.defaults!=="object"){n.defaults={}}else{n.defaults=T(n.defaults)}var a=false,o;if(typeof n.css==="string"){t("link").each(function(t,e){o=new RegExp(n.css);if(o.test(e.href)){a=true;F(n);return false}});if(!a){t(function(){var r=0;var s=function(){t("script").each(function(t,i){o=new RegExp("galleria\\."+n.name.toLowerCase()+"\\.");if(o.test(i.src)){a=i.src.replace(/[^\/]*$/,"")+n.css;e.setTimeout(function(){H.loadCSS(a,"galleria-theme-"+n.name,function(){F(n)})},1)}});if(!a){if(r++>5){i.raise("No theme CSS loaded")}else{e.setTimeout(s,500)}}};s()})}}else{F(n)}return n};i.loadTheme=function(n,a){if(t("script").filter(function(){return t(this).attr("src")==n}).length){return}var o=false,r;t(e).load(function(){if(!o){r=e.setTimeout(function(){if(!o){i.raise("Galleria had problems loading theme at "+n+". Please check theme path or load manually.",true)}},2e4)}});H.loadScript(n,function(){o=true;e.clearTimeout(r)});return i};i.get=function(t){if(!!D[t]){return D[t]}else if(typeof t!=="number"){return D}else{i.raise("Gallery index "+t+" not found")}};i.configure=function(e,n){var a={};if(typeof e=="string"&&n){a[e]=n;e=a}else{t.extend(a,e)}i.configure.options=a;t.each(i.get(),function(t,e){e.setOptions(a)});return i};i.configure.options={};i.on=function(e,n){if(!e){return}n=n||m;var a=e+n.toString().replace(/\s/g,"")+H.timestamp();t.each(i.get(),function(t,i){i._binds.push(a);i.bind(e,n)});i.on.binds.push({type:e,callback:n,hash:a});return i};i.on.binds=[];i.run=function(e,n){if(t.isFunction(n)){n={extend:n}}t(e||"#galleria").galleria(n);return i};i.addTransition=function(t,e){M.effects[t]=e;return i};i.utils=H;i.log=function(){var i=H.array(arguments);if("console"in e&&"log"in e.console){try{return e.console.log.apply(e.console,i)}catch(n){t.each(i,function(){e.console.log(this)})}}else{return e.alert(i.join("<br>"))}};i.ready=function(e){if(typeof e!="function"){return i}t.each(E,function(t,i){e.call(i,i._options)});i.ready.callbacks.push(e);return i};i.ready.callbacks=[];i.raise=function(e,i){var n=i?"Fatal error":"Error",a={color:"#fff",position:"absolute",top:0,left:0,zIndex:1e5},o=function(e){var o='<div style="padding:4px;margin:0 0 2px;background:#'+(i?"811":"222")+';">'+(i?"<strong>"+n+": </strong>":"")+e+"</div>";t.each(D,function(){var t=this.$("errors"),e=this.$("target");if(!t.length){e.css("position","relative");t=this.addElement("errors").appendChild("target","errors").$("errors").css(a)}t.append(o)});if(!D.length){t("<div>").css(t.extend(a,{position:"fixed"})).append(o).appendTo(_().body)
}};if(c){o(e);if(i){throw new Error(n+": "+e)}}else if(i){if($){return}$=true;i=false;o("Gallery could not load.")}};i.version=l;i.requires=function(t,e){e=e||"You need to upgrade Galleria to version "+t+" to use one or more components.";if(i.version<t){i.raise(e,true)}return i};i.Picture=function(e){this.id=e||null;this.image=null;this.container=H.create("galleria-image");t(this.container).css({overflow:"hidden",position:"relative"});this.original={width:0,height:0};this.ready=false;this.isIframe=false};i.Picture.prototype={cache:{},show:function(){H.show(this.image)},hide:function(){H.moveOut(this.image)},clear:function(){this.image=null},isCached:function(t){return!!this.cache[t]},preload:function(e){t(new Image).load(function(t,e){return function(){e[t]=t}}(e,this.cache)).attr("src",e)},load:function(n,a,o){if(typeof a=="function"){o=a;a=null}if(this.isIframe){var r="if"+(new Date).getTime();var s=this.image=t("<iframe>",{src:n,frameborder:0,id:r,allowfullscreen:true,css:{visibility:"hidden"}})[0];if(a){t(s).css(a)}t(this.container).find("iframe,img").remove();this.container.appendChild(this.image);t("#"+r).load(function(i,n){return function(){e.setTimeout(function(){t(i.image).css("visibility","visible");if(typeof n=="function"){n.call(i,i)}},10)}}(this,o));return this.container}this.image=new Image;if(i.IE8){t(this.image).css("filter","inherit")}if(!i.IE&&!i.CHROME&&!i.SAFARI){t(this.image).css("image-rendering","optimizequality")}var l=false,c=false,h=t(this.container),f=t(this.image),d=function(){if(!l){l=true;e.setTimeout(function(t,e){return function(){t.attr("src",e+(e.indexOf("?")>-1?"&":"?")+H.timestamp())}}(t(this),n),50)}else{if(u){t(this).attr("src",u)}else{i.raise("Image not found: "+n)}}},p=function(n,o,r){return function(){var s=function(){t(this).off("load");n.original=a||{height:this.height,width:this.width};if(i.HAS3D){this.style.MozTransform=this.style.webkitTransform="translate3d(0,0,0)"}h.append(this);n.cache[r]=r;if(typeof o=="function"){e.setTimeout(function(){o.call(n,n)},1)}};if(!this.width||!this.height){!function(e){H.wait({until:function(){return e.width&&e.height},success:function(){s.call(e)},error:function(){if(!c){t(new Image).load(p).attr("src",e.src);c=true}else{i.raise("Could not extract width/height from image: "+e.src+". Traced measures: width:"+e.width+"px, height: "+e.height+"px.")}},timeout:100})}(this)}else{s.call(this)}}}(this,o,n);h.find("iframe,img").remove();f.css("display","block");H.hide(this.image);t.each("minWidth minHeight maxWidth maxHeight".split(" "),function(t,e){f.css(e,/min/.test(e)?"0":"none")});f.load(p).on("error",d).attr("src",n);return this.container},scale:function(e){var a=this;e=t.extend({width:0,height:0,min:n,max:n,margin:0,complete:m,position:"center",crop:false,canvas:false,iframelimit:n},e);if(this.isIframe){var o=e.width,r=e.height,s,l;if(e.iframelimit){var c=g.min(e.iframelimit/o,e.iframelimit/r);if(c<1){s=o*c;l=r*c;t(this.image).css({top:r/2-l/2,left:o/2-s/2,position:"absolute"})}else{t(this.image).css({top:0,left:0})}}t(this.image).width(s||o).height(l||r).removeAttr("width").removeAttr("height");t(this.container).width(o).height(r);e.complete.call(a,a);try{if(this.image.contentWindow){t(this.image.contentWindow).trigger("resize")}}catch(h){}return this.container}if(!this.image){return this.container}var u,f,d=t(a.container),p;H.wait({until:function(){u=e.width||d.width()||H.parseValue(d.css("width"));f=e.height||d.height()||H.parseValue(d.css("height"));return u&&f},success:function(){var i=(u-e.margin*2)/a.original.width,n=(f-e.margin*2)/a.original.height,o=g.min(i,n),r=g.max(i,n),s={"true":r,width:i,height:n,"false":o,landscape:a.original.width>a.original.height?r:o,portrait:a.original.width<a.original.height?r:o},l=s[e.crop.toString()],c="";if(e.max){l=g.min(e.max,l)}if(e.min){l=g.max(e.min,l)}t.each(["width","height"],function(e,i){t(a.image)[i](a[i]=a.image[i]=g.round(a.original[i]*l))});t(a.container).width(u).height(f);if(e.canvas&&L){L.elem.width=a.width;L.elem.height=a.height;c=a.image.src+":"+a.width+"x"+a.height;a.image.src=L.cache[c]||function(t){L.context.drawImage(a.image,0,0,a.original.width*l,a.original.height*l);try{p=L.elem.toDataURL();L.length+=p.length;L.cache[t]=p;return p}catch(e){return a.image.src}}(c)}var h={},d={},m=function(e,i,n){var o=0;if(/\%/.test(e)){var r=parseInt(e,10)/100,s=a.image[i]||t(a.image)[i]();o=g.ceil(s*-1*r+n*r)}else{o=H.parseValue(e)}return o},v={top:{top:0},left:{left:0},right:{left:"100%"},bottom:{top:"100%"}};t.each(e.position.toLowerCase().split(" "),function(t,e){if(e==="center"){e="50%"}h[t?"top":"left"]=e});t.each(h,function(e,i){if(v.hasOwnProperty(i)){t.extend(d,v[i])}});h=h.top?t.extend(h,d):d;h=t.extend({top:"50%",left:"50%"},h);t(a.image).css({position:"absolute",top:m(h.top,"height",f),left:m(h.left,"width",u)});a.show();a.ready=true;e.complete.call(a,a)},error:function(){i.raise("Could not scale image: "+a.image.src)},timeout:1e3});return this}};t.extend(t.easing,{galleria:function(t,e,i,n,a){if((e/=a/2)<1){return n/2*e*e*e+i}return n/2*((e-=2)*e*e+2)+i},galleriaIn:function(t,e,i,n,a){return n*(e/=a)*e+i},galleriaOut:function(t,e,i,n,a){return-n*(e/=a)*(e-2)+i}});i.Finger=function(){var n=g.abs;var r=i.HAS3D=function(){var e=a.createElement("p"),i,n=["webkit","O","ms","Moz",""],o,r=0,s="transform";_().html.insertBefore(e,null);for(;n[r];r++){o=n[r]?n[r]+"Transform":s;if(e.style[o]!==undefined){e.style[o]="translate3d(1px,1px,1px)";i=t(e).css(n[r]?"-"+n[r].toLowerCase()+"-"+s:s)}}_().html.removeChild(e);return i!==undefined&&i.length>0&&i!=="none"}();var s=function(){var t="RequestAnimationFrame";return e.requestAnimationFrame||e["webkit"+t]||e["moz"+t]||e["o"+t]||e["ms"+t]||function(t){e.setTimeout(t,1e3/60)}}();var l=function(i,n){this.config={start:0,duration:500,onchange:function(){},oncomplete:function(){},easing:function(t,e,i,n,a){return-n*((e=e/a-1)*e*e*e-1)+i}};this.easeout=function(t,e,i,n,a){return n*((e=e/a-1)*e*e*e*e+1)+i};if(!i.children.length){return}var a=this;t.extend(this.config,n);this.elem=i;this.child=i.children[0];this.to=this.pos=0;this.touching=false;this.start={};this.index=this.config.start;this.anim=0;this.easing=this.config.easing;if(!r){this.child.style.position="absolute";this.elem.style.position="relative"}t.each(["ontouchstart","ontouchmove","ontouchend","setup"],function(t,e){a[e]=function(t){return function(){t.apply(a,arguments)}}(a[e])});this.setX=function(){var t=a.child.style;if(!r){t.left=a.pos+"px";return}t.MozTransform=t.webkitTransform=t.transform="translate3d("+a.pos+"px,0,0)";return};t(i).on("touchstart",this.ontouchstart);t(e).on("resize",this.setup);t(e).on("orientationchange",this.setup);this.setup();!function o(){s(o);a.loop.call(a)}()};l.prototype={constructor:l,setup:function(){this.width=t(this.elem).width();this.length=g.ceil(t(this.child).width()/this.width);if(this.index!==0){this.index=g.max(0,g.min(this.index,this.length-1));this.pos=this.to=-this.width*this.index}},setPosition:function(t){this.pos=t;this.to=t},ontouchstart:function(t){var e=t.originalEvent.touches;this.start={pageX:e[0].pageX,pageY:e[0].pageY,time:+new Date};this.isScrolling=null;this.touching=true;this.deltaX=0;o.on("touchmove",this.ontouchmove);o.on("touchend",this.ontouchend)},ontouchmove:function(t){var e=t.originalEvent.touches;if(e&&e.length>1||t.scale&&t.scale!==1){return}this.deltaX=e[0].pageX-this.start.pageX;if(this.isScrolling===null){this.isScrolling=!!(this.isScrolling||g.abs(this.deltaX)<g.abs(e[0].pageY-this.start.pageY))}if(!this.isScrolling){t.preventDefault();this.deltaX/=!this.index&&this.deltaX>0||this.index==this.length-1&&this.deltaX<0?g.abs(this.deltaX)/this.width+1.8:1;this.to=this.deltaX-this.index*this.width}t.stopPropagation()},ontouchend:function(t){this.touching=false;var e=+new Date-this.start.time<250&&g.abs(this.deltaX)>40||g.abs(this.deltaX)>this.width/2,i=!this.index&&this.deltaX>0||this.index==this.length-1&&this.deltaX<0;if(!this.isScrolling){this.show(this.index+(e&&!i?this.deltaX<0?1:-1:0))}o.off("touchmove",this.ontouchmove);o.off("touchend",this.ontouchend)},show:function(t){if(t!=this.index){this.config.onchange.call(this,t)}else{this.to=-(t*this.width)}},moveTo:function(t){if(t!=this.index){this.pos=this.to=-(t*this.width);this.index=t}},loop:function(){var t=this.to-this.pos,e=1;if(this.width&&t){e=g.max(.5,g.min(1.5,g.abs(t/this.width)))}if(this.touching||g.abs(t)<=1){this.pos=this.to;t=0;if(this.anim&&!this.touching){this.config.oncomplete(this.index)}this.anim=0;this.easing=this.config.easing}else{if(!this.anim){this.anim={start:this.pos,time:+new Date,distance:t,factor:e,destination:this.to}}var i=+new Date-this.anim.time;var n=this.config.duration*this.anim.factor;if(i>n||this.anim.destination!=this.to){this.anim=0;this.easing=this.easeout;return}this.pos=this.easing(null,i,this.anim.start,this.anim.distance,n)}this.setX()}};return l}();t.fn.galleria=function(e){var n=this.selector;if(!t(this).length){t(function(){if(t(n).length){t(n).galleria(e)}else{i.utils.wait({until:function(){return t(n).length},success:function(){t(n).galleria(e)},error:function(){i.raise('Init failed: Galleria could not find the element "'+n+'".')},timeout:5e3})}});return this}return this.each(function(){if(t.data(this,"galleria")){t.data(this,"galleria").destroy();t(this).find("*").hide()}t.data(this,"galleria",(new i).init(this,e))})};if(typeof module==="object"&&module&&typeof module.exports==="object"){module.exports=i}else{e.Galleria=i;if(typeof define==="function"&&define.amd){define("galleria",["jquery"],function(){return i})}}}(jQuery,this);
(function(){if(typeof window.CustomEvent==="function"){return false}function a(d,f){f=f||{bubbles:false,cancelable:false,detail:undefined};var b=document.createEvent("CustomEvent");b.initCustomEvent(d,f.bubbles,f.cancelable,f.detail);return b}a.prototype=window.Event.prototype;window.CustomEvent=a})();var stEvent=new CustomEvent("on_async_buttons_load",{bubbles:true,cancelable:false});(function(a){var d=document.createElement(a);var f="async-buttons";if(document.getElementById(f)){return}d.type="text/javascript";d.id=f;d.src=("https:"==document.location.protocol?"https://ws.":"http://w.")+"sharethis.com/button/async-buttons.js";var b=document.getElementsByTagName("script")[0];b.parentNode.insertBefore(d,b)})("script");var stlib=stlib||{functions:[],functionCount:0,util:{prop:function(b,a){if(a){return a[b]}return function(d){return d[b]}}},dynamicOn:true,setPublisher:function(a){stlib.publisher=a},setProduct:function(a){stlib.product=a},parseQuery:function(f){var g=new Object();if(!f){return g}var a=f.split(/[;&]/);for(var d=0;d<a.length;d++){var j=a[d].split("=");if(!j||j.length!=2){continue}var b=unescape(j[0]);var h=unescape(j[1]);h=h.replace(/\+/g," ");g[b]=h}return g},getQueryParams:function(){var a=document.getElementById("st_insights_js");if(a&&a.src){var d=a.src.replace(/^[^\?]+\??/,"");var b=stlib.parseQuery(d);stlib.setPublisher(b.publisher);stlib.setProduct(b.product)}}};stlib.global={hash:stlib.util.prop("hash",document.location).substr(1)};stlib.getQueryParams();stlib.debugOn=false;stlib.debug={count:0,messages:[],debug:function(b,a){if(a&&(typeof console)!="undefined"){console.log(b)}stlib.debug.messages.push(b)},show:function(a){for(message in stlib.debug.messages){if((typeof console)!="undefined"){if(a){/ERROR/.test(stlib.debug.messages[message])?console.log(stlib.debug.messages[message]):null}else{console.log(stlib.debug.messages[message])}}}},showError:function(){stlib.debug.show(true)}};var _$d=function(a){stlib.debug.debug(a,stlib.debugOn)};var _$d0=function(){_$d(" ")};var _$d_=function(){_$d("___________________________________________")};var _$d1=function(a){_$d(_$dt()+"| "+a)};var _$d2=function(a){_$d(_$dt()+"|  * "+a)};var _$de=function(a){_$d(_$dt()+"ERROR: "+a)};var _$dt=function(){var b=new Date();var f=b.getHours();var a=b.getMinutes();var d=b.getSeconds();return f+":"+a+":"+d+" > "};stlib.allServices={adfty:{title:"Adfty"},allvoices:{title:"Allvoices"},amazon_wishlist:{title:"Amazon Wishlist"},arto:{title:"Arto"},att:{title:"AT&T"},baidu:{title:"Baidu"},blinklist:{title:"Blinklist"},blip:{title:"Blip"},blogmarks:{title:"Blogmarks"},blogger:{title:"Blogger",type:"post"},buddymarks:{title:"BuddyMarks"},buffer:{title:"Buffer"},care2:{title:"Care2"},chiq:{title:"chiq"},citeulike:{title:"CiteULike"},chiq:{title:"chiq"},corkboard:{title:"Corkboard"},dealsplus:{title:"Dealspl.us"},delicious:{title:"Delicious"},digg:{title:"Digg"},diigo:{title:"Diigo"},dzone:{title:"DZone"},edmodo:{title:"Edmodo"},email:{title:"Email"},embed_ly:{title:"Embed.ly"},evernote:{title:"Evernote"},facebook:{title:"Facebook"},fark:{title:"Fark"},fashiolista:{title:"Fashiolista"},flipboard:{title:"Flipboard"},folkd:{title:"folkd.com"},foodlve:{title:"FoodLve"},fresqui:{title:"Fresqui"},friendfeed:{title:"FriendFeed"},funp:{title:"Funp"},fwisp:{title:"fwisp"},google:{title:"Google"},googleplus:{title:"Google +"},google_bmarks:{title:"Bookmarks"},google_reader:{title:"Google Reader"},google_translate:{title:"Google Translate"},hatena:{title:"Hatena"},instapaper:{title:"Instapaper"},jumptags:{title:"Jumptags"},kaboodle:{title:"Kaboodle"},kik:{title:"Kik"},linkagogo:{title:"linkaGoGo"},linkedin:{title:"LinkedIn"},livejournal:{title:"LiveJournal",type:"post"},mail_ru:{title:"mail.ru"},meneame:{title:"Meneame"},messenger:{title:"Messenger"},mister_wong:{title:"Mr Wong"},moshare:{title:"moShare"},myspace:{title:"MySpace"},n4g:{title:"N4G"},netlog:{title:"Netlog"},netvouz:{title:"Netvouz"},newsvine:{title:"Newsvine"},nujij:{title:"NUjij"},odnoklassniki:{title:"Odnoklassniki"},oknotizie:{title:"Oknotizie"},pinterest:{title:"Pinterest"},pocket:{title:"Pocket"},print:{title:"Print"},raise_your_voice:{title:"Raise Your Voice"},reddit:{title:"Reddit"},segnalo:{title:"Segnalo"},sharethis:{title:"ShareThis"},sina:{title:"Sina"},sonico:{title:"Sonico"},startaid:{title:"Startaid"},startlap:{title:"Startlap"},stumbleupon:{title:"StumbleUpon"},stumpedia:{title:"Stumpedia"},typepad:{title:"TypePad",type:"post"},tumblr:{title:"Tumblr"},twitter:{title:"Twitter"},viadeo:{title:"Viadeo"},virb:{title:"Virb"},vkontakte:{title:"Vkontakte"},voxopolis:{title:"VOXopolis"},whatsapp:{title:"WhatsApp"},weheartit:{title:"We Heart It"},wordpress:{title:"WordPress",type:"post"},xerpi:{title:"Xerpi"},xing:{title:"Xing"},yammer:{title:"Yammer"}};stlib.allOauthServices={twitter:{title:"Twitter"},linkedIn:{title:"LinkedIn"},facebook:{title:"Facebook"}};stlib.allNativeServices={fblike:{title:"Facebook Like"},fbrec:{title:"Facebook Recommend"},fbsend:{title:"Facebook Send"},fbsub:{title:"Facebook Subscribe"},foursquaresave:{title:"Foursquare Save"},foursquarefollow:{title:"Foursquare Follow"},instagram:{title:"Instagram Badge"},plusone:{title:"Google +1"},pinterestfollow:{title:"Pinterest Follow"},twitterfollow:{title:"Twitter Follow"},youtube:{title:"Youtube Subscribe"}};stlib.allDeprecatedServices={google_bmarks:{title:"Google Bookmarks"},yahoo_bmarks:{title:"Yahoo Bookmarks"}};stlib.allOtherServices={copy:{title:"Copy Paste"},sharenow:{title:"ShareNow"},sharenow_auto:{title:"Frictionless Sharing"},fbunlike:{title:"Facebook Unlike"}};var _all_services=stlib.allServices;stlib.buttonInfo={buttonList:[],addButton:function(a){stlib.buttonInfo.buttonList.push(a)},getButton:function(a){if(!isNaN(a)){if(a>=stlib.buttonInfo.buttonList.length){return false}else{return stlib.buttonInfo.buttonList[a]}}else{for(c=0;c<stlib.buttonInfo.buttonList.length;c++){if(stlib.buttonInfo.buttonList[c].service==a){debug(stlib.buttonInfo.buttonList[c])}}}},clickButton:function(a){if(!isNaN(a)){if(a>=stlib.buttonInfo.buttonList.length){return false}else{if(stlib.buttonInfo.getButton(a).service=="sharethis"||stlib.buttonInfo.getButton(a).service=="email"||stlib.buttonInfo.getButton(a).service=="wordpress"){stlib.buttonInfo.getButton(a).popup()}else{stlib.buttonInfo.getButton(a).element.childNodes[0].onclick()}}}else{for(c=0;c<stlib.buttonInfo.buttonList.length;c++){if(stlib.buttonInfo.buttonList[c].service==a){if(stlib.buttonInfo.getButton(c).service=="sharethis"||stlib.buttonInfo.getButton(c).service=="email"||stlib.buttonInfo.getButton(c).service=="wordpress"){stlib.buttonInfo.getButton(c).popup();return true}else{stlib.buttonInfo.getButton(c).element.childNodes[0].onclick()}}}}},resetButton:function(){stlib.buttonInfo.buttonList=[]},listButton:function(){for(c=0;c<stlib.buttonInfo.buttonList.length;c++){debug(stlib.buttonInfo.buttonList[c])}}};stlib.buttonInfo.resetButton();stlib.messageQueue=function(){var a=this;this.pumpInstance=null;this.queue=[];this.dependencies=["data"];this.sending=true;this.setPumpInstance=function(b){this.pumpInstance=b};this.send=function(g,d){if((typeof(g)=="string")&&(typeof(d)=="string")){_$d_();_$d1("Queueing message: "+d+": "+g)}(typeof(g)=="string")&&(typeof(d)=="string")?this.queue.push([d,g]):null;if(this.sending==false||stlib.browser.ieFallback){if(this.pumpInstance!=null){if(this.dependencies.length>0){for(messageSet in this.queue){if(this.queue.hasOwnProperty(messageSet)&&this.queue[messageSet][0]==this.dependencies[0]){if(this.queue.length>0){_$d1("Current Queue Length: "+this.queue.length);var b=this.queue.shift();this.pumpInstance.broadcastSendMessage(b[1]);this.dependencies.shift();this.sending=true}}}}else{if(this.queue.length>0){_$d1("Current Queue Length: "+this.queue.length);var b=this.queue.shift();this.pumpInstance.broadcastSendMessage(b[1]);this.sending=true}}}else{_$d_();_$d1("Pump is null")}}if((stlib.browser.ieFallback)&&(this.queue.length>0)){var f="process"+stlib.functionCount;stlib.functionCount++;stlib.functions[f]=a.process;setTimeout("stlib.functions['"+f+"']()",500)}};this.process=function(){_$d1("Processing MessageQueue");a.sending=false;_$d(this.queue);a.send()}};stlib.sharer={sharerUrl:(("https:"==document.location.protocol)?"https://ws.":"http://wd.")+"sharethis.com/api/sharer.php",regAuto:new RegExp(/(.*?)_auto$/),constructParamString:function(){stlib.data.validate();stlib.hash.checkURL();var a=stlib.data.pageInfo;var d="?";var b;for(b in a){d+=b+"="+encodeURIComponent(a[b])+"&";_$d1("constructParamStringPageInfo: "+b+": "+a[b])}a=stlib.data.shareInfo;for(b in a){d+=b+"="+encodeURIComponent(a[b])+"&";_$d1("constructParamStringShareInfo: "+b+": "+a[b])}d+="ts="+new Date().getTime()+"&";return d.substring(0,d.length-1)},stPrint:function(){window.print()},sharePinterest:function(){if(stlib.data.get("image","shareInfo")==false||stlib.data.get("image","shareInfo")==null||stlib.data.get("pinterest_native","shareInfo")=="true"){if(typeof(stWidget)!="undefined"&&typeof(stWidget.closeWidget)==="function"){stWidget.closeWidget()}if(typeof(stcloseWidget)==="function"){stcloseWidget()}if(typeof(stToolbar)!="undefined"&&typeof(stToolbar.closeWidget)==="function"){stToolbar.closeWidget()}var a=document.createElement("script");a.setAttribute("type","text/javascript");a.setAttribute("charset","UTF-8");a.setAttribute("src","//assets.pinterest.com/js/pinmarklet.js?r="+Math.random()*99999999);document.body.appendChild(a)}},share:function(f,a){var d=stlib.sharer.constructParamString();_$d_();_$d1("Initiating a Share with the following url:");_$d2(stlib.sharer.sharerUrl+d);if((stlib.data.get("destination","shareInfo")=="print")||(stlib.data.get("destination","shareInfo")=="email")||(stlib.data.get("destination","shareInfo")=="pinterest"&&stlib.data.get("source","shareInfo").match(/share4xmobile/)==null&&stlib.data.get("source","shareInfo").match(/share4xpage/)==null&&stlib.data.get("source","shareInfo").match(/5xpage/)==null&&(stlib.data.get("image","shareInfo")==false||stlib.data.get("image","shareInfo")==null))||stlib.data.get("destination","shareInfo")=="snapsets"||stlib.data.get("destination","shareInfo")=="copy"||stlib.data.get("destination","shareInfo")=="plusone"||stlib.data.get("destination","shareInfo").match(stlib.sharer.regAuto)||(typeof(stlib.nativeButtons)!="undefined"&&stlib.nativeButtons.checkNativeButtonSupport(stlib.data.get("destination","shareInfo")))||(stlib.data.get("pinterest_native","shareInfo")!=false&&stlib.data.get("pinterest_native","shareInfo")!=null)){var b=new Image(1,1);b.src=stlib.sharer.sharerUrl+d;b.onload=function(){return}}else{if(typeof(a)!="undefined"&&a==true){window.open(stlib.sharer.sharerUrl+d,(new Date()).valueOf(),"scrollbars=1, status=1, height=480, width=640, resizable=1")}else{window.open(stlib.sharer.sharerUrl+d)}}f?f():null}};stlib.browser={iemode:null,firefox:null,firefoxVersion:null,safari:null,chrome:null,opera:null,windows:null,mac:null,ieFallback:(/MSIE [6789]/).test(navigator.userAgent),init:function(){var a=navigator.userAgent.toString().toLowerCase();if(/msie|trident/i.test(a)){if(document.documentMode){stlib.browser.iemode=document.documentMode}else{stlib.browser.iemode=5;if(document.compatMode){if(document.compatMode=="CSS1Compat"){stlib.browser.iemode=7}}}}stlib.browser.firefox=((a.indexOf("firefox")!=-1)&&(typeof InstallTrigger!=="undefined"))?true:false;stlib.browser.firefoxVersion=(a.indexOf("firefox/5.0")!=-1||a.indexOf("firefox/9.0")!=-1)?false:true;stlib.browser.safari=(a.indexOf("safari")!=-1&&a.indexOf("chrome")==-1)?true:false;stlib.browser.chrome=(a.indexOf("safari")!=-1&&a.indexOf("chrome")!=-1)?true:false;stlib.browser.opera=(window.opera||a.indexOf(" opr/")>=0)?true:false;stlib.browser.windows=(a.indexOf("windows")!=-1)?true:false;stlib.browser.mac=(a.indexOf("macintosh")!=-1)?true:false},getIEVersion:function(){return stlib.browser.iemode},isFirefox:function(){return stlib.browser.firefox},firefox8Version:function(){return stlib.browser.firefoxVersion},isSafari:function(){return stlib.browser.safari},isWindows:function(){return stlib.browser.windows},isChrome:function(){return stlib.browser.chrome},isOpera:function(){return stlib.browser.opera},isMac:function(){return stlib.browser.mac}};stlib.browser.init();stlib.browser.mobile={mobile:false,uagent:null,android:null,iOs:null,silk:null,windows:null,kindle:null,url:null,sharCreated:false,sharUrl:null,isExcerptImplementation:false,iOsVer:0,init:function(){this.uagent=navigator.userAgent.toLowerCase();if(this.isAndroid()){this.mobile=true}else{if(this.isIOs()){this.mobile=true}else{if(this.isSilk()){this.mobile=true}else{if(this.isWindowsPhone()){this.mobile=true}else{if(this.isKindle()){this.mobile=true}}}}}},isMobile:function isMobile(){return this.mobile},isAndroid:function(){if(this.android===null){this.android=this.uagent.indexOf("android")>-1}return this.android},isKindle:function(){if(this.kindle===null){this.kindle=this.uagent.indexOf("kindle")>-1}return this.kindle},isIOs:function isIOs(){if(this.iOs===null){this.iOs=(this.uagent.indexOf("ipad")>-1)||(this.uagent.indexOf("ipod")>-1)||(this.uagent.indexOf("iphone")>-1)}return this.iOs},isSilk:function(){if(this.silk===null){this.silk=this.uagent.indexOf("silk")>-1}return this.silk},getIOSVersion:function(){if(this.isIOs()){this.iOsVer=this.uagent.substr((this.uagent.indexOf("os "))+3,5).replace(/\_/g,".")}return this.iOsVer},isWindowsPhone:function(){if(this.windows===null){this.windows=this.uagent.indexOf("windows phone")>-1}return this.windows}};stlib.browser.mobile.init();stlib=stlib||{};stlib.browser=stlib.browser||{};stlib.browser.mobile=stlib.browser.mobile||{};stlib.browser.mobile.handleForMobileFriendly=function(l,d,m){if(!this.isMobile()){return false}if(typeof(stLight)==="undefined"){stLight={};stLight.publisher=d.publisher;stLight.sessionID=d.sessionID;stLight.fpc=""}var u=(typeof(l.title)!=="undefined")?l.title:encodeURIComponent(document.title);var f=(typeof(l.url)!=="undefined")?l.url:document.URL;var v=(d.short_url!=""&&d.short_url!=null)?d.short_url:"";if(d.service=="sharethis"){var u=(typeof(l.title)!=="undefined")?l.title:encodeURIComponent(document.title);var f=(typeof(l.url)!=="undefined")?l.url:document.URL;var g="";if(typeof(l.summary)!="undefined"&&l.summary!=null){g=l.summary}var a=document.createElement("form");a.setAttribute("method","GET");a.setAttribute("action","http://edge.sharethis.com/share4x/mobile.html");a.setAttribute("target","_blank");var q={url:f,title:u,summary:g,destination:d.service,publisher:stLight.publisher,fpc:stLight.fpc,sessionID:stLight.sessionID,short_url:v};if(typeof(l.image)!="undefined"&&l.image!=null){q.image=l.image}if(typeof(l.summary)!="undefined"&&l.summary!=null){q.desc=l.summary}if(typeof(m)!="undefined"&&typeof(m.exclusive_services)!="undefined"&&m.exclusive_services!=null){q.exclusive_services=m.exclusive_services}if(typeof(d.exclusive_services)!="undefined"&&d.exclusive_services!=null){q.exclusive_services=d.exclusive_services}if(typeof(m)!="undefined"&&typeof(m.services)!="undefined"&&m.services!=null){q.services=m.services}if(typeof(d.services)!="undefined"&&d.services!=null){q.services=d.services}var j=d;if(typeof(m)!="undefined"){j=m}if(typeof(j.doNotHash)!="undefined"&&j.doNotHash!=null){q.doNotHash=j.doNotHash}if(typeof(l.via)!="undefined"&&l.via!=null){q.via=l.via}q.service=d.service;q.type=d.type;if(stlib.data){var s=stlib.json.encode(stlib.data.pageInfo);var r=stlib.json.encode(stlib.data.shareInfo);if(stlib.browser.isFirefox()&&!stlib.browser.firefox8Version()){s=encodeURIComponent(encodeURIComponent(s));r=encodeURIComponent(encodeURIComponent(r))}else{s=encodeURIComponent(s);r=encodeURIComponent(r)}q.pageInfo=s;q.shareInfo=r}for(var t in q){var h=document.createElement("input");h.setAttribute("type","hidden");h.setAttribute("name",t);h.setAttribute("value",q[t]);a.appendChild(h)}document.body.appendChild(a);a.submit();return true}if(d.service=="email"){var b,p=0;stlib.browser.mobile.url=f;if(stlib.browser.mobile.sharUrl==null){stlib.browser.mobile.createSharOnPage()}var k=(v!="")?v+"%0A%0a":"{sharURLValue}%0A%0a";if((typeof(l.summary)!="undefined")&&l.summary!=null){k+=l.summary+"%0A%0a"}k+="Sent using ShareThis";var n="mailto:?";n+="subject="+u;n+="&body="+k;b=setInterval(function(){if(stlib.browser.mobile.sharUrl!=null){clearInterval(b);window.location.href=n.replace("{sharURLValue}",stlib.browser.mobile.sharUrl)}if(p>500){clearInterval(b);window.location.href=n.replace("{sharURLValue}",stlib.browser.mobile.sharUrl)}p++},100)}return true};stlib.browser.mobile.createSharOnPage=function(){if(stlib.browser.mobile.url!==""&&stlib.browser.mobile.url!==" "&&stlib.browser.mobile.url!==null&&!stlib.browser.mobile.sharCreated){var a=["return=json","cb=stlib.browser.mobile.createSharOnPage_onSuccess","service=createSharURL","url="+encodeURIComponent(stlib.browser.mobile.url)];a=a.join("&");stlib.scriptLoader.loadJavascript((("https:"==document.location.protocol)?"https://ws.":"http://wd.")+"sharethis.com/api/getApi.php?"+a,function(){})}};stlib.browser.mobile.createSharOnPage_onSuccess=function(a){if(a.status=="SUCCESS"){stlib.browser.mobile.sharCreated=true;stlib.browser.mobile.sharUrl=a.data.sharURL}else{stlib.browser.mobile.sharUrl=stlib.browser.mobile.url}};var tpcCookiesEnableCheckingDone=false;var tpcCookiesEnabledStatus=true;stlib.cookie={setCookie:function(f,o,q){var d=(navigator.userAgent.indexOf("Safari")!=-1&&navigator.userAgent.indexOf("Chrome")==-1);var b=(navigator.userAgent.indexOf("MSIE")!=-1);if(d||b){var s=(q)?q*24*60*60:0;var l=document.createElement("div");l.setAttribute("id",f);l.setAttribute("type","hidden");document.body.appendChild(l);var a=document.getElementById(f),g=document.createElement("form");try{var n=document.createElement('<iframe name="'+f+'" ></iframe>')}catch(m){n=document.createElement("iframe")}n.name=f;n.src="javascript:false";n.style.display="none";a.appendChild(n);g.action=(("https:"==document.location.protocol)?"https://sharethis.com/":"http://sharethis.com/")+"account/setCookie.php";g.method="POST";var k=document.createElement("input");k.setAttribute("type","hidden");k.setAttribute("name","name");k.setAttribute("value",f);g.appendChild(k);var r=document.createElement("input");r.setAttribute("type","hidden");r.setAttribute("name","value");r.setAttribute("value",o);g.appendChild(r);var p=document.createElement("input");p.setAttribute("type","hidden");p.setAttribute("name","time");p.setAttribute("value",s);g.appendChild(p);g.target=f;a.appendChild(g);g.submit()}else{if(q){var j=new Date();j.setTime(j.getTime()+(q*24*60*60*1000));var h="; expires="+j.toGMTString()}else{var h=""}var i=f+"="+escape(o)+h;i+="; domain="+escape(".sharethis.com")+";path=/";document.cookie=i}},setTempCookie:function(f,g,h){if(h){var d=new Date();d.setTime(d.getTime()+(h*24*60*60*1000));var a="; expires="+d.toGMTString()}else{var a=""}var b=f+"="+escape(g)+a;b+="; domain="+escape(".sharethis.com")+";path=/";document.cookie=b},getCookie:function(b){var a=document.cookie.match("(^|;) ?"+b+"=([^;]*)(;|$)");if(a){return(unescape(a[2]))}else{return false}},deleteCookie:function(f){var m="/";var l=".sharethis.com";document.cookie=f.replace(/^\s+|\s+$/g,"")+"="+((m)?";path="+m:"")+((l)?";domain="+l:"")+";expires=Thu, 01-Jan-1970 00:00:01 GMT";var d=(navigator.userAgent.indexOf("Safari")!=-1&&navigator.userAgent.indexOf("Chrome")==-1);var b=(navigator.userAgent.indexOf("MSIE")!=-1);if(d||b){var i=document.createElement("div");i.setAttribute("id",f);i.setAttribute("type","hidden");document.body.appendChild(i);var a=document.getElementById(f),g=document.createElement("form");try{var k=document.createElement('<iframe name="'+f+'" ></iframe>')}catch(j){k=document.createElement("iframe")}k.name=f;k.src="javascript:false";k.style.display="none";a.appendChild(k);g.action=(("https:"==document.location.protocol)?"https://sharethis.com/":"http://sharethis.com/")+"account/deleteCookie.php";g.method="POST";var h=document.createElement("input");h.setAttribute("type","hidden");h.setAttribute("name","name");h.setAttribute("value",f);g.appendChild(h);g.target=f;a.appendChild(g);g.submit()}},deleteAllSTCookie:function(){var f=document.cookie;f=f.split(";");for(var h=0;h<f.length;h++){var d=f[h];d=d.split("=");if(!/st_optout/.test(d[0])){var g=d[0];var k="/";var j=".edge.sharethis.com";document.cookie=g+"=;path="+k+";domain="+j+";expires=Thu, 01-Jan-1970 00:00:01 GMT"}}},setFpcCookie:function(a,i){var d=new Date;var k=d.getFullYear();var h=d.getMonth()+9;var j=d.getDate();var f=a+"="+escape(i);if(k){var b=new Date(k,h,j);f+="; expires="+b.toGMTString()}var g=stlib.cookie.getDomain();f+="; domain="+escape(g)+";path=/";document.cookie=f},getFpcCookie:function(b){var a=document.cookie.match("(^|;) ?"+b+"=([^;]*)(;|$)");if(a){return(unescape(a[2]))}else{return false}},getDomain:function(){var b=document.domain.split(/\./);var a="";if(b.length>1){a="."+b[b.length-2]+"."+b[b.length-1]}return a},checkCookiesEnabled:function(){if(!tpcCookiesEnableCheckingDone){stlib.cookie.setTempCookie("STPC","yes",1);if(stlib.cookie.getCookie("STPC")=="yes"){tpcCookiesEnabledStatus=true}else{tpcCookiesEnabledStatus=false}tpcCookiesEnableCheckingDone=true;return tpcCookiesEnabledStatus}else{return tpcCookiesEnabledStatus}},hasLocalStorage:function(){try{localStorage.setItem("stStorage","yes");localStorage.removeItem("stStorage");return true}catch(a){return false}}};stlib.fpc={cookieName:"__unam",cookieValue:"",createFpc:function(){stlib.fpc.setOptout();if(!document.domain||document.domain.search(/\.gov/)>0){return false}var j=stlib.cookie.getFpcCookie(stlib.fpc.cookieName);if(j==false){var d=Math.round(Math.random()*2147483647);d=d.toString(16);var h=(new Date()).getTime();h=h.toString(16);var g=window.location.hostname.split(/\./)[1];if(!g){return false}var i="";i=stlib.fpc.determineHash(g)+"-"+h+"-"+d+"-1";j=i}else{var b=j;var a=b.split(/\-/);if(a.length==4){var f=Number(a[3]);f++;j=a[0]+"-"+a[1]+"-"+a[2]+"-"+f}}stlib.cookie.setFpcCookie(stlib.fpc.cookieName,j);stlib.fpc.cookieValue=j;return j},setOptout:function(){opt_out=(stlib.cookie.getCookie("st_optout"));stlib.data.set("st_optout",opt_out,"pageInfo")},determineHash:function(b){var g=0;var f=0;for(var d=b.length-1;d>=0;d--){var a=parseInt(b.charCodeAt(d));g=((g<<8)&268435455)+a+(a<<12);if((f=g&161119850)!=0){g=(g^(f>>20))}}return g.toString(16)}};stlib.validate={regexes:{notEncoded:/(%[^0-7])|(%[0-7][^0-9a-f])|["{}\[\]\<\>\\\^`\|]/gi,tooEncoded:/%25([0-7][0-9a-f])/gi,publisher:/^(([a-z]{2}(-|\.))|)[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,url:/^(http|https):\/\/([a-z0-9!'\(\)\*\.\-\+:]*(\.)[a-z0-9!'\(\)\*\.\-\+:]*)((\/[a-z0-9!'\(\)\*\.\-\+:]*)*)/i,fpc:/^[0-9a-f]{7}-[0-9a-f]{11}-[0-9a-f]{7,8}-[0-9]*$/i,sessionID:/^[0-9]*\.[0-9a-f]*$/i,title:/.*/,description:/.*/,buttonType:/^(chicklet|vcount|hcount|large|custom|button|)$/,comment:/.*/,destination:/.*/,source:/.*/,image:/(^(http|https):\/\/([a-z0-9!'\(\)\*\.\-\+:]*(\.)[a-z0-9!'\(\)\*\.\-\+:]*)((\/[a-z0-9!'\(\)\*\.\-\+:]*)*))|^$/i,sourceURL:/^(http|https):\/\/([a-z0-9!'\(\)\*\.\-\+:]*(\.)[a-z0-9!'\(\)\*\.\-\+:]*)((\/[a-z0-9!'\(\)\*\.\-\+:]*)*)/i,sharURL:/(^(http|https):\/\/([a-z0-9!'\(\)\*\.\-\+:]*(\.)[a-z0-9!'\(\)\*\.\-\+:]*)((\/[a-z0-9!'\(\)\*\.\-\+:]*)*))|^$/i}};stlib.html={encode:function(a){if(stlib.html.startsWith(a,"http")){return String(a).replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}else{return String(a).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}},startsWith:function(a,b){return(a.match("^"+b)==b)}};stlib.stfp={screenResolutionDepthHash:"ERROR",pluginsListHash:"ERROR",fontsListHash:"ERROR",timezoneoffsetHash:"ERROR",checkIEPlugins:["ShockwaveFlash.ShockwaveFlash","AcroPDF.PDF","PDF.PdfCtrl","QuickTime.QuickTime","rmocx.RealPlayer G2 Control","rmocx.RealPlayer G2 Control.1","RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)","RealVideo.RealVideo(tm) ActiveX Control (32-bit)","RealPlayer","SWCtl.SWCtl","WMPlayer.OCX","AgControl.AgControl","Skype.Detection"],getPluginsHash:function(){var b="";if(stlib.browser.getIEVersion()!=null){for(var a=0;a<stlib.stfp.checkIEPlugins.length;a++){try{new ActiveXObject(stlib.stfp.checkIEPlugins[a]);b+=stlib.stfp.checkIEPlugins[a]+":"}catch(d){}}}if(stlib.browser.getIEVersion()==null||stlib.browser.getIEVersion()>=11){if(((typeof navigator)!="undefined"||navigator!=null)&&((typeof navigator.plugins)!="undefined"||navigator.plugins!=null)){for(var a=0;a<navigator.plugins.length;a++){b+=navigator.plugins[a].name+":"}}}if(b.length>0){stlib.stfp.pluginsListHash=stlib.stfp.getFpHash(b)}},getResolutionDepthHash:function(){if(screen){stlib.stfp.screenResolutionDepthHash=stlib.stfp.getFpHash((((typeof screen.width)!="undefined")?screen.width:"NA")+":"+(((typeof screen.height)!="undefined")?screen.height:"NA")+":"+(((typeof screen.colorDepth)!="undefined")?screen.colorDepth:"NA"))}},getTimezoneOffsetHash:function(){var b=new Date();var a=b.getTimezoneOffset();stlib.stfp.timezoneoffsetHash=stlib.stfp.getFpHash(a.toString())},getFontsHash:function(){var d=false;var h=document;var a=h.createElement("iframe");a.id="st_ifr";a.style.width="0px";a.style.height="0px";a.src="about:blank";var b=stlib.browser.isChrome();var f='<html><head><title>st_bf</title><script type="text/javascript">var stlib1={};stlib1.stfp={fontStr:"",fontsListHash:"ERROR",checkFonts:["Aharoni","algerian","Andalus","\'Angsana New\'","\'Apple Symbols\'","\'Arabic Typesetting\'","Arial","\'Baskerville Old Face\'","Batang","BatangChe","\'Bell MT\'","\'Berlin Sans FB\'","\'Bitstream Charter\'","\'Book Antiqua\'","\'Bookman Old Style\'","\'Bradley Hand ITC\'","Calibri","\'Californian FB\'","\'Cambria Math\'","\'Century Schoolbook\'","\'Century Schoolbook L\'","Charter","\'colonna mt\'","Consolas","Corbel","\'Cordia New\'","Courier","cursive","David","default","DFKai-SB","DilleniaUPC","DotumChe","Ebrima","\'Estrangelo Edessa\'","fantasy","FrankRuehl","Garamond","Gentium","Gungsuh","GungsuhChe","Haettenschweiler","\'Heiti TC\'","\'High Tower Text\'","\'Informal Roman\'","IrisUPC","\'Juice ITC\'","KaiTi","Kalinga","Kartika","Kokonor","Leelawadee","\'Liberation Mono\'","\'Liberation Sans\'","Loma","Magneto","\'Malgun Gothic\'","\'matura mt script capitals\'","\'Microsoft Himalaya\'","\'Microsoft JhengHei\'","\'Microsoft Sans Serif\'","\'Microsoft Uighur\'","\'Microsoft YaHei\'","\'Microsoft Yi Baiti\'","MingLiU","Mistral","Modena","\'Mongolian Baiti\'","\'Monotype Corsiva\'","\'MS Mincho\'","\'MS Outlook\'","\'MS PGothic\'","\'MS PMincho\'","\'MT Extra\'","\'Nimbus Mono L\'","\'Nimbus Sans L\'","NSimSun","Optima","Papyrus","PMingLiU-ExtB","Saab","\'Segoe Print\'","\'Segoe Script\'","\'Showcard Gothic\'","SimHei","\'Simplified Arabic\'","\'Simplified Arabic Fixed\'","SimSun","SimSun-ExtB","Tahoma","\'Traditional Arabic\'","Tunga","Ubuntu","\'URW Gothic L\'","\'URW Palladio L\'","Utopia","Verona","\'Viner Hand ITC\'","Vrinda","webdings","\'wide latin\'","Zapfino"],checkFontsLength:0,baseFonts:["monospace","sans-serif","serif"],baseFontsLength:0,testString:"mmmmmmmmmmlli",testSize:"72px",s:document.createElement("span"),sty:document.createElement("style"),hd:document.head||document.getElementsByTagName("head")[0],defaultWidth:{},defaultHeight:{},';if(b){f+="checkFontForCrome:function(checkFontIndex){var detected = false;var checkElement;for(var baseFontIndex=0;baseFontIndex<stlib1.stfp.baseFontsLength;baseFontIndex++){checkElement = document.getElementById(\"st_check_fonts_\" + checkFontIndex + \"_\" + baseFontIndex);var matched = checkElement.offsetWidth!=stlib1.stfp.defaultWidth[baseFontIndex]||checkElement.offsetHeight!=stlib1.stfp.defaultHeight[baseFontIndex];detected = detected || matched;}return detected;},createFragments:function(){var span, fragment = document.createDocumentFragment();var doc = document;var d = doc.createElement('div');d.className = 'st_fontDetect';var baseFontName, checkFontName, baseElement, checkElement;for(var baseFontIndex=0;baseFontIndex<stlib1.stfp.baseFontsLength;baseFontIndex++){baseFontName = stlib1.stfp.baseFonts[baseFontIndex];baseElement = document.createElement('span');baseElement.style.fontFamily=baseFontName;baseElement.id = \"st_base_fonts_\" + baseFontIndex;baseElement.innerHTML = stlib1.stfp.testString;baseElement.style.fontSize = stlib1.stfp.testSize;fragment.appendChild(baseElement);}for(var checkFontIndex=0;checkFontIndex<stlib1.stfp.checkFontsLength;checkFontIndex++){checkFontName = stlib1.stfp.checkFonts[checkFontIndex];for(var baseFontIndex=0;baseFontIndex<stlib1.stfp.baseFontsLength;baseFontIndex++){baseFontName = stlib1.stfp.baseFonts[baseFontIndex];checkElement = document.createElement('span');checkElement.style.fontFamily= checkFontName + ',' + baseFontName;checkElement.id = \"st_check_fonts_\" + checkFontIndex + \"_\" + baseFontIndex;checkElement.innerHTML = stlib1.stfp.testString;checkElement.style.fontSize = stlib1.stfp.testSize;fragment.appendChild(checkElement);}}d.appendChild(fragment);doc.body.appendChild(d);},"}else{f+='checkFont:function(font){var detected = false;for(var baseFontIndex=0;baseFontIndex<stlib1.stfp.baseFontsLength;baseFontIndex++){stlib1.stfp.s.style.fontFamily = font +"," + stlib1.stfp.baseFonts[baseFontIndex];var matched = stlib1.stfp.s.offsetWidth!=stlib1.stfp.defaultWidth[stlib1.stfp.baseFonts[baseFontIndex]]||stlib1.stfp.s.offsetHeight!=stlib1.stfp.defaultHeight[stlib1.stfp.baseFonts[baseFontIndex]];detected = detected || matched;}return detected;},'}f+='createStyle:function(){var css =".st_fontDetect{display:inline !important}";stlib1.stfp.sty.type="text/css";stlib1.stfp.sty.id="st_style";if(stlib1.stfp.sty.styleSheet){stlib1.stfp.sty.styleSheet.cssText = css;}else{stlib1.stfp.sty.appendChild(document.createTextNode(css))}stlib1.stfp.hd.appendChild(stlib1.stfp.sty)},getFontsHash:function(){var isBodyStyleSet = false;stlib1.stfp.s.className="st_fontDetect";stlib1.stfp.createStyle();stlib1.stfp.s.style.fontSize=stlib1.stfp.testSize;stlib1.stfp.s.innerHTML=stlib1.stfp.testString;stlib1.stfp.baseFontsLength = stlib1.stfp.baseFonts.length;stlib1.stfp.checkFontsLength = stlib1.stfp.checkFonts.length;var bodyDisplay = null;var bodyVisibility = null;if(document.body.style.display==="none"){isBodyStyleSet = true;bodyDisplay = document.body.style.display;bodyVisibility = document.body.style.visibility;document.body.style.display="block";document.body.style.visibility="hidden";}';if(b){f+="stlib1.stfp.createFragments();stlib1.stfp.defaultWidth[0] = document.getElementById('st_base_fonts_0').offsetWidth;stlib1.stfp.defaultHeight[0] = document.getElementById('st_base_fonts_0').offsetHeight;stlib1.stfp.defaultWidth[1] = document.getElementById('st_base_fonts_1').offsetWidth;stlib1.stfp.defaultHeight[1] = document.getElementById('st_base_fonts_1').offsetHeight;stlib1.stfp.defaultWidth[2] = document.getElementById('st_base_fonts_2').offsetWidth;stlib1.stfp.defaultHeight[2] = document.getElementById('st_base_fonts_2').offsetHeight;for(var checkFontIndex=0;checkFontIndex<stlib1.stfp.checkFontsLength;checkFontIndex++){var tempCheckFontName = stlib1.stfp.checkFonts[checkFontIndex];if(stlib1.stfp.checkFontForCrome(checkFontIndex)){stlib1.stfp.fontStr += tempCheckFontName +\":\";}}"}else{f+='for(var baseFontIndex=0;baseFontIndex<stlib1.stfp.baseFontsLength;baseFontIndex++){var tempBaseFontName = stlib1.stfp.baseFonts[baseFontIndex];stlib1.stfp.s.style.fontFamily = tempBaseFontName;document.body.appendChild(stlib1.stfp.s);stlib1.stfp.defaultWidth[tempBaseFontName]=stlib1.stfp.s.offsetWidth;stlib1.stfp.defaultHeight[tempBaseFontName]=stlib1.stfp.s.offsetHeight;document.body.removeChild(stlib1.stfp.s)}stlib1.stfp.s.style.fontFamily="st_font";document.body.appendChild(stlib1.stfp.s);for(var checkFontIndex=0;checkFontIndex<stlib1.stfp.checkFontsLength;checkFontIndex++){var tempCheckFontName = stlib1.stfp.checkFonts[checkFontIndex];if(stlib1.stfp.checkFont(tempCheckFontName)){stlib1.stfp.fontStr += tempCheckFontName +":"}}var sheet = document.getElementById("st_style");sheet.parentNode.removeChild(sheet);document.body.removeChild(stlib1.stfp.s);'}f+='if(isBodyStyleSet){document.body.style.display = bodyDisplay;document.body.style.visibility = bodyVisibility;}}};<\/script></head><body id="st_ifr"><div><script type="text/javascript">stlib1.stfp.getFontsHash();<\/script></div></body></html>';h.body.appendChild(a);try{a.contentWindow.document.open("text/html","replace")}catch(g){if(stlib.browser.getIEVersion()!=null){if(stlib.browser.getIEVersion()<11&&g.message.match(/denied/g)){h.body.removeChild(a);d=true}}}if(!d){a.contentWindow.document.write(f);a.contentWindow.document.close();stlib.stfp.fontsListHash=stlib.stfp.getFpHash(document.getElementById("st_ifr").contentWindow.stlib1.stfp.fontStr);h.body.removeChild(a)}},init:function(){stlib.stfp.getFontsHash()},getFpHash:function(a){var g=0,f=0;for(var d=a.length-1;d>=0;d--){var b=parseInt(a.charCodeAt(d));g=((g<<8)&268435455)+b+(b<<12);if((f=g&161119850)!=0){g=(g^(f>>20))}}return g.toString(16)}};if(typeof(stlib.data)=="undefined"){stlib.data={bInit:false,publisherKeySet:false,pageInfo:{},shareInfo:{},resetPageData:function(){stlib.data.pageInfo.fpc="ERROR";stlib.data.pageInfo.sessionID="ERROR";stlib.data.pageInfo.hostname="ERROR";stlib.data.pageInfo.location="ERROR";stlib.data.pageInfo.product="widget";stlib.data.pageInfo.stid=""},resetShareData:function(){stlib.data.shareInfo={};stlib.data.shareInfo.url="ERROR";stlib.data.shareInfo.sharURL="";stlib.data.shareInfo.buttonType="ERROR";stlib.data.shareInfo.destination="ERROR";stlib.data.shareInfo.source="ERROR"},resetData:function(){stlib.data.resetPageData();stlib.data.resetShareData()},validate:function(){var a=stlib.validate.regexes;function b(g,i){if(i!=encodeURIComponent(i)){a.notEncoded.test(i)?_$de(g+" not encoded"):null;a.tooEncoded.test(i)?_$de(g+" has too much encoding"):null}var h=a[g]?a[g].test(decodeURIComponent(i)):true;if(!h){_$de(g+" failed validation")}}var d=stlib.data.pageInfo;var f;for(f in d){b(f,d[f])}d=stlib.data.shareInfo;for(f in d){b(f,d[f])}},init:function(){if(!stlib.data.bInit){stlib.data.bInit=true;stlib.data.resetData();if(stlib.publisher){stlib.data.setPublisher(stlib.publisher)}stlib.data.set("product",stlib.product,"pageInfo");var i=document.location.href,d="",a="",h=[],l="",k="",f="",b="",g="",j="";h=stlib.data.getRefDataFromUrl(i);if(h.length>0){d=(typeof(h[0])!="undefined")?h[0]:"";a=(typeof(h[1])!="undefined")?h[1]:"";k=stlib.data.removeRefDataFromUrl(i);stlib.data.showModifiedUrl(k);stlib.data.set("url",k,"shareInfo")}else{l=document.referrer;h=l.replace("http://","").replace("https://","").split("/");d=h.shift();a=h.join("/");stlib.data.set("url",i,"shareInfo")}stlib.stfp.getPluginsHash();stlib.stfp.getResolutionDepthHash();stlib.stfp.getTimezoneOffsetHash();stlib.data.set("title",document.title,"shareInfo");if(stlib.data.publisherKeySet!=true){stlib.data.set("publisher","ur.00000000-0000-0000-0000-000000000000","pageInfo")}stlib.fpc.createFpc();stlib.data.set("fpc",stlib.fpc.cookieValue,"pageInfo");g=(new Date()).getTime().toString();j=Number(Math.random().toPrecision(5).toString().substr(2)).toString();stlib.data.set("sessionID",g+"."+j,"pageInfo");stlib.data.set("hostname",document.location.hostname,"pageInfo");stlib.data.set("location",document.location.pathname,"pageInfo");stlib.data.set("refDomain",d,"pageInfo");stlib.data.set("refQuery",a,"pageInfo")}},showModifiedUrl:function(b){if(window.history&&history.replaceState){history.replaceState(null,document.title,b)}else{if((/MSIE/).test(navigator.userAgent)){var h=0,d=window.location.hash,a=new RegExp("(&st_refDomain=?)[^&|]+"),g=new RegExp("(#st_refDomain=?)[^&|]+"),f=document.location.href;if(a.test(f)){h=d.indexOf("&st_refDomain");window.location.hash=d.substr(0,h)}else{if(g.test(f)){window.location.replace("#")}}}else{document.location.replace(b)}}},getRefDataFromUrl:function(b){var f=new RegExp("st_refDomain="),g="",d="",a=[];if(f.test(b)){g=b.match(/(st_refDomain=?)[^\&|]+/g);a.push(g[0].split("=")[1]);d=b.match(/(st_refQuery=?)[^\&|]+/g);a.push(d[0].replace("st_refQuery=",""))}return a},removeRefDataFromUrl:function(b){var g="",d="",a=new RegExp("(&st_refDomain=?)[^&|]+"),f=new RegExp("(#st_refDomain=?)[^&|]+");if(a.test(b)){g=b.replace(/\&st_refDomain=(.*)/g,"")}else{if(f.test(b)){g=b.replace(/\#st_refDomain=(.*)/g,"")}else{g=b}}return g},setPublisher:function(a){stlib.data.set("publisher",a,"pageInfo");stlib.data.publisherKeySet=true},setSource:function(d,a){var b="";if(a){if(a.toolbar){b="toolbar"+d}else{if(a.page&&a.page!="home"&&a.page!=""){b="chicklet"+d}else{b="button"+d}}}else{b=d}stlib.data.set("source",b,"shareInfo")},set:function(a,d,b){if(typeof(d)=="number"||typeof(d)=="boolean"){stlib.data[b][a]=d}else{if(typeof(d)=="undefined"||d==null){}else{stlib.data[b][a]=encodeURIComponent(decodeURIComponent(unescape(d.replace(/<[^<>]*>/gi," ")).replace(/%/gi,"%25")));if(a=="url"||a=="location"||a=="image"){try{stlib.data[b][a]=encodeURIComponent(decodeURIComponent(decodeURI(d.replace(/<[^<>]*>/gi," ")).replace(/%/gi,"%25")))}catch(f){stlib.data[b][a]=encodeURIComponent(decodeURIComponent(unescape(d.replace(/<[^<>]*>/gi," ")).replace(/%/gi,"%25")))}}}}},get:function(a,b){if(stlib.data[b]&&stlib.data[b][a]){return decodeURIComponent(stlib.data[b][a])}else{return false}},unset:function(a,b){if(stlib.data[b]&&typeof(stlib.data[b][a])!="undefined"){delete stlib.data[b][a]}}};stlib.data.resetData()}if(typeof(stlib.pixels)=="undefined"){stlib.pixels={stid:"__stid",getCurrentURL:function(){return window.location.href},trimURL:function(a){return a.split(/\?|\&|\#/)[0]},getReferrerDomain:function(){var a=document.createElement("a");a.href=document.referrer;return a.hostname},getPxcelParams:function(f,d,h){var b=stlib.pixels.getCurrentURL();var a=stlib.pixels.trimURL(b);var g=h=="simpleshare"?", htmdmn: 'tm.sharethis.com'":"";return"var pxcelData = { v0: '"+encodeURIComponent(f)+"', v1: '"+encodeURIComponent(stlib.pixels.getReferrerDomain())+"', v2: '"+encodeURIComponent("http://seg.sharethis.com/getSegment.php?purl="+encodeURIComponent(a)+"&rnd="+d)+"', v3: '"+encodeURIComponent(a)+"', v4: '"+encodeURIComponent(b)+"'"+g+" };"},getRnd:function(){return(new Date()).getTime()},getPxcelTag:function(d,h){var b=stlib.pixels.getRnd();var f=stlib.pixels.getPxcelParams(d,b,h);var a=window.top.location===window.location?window.location.toString():document.referrer;var g=a.split("/")[2];return"<script>"+f+"(function() { var pxscrpt = document.createElement('script'); pxscrpt.id = 'pxscrpt'; pxscrpt.async = true; pxscrpt.defer = true; pxscrpt.src = '//t.sharethis.com/1/d/t.dhj?rnd="+b+"&cid=c010&dmn="+g+"';document.body.appendChild(pxscrpt);})();<\/script>"},getComscoreTag:function(){return'<script type="text/javascript">var ref=document.referrer;var lurl = (("https:" == document.location.protocol) ? "https://sb." : "http://b.")+"scorecardresearch.com/";lurl+="b?";lurl+="c1=7"+"&c2=8097938"+"&rn=" +Math.round(Math.random() * 2147483647 )+ "&c7=" + encodeURIComponent(document.location.href)+ "&c3=8097938"+ "&c8="+encodeURIComponent(document.title)+ ( (ref)? "&c9="+encodeURIComponent(document.referrer) :  "" )+ "&cv=2.2"+ "&cs=js";var logger = new Image(1,1);logger.src = lurl;logger.onload = function(){return;};<\/script>'},getCookie:function(d){var b="(?:(?:^|.*;)\\s*"+d+"\\s*\\=\\s*([^;]*).*$)|^.*$";var a=new RegExp(b,"g");return document.cookie.replace(a,"$1")},isCookieSet:function(a){return stlib.pixels.getCookie(a)!==""},setAxciomCookie:function(f){var d=new Date;var b="__stacxiommap="+encodeURIComponent(f);var a=new Date(d.getTime()+(86400000));b+="; expires="+a.toGMTString();document.cookie=b},hasStid:function(){return stlib.pixels.isCookieSet(stlib.pixels.stid)},hasAcxiomCookie:function(){return stlib.pixels.isCookieSet("__stacxiommap")},fireLR:function(a,b){if(stlib.pixels.hasAcxiomCookie()||b=="simpleshare"){return""}else{stlib.pixels.setAxciomCookie(a);return'<img src="'+location.protocol+"//idsync.rlcdn.com/386076.gif?partner_uid="+a+'" alt=""/>'}},getIframeContents:function(a,b){return"<!DOCTYPE html><html><head><title>ShareThis Segmenter</title></head><body>"+stlib.pixels.getPxcelTag(a,b)+stlib.pixels.getComscoreTag()+stlib.pixels.fireLR(a,b)+"</body></html>"},createSegmentFrame:function(f){if(stlib.pixels.segmentframe||document.getElementById("stSegmentFrame")){return}try{stlib.pixels.segmentframe=document.createElement('<iframe name="stframe" allowTransparency="true" style="body{background:transparent;}" ></iframe>')}catch(d){stlib.pixels.segmentframe=document.createElement("iframe")}stlib.pixels.segmentframe.id="stSegmentFrame";stlib.pixels.segmentframe.name="stSegmentFrame";var g=document.head;stlib.pixels.segmentframe.frameBorder="0";stlib.pixels.segmentframe.scrolling="no";stlib.pixels.segmentframe.width="0px";stlib.pixels.segmentframe.height="0px";stlib.pixels.segmentframe.sandbox="allow-scripts allow-same-origin";stlib.pixels.segmentframe.setAttribute("style","display:none;");var b=stlib.data.get("stid","pageInfo");if(b){var a=stlib.pixels.getIframeContents(b,f);g.appendChild(stlib.pixels.segmentframe);stlib.pixels.segmentframe.contentWindow.document.open();stlib.pixels.segmentframe.contentWindow.document.write(a);stlib.pixels.segmentframe.contentWindow.document.close()}else{stlib.pixels.segmentframe.src=(("https:"==document.location.protocol)?"https://seg.":"http://seg.")+"sharethis.com/getSegment.php?purl="+encodeURIComponent(document.location.href)+"&jsref="+encodeURIComponent(document.referrer)+"&product="+f+"&rnd="+(new Date()).getTime();g.appendChild(stlib.pixels.segmentframe)}}}}stlib.hash={doNotHash:true,hashAddressBar:false,doNotCopy:true,prefix:"sthash",shareHash:"",incomingHash:"",validChars:["1","2","3","4","5","6","7","8","9","0","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],servicePreferences:{linkedin:"param",stumbleupon:"param",bebo:"param"},hashDestination:function(b){if(b=="copy"){return"dpuf"}var d=b.substring(0,2)+b.substring(b.length-2,b.length);var a=function(f,g){if(f.charCodeAt(g)==122){return"a"}return String.fromCharCode(f.charCodeAt(g)+1)};return a(d,0)+a(d,1)+a(d,2)+a(d,3)},getHash:function(){var d=false;var b="";var f=document.location.href;f=f.split("#").shift();var a=f.split("?");if(a.length>1){a=a[1].split("&");for(arg in a){try{if(a[arg].substring(0,6)=="sthash"){d=true;b=a[arg]}}catch(g){}}if(d){return b}else{return document.location.hash.substring(1)}}else{return document.location.hash.substring(1)}},stripHash:function(a){var b=a;b=b.split("#");if(b.length>1){return b[1]}else{return""}},clearHash:function(){if(stlib.hash.validateHash(document.location.hash)){var a=document.location.href.split("#").shift();if(window.history&&history.replaceState){history.replaceState(null,document.title,a)}else{if((/MSIE/).test(navigator.userAgent)){window.location.replace("#")}else{document.location.hash=""}}}},init:function(){var b="";var a=stlib.hash.validChars.length;for(var g=0;g<8;g++){b+=stlib.hash.validChars[Math.random()*a|0]}if(stlib.hash.getHash()==""){stlib.hash.shareHash=stlib.hash.prefix+"."+b}else{var d=stlib.hash.getHash().split(".");var f=d.shift();if(f==stlib.hash.prefix||f==stlib.hash.prefix){stlib.hash.incomingHash=stlib.hash.getHash();stlib.hash.shareHash=stlib.hash.prefix+"."+d.shift()+"."+b}else{stlib.hash.shareHash=stlib.hash.prefix+"."+b}}if(!stlib.hash.doNotHash&&stlib.hash.hashAddressBar){if(document.location.hash==""||stlib.hash.validateHash(document.location.hash)){if(window.history&&history.replaceState){history.replaceState(null,"ShareThis","#"+stlib.hash.shareHash+".dpbs")}else{if((/MSIE/).test(navigator.userAgent)){window.location.replace("#"+stlib.hash.shareHash+".dpbs")}else{document.location.hash=stlib.hash.shareHash+".dpbs"}}}}else{stlib.hash.clearHash()}if(!stlib.hash.doNotHash&&!stlib.hash.doNotCopy){stlib.hash.copyPasteInit()}stlib.hash.copyPasteLog()},checkURL:function(){var b=stlib.data.get("destination","shareInfo");var h=stlib.hash.updateParams(b);var f="."+stlib.hash.hashDestination(b);stlib.hash.updateDestination(f);if(!stlib.hash.doNotHash&&typeof(stlib.data.pageInfo.shareHash)!="undefined"){var d=stlib.data.get("url","shareInfo");var i=stlib.hash.stripHash(d);if(stlib.hash.validateHash(i)||i==""){if(typeof(stlib.hash.servicePreferences[b])!="undefined"){if(stlib.hash.servicePreferences[b]=="param"){_$d1("Don't use hash, use params");_$d2(h);if(h.split("?").length>1){var g=h.split("?")[1].split("&");var j=false;for(var a=0;a<g.length;a++){if(g[a].split(".")[0]=="sthash"){j=true}}if(j){stlib.data.set("url",h,"shareInfo")}else{stlib.data.set("url",h+"&"+stlib.data.pageInfo.shareHash,"shareInfo")}}else{stlib.data.set("url",h+"?"+stlib.data.pageInfo.shareHash,"shareInfo")}if(b=="linkedin"){if(stlib.data.get("sharURL","shareInfo")!=""){stlib.data.set("sharURL",stlib.data.get("url","shareInfo"),"shareInfo")}}}else{_$d1("Using Hash");stlib.data.set("url",h+"#"+stlib.data.pageInfo.shareHash,"shareInfo")}}else{_$d1("Not using custom destination hash type");stlib.data.set("url",h+"#"+stlib.data.pageInfo.shareHash,"shareInfo")}}}},updateParams:function(a){var h=stlib.data.get("url","shareInfo").split("#").shift();var g=/(\?)sthash\.[a-zA-z0-9]{8}\.[a-zA-z0-9]{8}/;var f=/(&)sthash\.[a-zA-z0-9]{8}\.[a-zA-z0-9]{8}/;var d=/(\?)sthash\.[a-zA-z0-9]{8}/;var b=/(&)sthash\.[a-zA-z0-9]{8}/;if(g.test(h)){h=h.replace(g,"?"+stlib.data.pageInfo.shareHash)}else{if(f.test(h)){h=h.replace(f,"&"+stlib.data.pageInfo.shareHash)}else{if(d.test(h)){h=h.replace(d,"?"+stlib.data.pageInfo.shareHash)}else{if(b.test(h)){h=h.replace(b,"&"+stlib.data.pageInfo.shareHash)}}}}return h},updateDestination:function(b){var a=/sthash\.[a-zA-z0-9]{8}\.[a-zA-z0-9]{8}\.[a-z]{4}/;var d=/sthash\.[a-zA-z0-9]{8}\.[a-z]{4}/;_$d_();_$d1("Updating Destination");if(a.test(stlib.data.pageInfo.shareHash)){_$d2(stlib.data.pageInfo.shareHash.substring(0,24));stlib.data.pageInfo.shareHash=stlib.data.pageInfo.shareHash.substring(0,24)+b}else{if(d.test(stlib.data.pageInfo.shareHash)){_$d2(stlib.data.pageInfo.shareHash.substring(0,15));stlib.data.pageInfo.shareHash=stlib.data.pageInfo.shareHash.substring(0,15)+b}else{stlib.data.pageInfo.shareHash+=b}}},validateHash:function(a){var b=/[\?#&]?sthash\.[a-zA-z0-9]{8}\.[a-zA-z0-9]{8}$/;var d=/[\?#&]?sthash\.[a-zA-z0-9]{8}\.[a-zA-z0-9]{8}\.[a-z]{4}$/;var f=/[\?#&]?sthash\.[a-zA-z0-9]{8}\.[a-z]{4}$/;var g=/[\?#&]?sthash\.[a-zA-z0-9]{8}$/;return g.test(a)||f.test(a)||d.test(a)||b.test(a)},appendHash:function(a){var b=stlib.hash.stripHash(a);if(stlib.data.pageInfo.shareHash&&(stlib.hash.validateHash(b)||b=="")){a=a.replace("#"+b,"")+"#"+stlib.data.pageInfo.shareHash}else{}return a},copyPasteInit:function(){var a=document.getElementsByTagName("body")[0];var d=document.createElement("div");d.id="stcpDiv";d.style.position="absolute";d.style.top="-1999px";d.style.left="-1988px";a.appendChild(d);d.innerHTML="ShareThis Copy and Paste";var b=document.location.href.split("#").shift();var f="#"+stlib.hash.shareHash;if(document.addEventListener){a.addEventListener("copy",function(j){if(typeof(Tynt)!="undefined"){return}var i=document.getSelection();if(i.isCollapsed){return}var h=i.getRangeAt(0).cloneContents();d.innerHTML="";d.appendChild(h);if(d.textContent.trim().length==0){return}if((i+"").trim().length==0){}else{if(d.innerHTML==(i+"")||d.textContent==(i+"")){d.innerHTML=stlib.html.encode(stlib.hash.selectionModify(i))}else{d.innerHTML+=stlib.html.encode(stlib.hash.selectionModify(i,true))}}var g=document.createRange();g.selectNodeContents(d);var k=i.getRangeAt(0);i.removeAllRanges();i.addRange(g);setTimeout(function(){i.removeAllRanges();i.addRange(k)},0)},false)}else{if(document.attachEvent){}}},copyPasteLog:function(){var d=window.addEventListener?"addEventListener":"attachEvent";var b=d=="attachEvent"?"oncopy":"copy";var a=document.getElementsByTagName("body")[0];if(a){a[d](b,function(g){var f=true;stlib.data.resetShareData();stlib.data.set("url",document.location.href,"shareInfo");stlib.data.setSource("copy");stlib.data.set("destination","copy","shareInfo");stlib.data.set("buttonType","custom","shareInfo");if(typeof(Tynt)!="undefined"){stlib.data.set("result","tynt","shareInfo");stlib.logger.log("debug");f=false}if(typeof(addthis_config)!="undefined"){stlib.data.set("result","addThis","shareInfo");if(typeof(addthis_config.data_track_textcopy)=="undefined"||addthis_config.data_track_textcopy){stlib.data.set("enabled","true","shareInfo");f=false}else{stlib.data.set("enabled","false","shareInfo")}stlib.logger.log("debug")}if(f){stlib.data.set("result","pass","shareInfo");stlib.logger.log("debug")}},false)}},logCopy:function(a,b){stlib.data.resetShareData();stlib.data.set("url",a,"shareInfo");stlib.data.setSource("copy");stlib.data.set("destination","copy","shareInfo");stlib.data.set("buttonType","custom","shareInfo");if(b){stlib.data.set("description",b,"shareInfo")}stlib.sharer.share()},selectionModify:function(p,n){p=""+p;_$d_();_$d1("Copy Paste");var o=/^((http|https):\/\/([a-z0-9!'\(\)\*\.\-\+:]*(\.)[a-z0-9!'\(\)\*\.\-\+:]*)((\/[a-z0-9!'\(\)\*\.\-\+:]*)*))/i;var i=/^([a-z0-9!'\(\)\*\.\-\+:]*(\.)[a-z0-9!'\(\)\*\.\-\+:]*)((\/[a-z0-9!'\(\)\*\.\-\+:]*)*)/i;var g=/^\+?1?[\.\-\\)_\s]?[\\(]?[0-9]{3}[\.\-\\)_\s]?[0-9]{3}[\.\-_\s]?[0-9]{4}$|^[0-9]{3}[\.\-_\s]?[0-9]{4}$/;var k=/^[0-9]{3}[\.\-_\s]?[0-9]{8}$/;var m=/^[0-9]{2}[\.\-_\s]?[0-9]{4}[\.\-_\s]?[0-9]{4}$/;var d=/[\-_\.a-z0-9]+@[\-_\.a-z0-9]+\.[\-_\.a-z0-9]+/i;var h=/[\s@]/;var b=document.location.href.split("#").shift();var j="#"+stlib.hash.shareHash;var a="";var l="";var f="";if(typeof(n)=="undefined"&&((o.test(p)||i.test(p))&&!h.test(p.trim()))){_$d2("is Url");if(p.match(/#/)==null||stlib.hash.validateHash(p)){l=p.split("#")[0]+j+".dpuf";f=l}else{l=p;f=l}}else{_$d2("is Not Url");if(document.location.hash==""||(/^#$/).test(document.location.hash)||stlib.hash.validateHash(document.location.hash)){l=b+j+".dpuf"}else{l=document.location.href}f=p;if(p.length>50){a=" - See more at: "+l+"";if(!g.test(p)&&!k.test(p)&&!m.test(p)&&!d.test(p)){f+=a}}}if(p.length>140){p=p.substring(0,137)+"..."}stlib.hash.logCopy(l,p);return((n&&n==true)?a:f)}};stlib.pump=function(a,d,f){var b=this;this.isIframeReady=false;this.isIframeSending=false;this.getHash=function(g){var h=g.split("#");h.shift();return h.join("#")};this.broadcastInit=function(g){this.destination=g;_$d_("---------------------");_$d1("Initiating broadcaster:");_$d(this.destination)};this.broadcastSendMessage=function(g){_$d_("---------------------");_$d1("Initiating Send:");if(this.destination===window){if(stlib.browser.ieFallback){window.location.replace(window.location.href.split("#")[0]+"#"+g);_$d2("child can't communicate with parent");return}_$d2("Iframe to publisher: "+g);parent.postMessage("#"+g,document.referrer)}else{_$d2("Publisher to Iframe: "+g);if(stlib.browser.ieFallback){if(this.destination.contentWindow){this.destination.contentWindow.location.replace(this.destination.src+"#"+g);this.isIframeSending=true}return}this.destination.contentWindow.postMessage("#"+g,this.destination.src)}};this.receiverInit=function(i,l){_$d_("---------------------");_$d1("Initiating Receiver:");_$d(i);if(stlib.browser.ieFallback){this.callback=l;this.source=i;if(i===window){window.location.replace(window.location.href.split("#")[0]+"#");this.currentIframe=window.location.hash;var h="receiver"+stlib.functionCount;stlib.functions[h]=function(n){if(""!=window.location.hash&&"#"!=window.location.hash){var m=window.location.hash;n(m);window.location.replace(window.location.href.split("#")[0]+"#")}};stlib.functionCount++;var k="callback"+stlib.functionCount;stlib.functions[k]=l;stlib.functionCount++;setInterval("stlib.functions['"+h+"'](stlib.functions['"+k+"'])",200)}else{}var j=window.addEventListener?"addEventListener":"attachEvent";var g=j=="attachEvent"?"onmessage":"message";window[j](g,function(m){if(i==window){}else{if(m.origin.indexOf("sharethis.com")!=-1){if(m.data.match(/#Pinterest Click/)){stlib.sharer.sharePinterest()}if(m.data.match(/#Print Click/)){stlib.sharer.stPrint()}}}},false);return}var j=window.addEventListener?"addEventListener":"attachEvent";var g=j=="attachEvent"?"onmessage":"message";window[j](g,function(m){if(i==window){_$d1("arrived in iframe from:");_$d(m.origin);if(m.data.match(/#fragmentPump/)||m.data.match(/#Buttons Ready/)||m.data.match(/#Widget Ready/)||m.data.indexOf("#light")==0||m.data.indexOf("#widget")==0||m.data.indexOf("#popup")==0||m.data.indexOf("#show")==0||m.data.indexOf("#init")==0||m.data.indexOf("#test")==0||m.data.indexOf("#data")==0){l(m.data)}}else{if(m.origin.indexOf("sharethis.com")!=-1){_$d1("arrived in parent from:");_$d(m.origin);if(m.data.match(/#fragmentPump/)||m.data.match(/#Buttons Ready/)||m.data.match(/#Widget Ready/)||m.data.indexOf("#light")==0||m.data.indexOf("#widget")==0||m.data.indexOf("#popup")==0||m.data.indexOf("#show")==0||m.data.indexOf("#init")==0||m.data.indexOf("#test")==0||m.data.indexOf("#data")==0){l(m.data)}else{if(m.data.match(/#Pinterest Click/)){stlib.sharer.sharePinterest()}else{if(m.data.match(/#Print Click/)){stlib.sharer.stPrint()}}}}else{_$d1("discarded event from:");_$d(m.origin)}}},false)};this.broadcastInit(a);this.receiverInit(d,f)};stlib.json={c:{"\b":"b","\t":"t","\n":"n","\f":"f","\r":"r",'"':'"',"\\":"\\","/":"/"},d:function(a){return a<10?"0".concat(a):a},e:function(c,f,e){e=eval;delete eval;if(typeof eval==="undefined"){eval=e}f=eval(""+c);eval=e;return f},i:function(d,b,a){return 1*d.substr(b,a)},p:["","000","00","0",""],rc:null,rd:/^[0-9]{4}\-[0-9]{2}\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$/,rs:/(\x5c|\x2F|\x22|[\x0c-\x0d]|[\x08-\x0a])/g,rt:/^([0-9]+|[0-9]+[,\.][0-9]{1,3})$/,ru:/([\x00-\x07]|\x0b|[\x0e-\x1f])/g,s:function(a,b){return"\\".concat(stlib.json.c[b])},u:function(a,b){var f=b.charCodeAt(0).toString(16);return"\\u".concat(stlib.json.p[f.length],f)},v:function(b,a){return stlib.json.types[typeof result](result)!==Function&&(a.hasOwnProperty?a.hasOwnProperty(b):a.constructor.prototype[b]!==a[b])},types:{"boolean":function(){return Boolean},"function":function(){return Function},number:function(){return Number},object:function(a){return a instanceof a.constructor?a.constructor:null},string:function(){return String},"undefined":function(){return null}},$$:function(a){function b(g,d){d=g[a];delete g[a];try{stlib.json.e(g)}catch(f){g[a]=d;return 1}}return b(Array)&&b(Object)},encode:function(){var d=arguments.length?arguments[0]:this,a,l;if(d===null){a="null"}else{if(d!==undefined&&(l=stlib.json.types[typeof d](d))){switch(l){case Array:a=[];for(var h=0,f=0,b=d.length;f<b;f++){if(d[f]!==undefined&&(l=stlib.json.encode(d[f]))){a[h++]=l}}a="[".concat(a.join(","),"]");break;case Boolean:a=String(d);break;case Date:a='"'.concat(d.getFullYear(),"-",stlib.json.d(d.getMonth()+1),"-",stlib.json.d(d.getDate()),"T",stlib.json.d(d.getHours()),":",stlib.json.d(d.getMinutes()),":",stlib.json.d(d.getSeconds()),'"');break;case Function:break;case Number:a=isFinite(d)?String(d):"null";break;case String:a='"'.concat(d.replace(stlib.json.rs,stlib.json.s).replace(stlib.json.ru,stlib.json.u),'"');break;default:var h=0,g;a=[];for(g in d){if(d[g]!==undefined&&(l=stlib.json.encode(d[g]))){a[h++]='"'.concat(g.replace(stlib.json.rs,stlib.json.s).replace(stlib.json.ru,stlib.json.u),'":',l)}}a="{".concat(a.join(","),"}");break}}}return a},decode:function(a){if(typeof(a)=="string"){var d=null;try{if(/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){d=window.JSON&&window.JSON.parse?window.JSON.parse(a):(new Function("return "+a))();return d}else{return null}}catch(b){}}}};try{stlib.json.rc=new RegExp('^("(\\\\.|[^"\\\\\\n\\r])*?"|[,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t])+?$')}catch(z){stlib.json.rc=/^(true|false|null|\[.*\]|\{.*\}|".*"|\d+|\d+\.\d+)$/}stlib.logger={loggerUrl:(("https:"==document.location.protocol)?"https://":"http://")+"l.sharethis.com/",l2LoggerUrl:(("https:"==document.location.protocol)?"https://":"http://")+"l2.sharethis.com/",productArray:new Array(),version:"",lang:"en",isFpEvent:false,constructParamString:function(){var a=stlib.data.pageInfo;var d="";var b;for(b in a){if(!stlib.logger.isFpEvent&&(b=="ufa"||b=="ufb"||b=="ufc"||b=="ufd")){continue}d+=b+"="+a[b]+"&"}a=stlib.data.shareInfo;for(b in a){d+=b+"="+a[b]+"&"}return d.substring(0,d.length-1)},log:function(a,k,m){if(a=="pview"||a=="share"||a=="onload"){stlib.logger.isFpEvent=true;if(stlib.stfp.screenResolutionDepthHash!="ERROR"){stlib.data.set("ufa",stlib.stfp.screenResolutionDepthHash,"pageInfo")}if(stlib.stfp.pluginsListHash!="ERROR"){stlib.data.set("ufb",stlib.stfp.pluginsListHash,"pageInfo")}if(stlib.stfp.fontsListHash!="ERROR"){stlib.data.set("ufc",stlib.stfp.fontsListHash,"pageInfo")}if(stlib.stfp.timezoneoffsetHash!="ERROR"){stlib.data.set("ufd",stlib.stfp.timezoneoffsetHash,"pageInfo")}}else{stlib.logger.isFpEvent=false}if(typeof(stlib.data.get("counter","shareInfo"))!="undefined"){var i=0;if(stlib.data.get("counter","shareInfo")){i=stlib.data.get("counter","shareInfo")}stlib.data.set("ts"+new Date().getTime()+"."+i,"","shareInfo");stlib.data.unset("counter","shareInfo")}else{stlib.data.set("ts"+new Date().getTime(),"","shareInfo")}if(a=="widget"){var l="."+stlib.hash.hashDestination(stlib.data.shareInfo.destination);stlib.hash.updateDestination(l)}if(!k||(k!=stlib.logger.loggerUrl&&k!=stlib.logger.l2LoggerUrl)){k=stlib.logger.loggerUrl}var b=(a=="pview"||a=="onload")?a:((a=="debug")?"cns":"log");if(a=="pview"||a=="onload"){var j=k+b+"?event="+a+"&test=pxexp&version="+stlib.logger.version+"&lang="+stlib.logger.lang+"&"+stlib.logger.constructParamString()}else{if(a=="error"){var j=k+"pview?event=pview&test=error&version="+stlib.logger.version+"&lang="+stlib.logger.lang+"&"+stlib.logger.constructParamString()}else{var j=k+b+"?event="+a+"&"+stlib.logger.constructParamString()}}if(a=="pview"){var f=k+"onscript?event=onscript&test=pxexp&version="+stlib.logger.version+"&lang="+stlib.logger.lang+"&"+stlib.logger.constructParamString();var h=new Image(1,1);h.src=f;h.onload=function(){return};m?m():null}try{var d=new XMLHttpRequest();d.open("GET",j,true);d.withCredentials=true;d.onreadystatechange=function(){if(this.readyState==this.HEADERS_RECEIVED){var n=d.getResponseHeader("stid");stlib.data.set("stid",n,"pageInfo");m?m():null}};d.send()}catch(g){var h=new Image(1,1);h.src=j;h.onload=function(){return};m?m():null}}};stlib.logger.version="buttons.js";var customProduct="widget";if(typeof(stLight)=="undefined"&&typeof(SHARETHIS)=="undefined"){var stWidgetVersion=false;if(typeof(switchTo5x)=="undefined"){stWidgetVersion="4x"}else{if(switchTo5x==false){stWidgetVersion="4x"}if(switchTo5x==true){stWidgetVersion="5xa"}}stLight=new function(){this.version=false;this.publisher=null;this.sessionID_time=(new Date()).getTime().toString();this.sessionID_rand=Number(Math.random().toPrecision(5).toString().substr(2)).toString();this.sessionID=this.sessionID_time+"."+this.sessionID_rand;this.fpc=null;this.counter=0;this.readyRun=false;this.meta={hostname:document.location.host,location:document.location.pathname};this.loadedFromBar=false;this.clickCallBack=false};stLight.loadDefault=function(){if(typeof(customProduct)=="undefined"){this.product="DOS2"}else{this.product=customProduct}this.source="DOS2";this.version="st_insights.js"};stLight.options=function(a){this.loadDefault();if(a&&a.publisher){stLight.setPublisher(a.publisher)}if(a&&a.refDomain){stLight.setRefDomain(a.refDomain)}stlib.logger.productArray=[];if(a&&a.product){stLight.setProduct(a.product)}else{stLight.setProduct(stLight.product)}if(a&&typeof(a.hashAddressBar)!="undefined"){stlib.hash.hashAddressBar=a.hashAddressBar}if(a&&typeof(a.doNotHash)!="undefined"){stlib.hash.doNotHash=a.doNotHash}if(a&&typeof(a.doNotCopy)!="undefined"){stlib.hash.doNotCopy=a.doNotCopy}stlib.stLightOptionsObj=a};stLight.onReady=function(){if(stLight.readyRun==true){return false}stLight.loadFromScript();stLight.readyRun=true;stlib.data.init();stlib.stfp.init();stLight.fpc=stlib.data.get("fpc","pageInfo");if(stLight.publisher==null){if(typeof(window.console)!=="undefined"){try{console.debug("Please specify a ShareThis Publisher Key \nFor help, contact support@sharethis.com")}catch(a){}}}stLight.setProduct(stLight.product);stlib.logger.lang="en";stLight.log("onload")};stLight.log=function(a){stlib.data.resetShareData();stlib.data.setSource(stLight.getSource());stlib.data.set("url",document.location.href,"shareInfo");stlib.data.set("title",document.title,"shareInfo");stlib.data.set("counter",stLight.counter++,"shareInfo");stlib.logger.log(a)};if(window.document.readyState=="completed"){stLight.onReady()}else{if(typeof(window.addEventListener)!="undefined"){window.addEventListener("load",stLight.onReady,false)}else{if(typeof(document.addEventListener)!="undefined"){document.addEventListener("load",stLight.onReady,false)}else{if(typeof window.attachEvent!="undefined"){window.attachEvent("onload",stLight.onReady)}}}}stLight.setPublisher=function(a){stlib.data.setPublisher(a);stLight.publisher=a};stLight.setRefDomain=function(a){stlib.data.setRefDomain(a)};stLight.setProduct=function(a){this.product=a;stlib.data.set("product",a,"pageInfo")};stLight.getProduct=function(){return this.product};stLight.getSource=function(){var a="share4x";if(stWidgetVersion=="5xa"){a="share5x"}return a}}stLight.getUrlSearchParam=function(){var a=window.location.search.substring(1);return a.split("&")};stLight.getUrlQueryParams=function(a){var d={};var b=a.replace(/[?&]+([^=&]+)=([^&]*)/gi,function(f,g,h){d[g]=h});return d};stLight.getScriptSrcParams=function(b){var a=document.getElementById(b);if(a){return stLight.getUrlQueryParams(a.src)}};stLight.setParams=function(a){if(a){if(a.refdomain){stLight.setRefDomain(a.refdomain)}if(a.publisher){stLight.setPublisher(a.publisher)}if(a.product){stLight.setProduct(a.product)}}};stLight.loadFromScript=function(){var a=stLight.getScriptSrcParams("st_insights_js");stLight.setParams(a)};stLight.loadFromWindowLocation=function(){var a=stLight.getUrlSearchParam();stLight.setParams(a)};stLight.onDomContentLoaded=function(){stLight.onReady()};stLight.domReady=function(){stLight.onReady()};st_showing=false;stLight.clickSubscribers=[];stLight.nonClickSubscribers=[];if(window.document.readyState=="completed"){stLight.domReady()}else{if(typeof(window.addEventListener)!="undefined"){window.addEventListener("load",stLight.domReady,false)}else{if(typeof(document.addEventListener)!="undefined"){document.addEventListener("load",stLight.domReady,false)}else{if(typeof window.attachEvent!="undefined"){window.attachEvent("onload",stLight.domReady)}}}}if(typeof(__st_loadLate)=="undefined"){if(typeof(window.addEventListener)!="undefined"){window.addEventListener("DOMContentLoaded",stLight.onDomContentLoaded,false)}else{if(typeof(document.addEventListener)!="undefined"){document.addEventListener("DOMContentLoaded",stLight.onDomContentLoaded,false)}}}else{if(typeof(window.addEventListener)!="undefined"){window.addEventListener("DOMContentLoaded",stLight.onDomContentLoadedLazy,false)}else{if(typeof(document.addEventListener)!="undefined"){document.addEventListener("DOMContentLoaded",stLight.onDomContentLoadedLazy,false)}}}if(document.readyState=="complete"&&stLight.readyRun==false){stLight.domReady()}var stButtons=stButtons||{};stButtons.getCount=function(d,a,f){var b=false;if(f&&f!==null){while(f.childNodes.length>=1){try{f.removeChild(f.firstChild)}catch(g){}}}document.addEventListener("on_async_buttons_load",function(){stButtons=async_buttons.stButtons;stButtons.cbQueue.push({url:d,service:a,element:f});stButtons.getCountsFromService(d,a,f)},false)};var stWidget=stWidget||{};if(typeof(stWidget.readyRun)=="undefined"){stWidget.addEntry=function(a){document.addEventListener("on_async_buttons_load",function(){stWidget=async_buttons.stWidget;stWidget.addEntry(a)},false)}}stLight.subscribe=function(b,a){document.addEventListener("on_async_buttons_load",function(){stButtonsLib.subscribe(b,a)},false)};if(!stlib.onscriptload&&document.URL.indexOf("edge.sharethis.com")==-1){try{stlib.data.init();stlib.onscriptload=true;var product=stlib.data.get("product","pageInfo");if(stlib.logger.version=="buttons.js"||product=="simpleshare"){stlib.logger.log("pview",null,function(){stlib.pixels.createSegmentFrame(product)})}else{stlib.logger.log("pview")}}catch(e){stlib.logger.log("error")}}stlib.scriptLoader={loadJavascript:function(b,d){_$d_();_$d1("Loading JS: "+b);var a=stlib.scriptLoader;a.head=document.getElementsByTagName("head")[0];a.scriptSrc=b;a.script=document.createElement("script");a.script.setAttribute("type","text/javascript");a.script.setAttribute("src",a.scriptSrc);a.script.async=true;if(window.attachEvent&&document.all){a.script.onreadystatechange=function(){if(this.readyState=="complete"||this.readyState=="loaded"){d()}}}else{a.script.onload=d}a.s=document.getElementsByTagName("script")[0];a.s.parentNode.insertBefore(a.script,a.s)},loadCSS:function(b,f){_$d_();_$d1("Loading CSS: "+b);var a=stlib.scriptLoader;var d;a.head=document.getElementsByTagName("head")[0];a.cssSrc=b;a.css=document.createElement("link");a.css.setAttribute("rel","stylesheet");a.css.setAttribute("type","text/css");a.css.setAttribute("href",b);a.css.setAttribute("id",b);setTimeout(function(){f();if(!document.getElementById(b)){d=setInterval(function(){if(document.getElementById(b)){clearInterval(d);f()}},100)}},100);a.head.appendChild(a.css)}};

/**
 * Swiper 3.4.0
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * 
 * http://www.idangero.us/swiper/
 * 
 * Copyright 2016, Vladimir Kharlampidi
 * The iDangero.us
 * http://www.idangero.us/
 * 
 * Licensed under MIT
 * 
 * Released on: October 16, 2016
 */
(function () {
    'use strict';
    var $;
    /*===========================
    Swiper
    ===========================*/
    var Swiper = function (container, params) {
        if (!(this instanceof Swiper)) return new Swiper(container, params);

        var defaults = {
            direction: 'horizontal',
            touchEventsTarget: 'container',
            initialSlide: 0,
            speed: 300,
            // autoplay
            autoplay: false,
            autoplayDisableOnInteraction: true,
            autoplayStopOnLast: false,
            // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
            iOSEdgeSwipeDetection: false,
            iOSEdgeSwipeThreshold: 20,
            // Free mode
            freeMode: false,
            freeModeMomentum: true,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: true,
            freeModeMomentumBounceRatio: 1,
            freeModeMomentumVelocityRatio: 1,
            freeModeSticky: false,
            freeModeMinimumVelocity: 0.02,
            // Autoheight
            autoHeight: false,
            // Set wrapper width
            setWrapperSize: false,
            // Virtual Translate
            virtualTranslate: false,
            // Effects
            effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
            coverflow: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows : true
            },
            flip: {
                slideShadows : true,
                limitRotation: true
            },
            cube: {
                slideShadows: true,
                shadow: true,
                shadowOffset: 20,
                shadowScale: 0.94
            },
            fade: {
                crossFade: false
            },
            // Parallax
            parallax: false,
            // Zoom
            zoom: false,
            zoomMax: 3,
            zoomMin: 1,
            zoomToggle: true,
            // Scrollbar
            scrollbar: null,
            scrollbarHide: true,
            scrollbarDraggable: false,
            scrollbarSnapOnRelease: false,
            // Keyboard Mousewheel
            keyboardControl: true,
            mousewheelControl: true,
            mousewheelReleaseOnEdges: false,
            mousewheelInvert: false,
            mousewheelForceToAxis: false,
            mousewheelSensitivity: 1,
            mousewheelEventsTarged: 'container',
            // Hash Navigation
            hashnav: false,
            hashnavWatchState: false,
            // History
            history: false,
            // Commong Nav State
            replaceState: false,
            // Breakpoints
            breakpoints:  { 1024:   { slidesPerView: 4 },
                            768:    { slidesPerView: 3 },
                            640:    { slidesPerView: 2 }
                          },
            // Slides grid
            spaceBetween: 0,
            slidesPerView: 4,
            slidesPerColumn: 1,
            slidesPerColumnFill: 'column',
            slidesPerGroup: 1,
            centeredSlides: false,
            slidesOffsetBefore: 0, // in px
            slidesOffsetAfter: 0, // in px
            // Round length
            roundLengths: false,
            // Touches
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: 0.5,
            longSwipesMs: 300,
            followFinger: true,
            onlyExternal: false,
            threshold: 0,
            touchMoveStopPropagation: true,
            touchReleaseOnEdges: false,
            // Unique Navigation Elements
            uniqueNavElements: true,
            // Pagination
            pagination: '.swiper-pagination',
            paginationElement: 'span',
            paginationClickable: true,
            paginationHide: false,
            paginationBulletRender: null,
            paginationProgressRender: null,
            paginationFractionRender: null,
            paginationCustomRender: null,
            paginationType: 'bullets', // 'bullets' or 'progress' or 'fraction' or 'custom'
            // Resistance
            resistance: true,
            resistanceRatio: 0.85,
            // Next/prev buttons
            nextButton: '.swiper-button-next',
            prevButton: '.swiper-button-next',
            // Progress
            watchSlidesProgress: false,
            watchSlidesVisibility: false,
            // Cursor
            grabCursor: false,
            // Clicks
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            // Lazy Loading
            lazyLoading: false,
            lazyLoadingInPrevNext: false,
            lazyLoadingInPrevNextAmount: 1,
            lazyLoadingOnTransitionStart: false,
            // Images
            preloadImages: true,
            updateOnImagesReady: true,
            // loop
            loop: true,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            // Control
            control: undefined,
            controlInverse: false,
            controlBy: 'slide', //or 'container'
            normalizeSlideIndex: true,
            // Swiping/no swiping
            allowSwipeToPrev: true,
            allowSwipeToNext: true,
            swipeHandler: null, //'.swipe-handler',
            noSwiping: true,
            noSwipingClass: 'swiper-no-swiping',
            // Passive Listeners
            passiveListeners: true,
            // NS
            containerModifierClass: 'swiper-container-', // NEW
            slideClass: 'swiper-slide',
            slideActiveClass: 'swiper-slide-active',
            slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
            slideVisibleClass: 'swiper-slide-visible',
            slideDuplicateClass: 'swiper-slide-duplicate',
            slideNextClass: 'swiper-slide-next',
            slideDuplicateNextClass: 'swiper-slide-duplicate-next',
            slidePrevClass: 'swiper-slide-prev',
            slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
            wrapperClass: 'swiper-wrapper',
            bulletClass: 'swiper-pagination-bullet',
            bulletActiveClass: 'swiper-pagination-bullet-active',
            buttonDisabledClass: 'swiper-button-disabled',
            paginationCurrentClass: 'swiper-pagination-current',
            paginationTotalClass: 'swiper-pagination-total',
            paginationHiddenClass: 'swiper-pagination-hidden',
            paginationProgressbarClass: 'swiper-pagination-progressbar',
            paginationClickableClass: 'swiper-pagination-clickable', // NEW
            paginationModifierClass: 'swiper-pagination-', // NEW
            lazyLoadingClass: 'swiper-lazy',
            lazyStatusLoadingClass: 'swiper-lazy-loading',
            lazyStatusLoadedClass: 'swiper-lazy-loaded',
            lazyPreloaderClass: 'swiper-lazy-preloader',
            notificationClass: 'swiper-notification',
            preloaderClass: 'preloader',
            zoomContainerClass: 'swiper-zoom-container',
        
            // Observer
            observer: false,
            observeParents: false,
            // Accessibility
            a11y: false,
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
            paginationBulletMessage: 'Go to slide {{index}}',
            // Callbacks
            runCallbacksOnInit: true
            /*
            Callbacks:
            onInit: function (swiper)
            onDestroy: function (swiper)
            onClick: function (swiper, e)
            onTap: function (swiper, e)
            onDoubleTap: function (swiper, e)
            onSliderMove: function (swiper, e)
            onSlideChangeStart: function (swiper)
            onSlideChangeEnd: function (swiper)
            onTransitionStart: function (swiper)
            onTransitionEnd: function (swiper)
            onImagesReady: function (swiper)
            onProgress: function (swiper, progress)
            onTouchStart: function (swiper, e)
            onTouchMove: function (swiper, e)
            onTouchMoveOpposite: function (swiper, e)
            onTouchEnd: function (swiper, e)
            onReachBeginning: function (swiper)
            onReachEnd: function (swiper)
            onSetTransition: function (swiper, duration)
            onSetTranslate: function (swiper, translate)
            onAutoplayStart: function (swiper)
            onAutoplayStop: function (swiper),
            onLazyImageLoad: function (swiper, slide, image)
            onLazyImageReady: function (swiper, slide, image)
            */
        
        };
        var initialVirtualTranslate = params && params.virtualTranslate;
        
        params = params || {};
        var originalParams = {};
        for (var param in params) {
            if (typeof params[param] === 'object' && params[param] !== null && !(params[param].nodeType || params[param] === window || params[param] === document || (typeof Dom7 !== 'undefined' && params[param] instanceof Dom7) || (typeof jQuery !== 'undefined' && params[param] instanceof jQuery))) {
                originalParams[param] = {};
                for (var deepParam in params[param]) {
                    originalParams[param][deepParam] = params[param][deepParam];
                }
            }
            else {
                originalParams[param] = params[param];
            }
        }
        for (var def in defaults) {
            if (typeof params[def] === 'undefined') {
                params[def] = defaults[def];
            }
            else if (typeof params[def] === 'object') {
                for (var deepDef in defaults[def]) {
                    if (typeof params[def][deepDef] === 'undefined') {
                        params[def][deepDef] = defaults[def][deepDef];
                    }
                }
            }
        }
        
        // Swiper
        var s = this;
        
        // Params
        s.params = params;
        s.originalParams = originalParams;
        
        // Classname
        s.classNames = [];
        /*=========================
          Dom Library and plugins
          ===========================*/
        if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined'){
            $ = Dom7;
        }
        if (typeof $ === 'undefined') {
            if (typeof Dom7 === 'undefined') {
                $ = window.Dom7 || window.Zepto || window.jQuery;
            }
            else {
                $ = Dom7;
            }
            if (!$) return;
        }
        // Export it to Swiper instance
        s.$ = $;
        
        /*=========================
          Breakpoints
          ===========================*/
        s.currentBreakpoint = undefined;
        s.getActiveBreakpoint = function () {
            //Get breakpoint for window width
            if (!s.params.breakpoints) return false;
            var breakpoint = false;
            var points = [], point;
            for ( point in s.params.breakpoints ) {
                if (s.params.breakpoints.hasOwnProperty(point)) {
                    points.push(point);
                }
            }
            points.sort(function (a, b) {
                return parseInt(a, 10) > parseInt(b, 10);
            });
            for (var i = 0; i < points.length; i++) {
                point = points[i];
                if (point >= window.innerWidth && !breakpoint) {
                    breakpoint = point;
                }
            }
            return breakpoint || 'max';
        };
        s.setBreakpoint = function () {
            //Set breakpoint for window width and update parameters
            var breakpoint = s.getActiveBreakpoint();
            if (breakpoint && s.currentBreakpoint !== breakpoint) {
                var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
                var needsReLoop = s.params.loop && (breakPointsParams.slidesPerView !== s.params.slidesPerView);
                for ( var param in breakPointsParams ) {
                    s.params[param] = breakPointsParams[param];
                }
                s.currentBreakpoint = breakpoint;
                if(needsReLoop && s.destroyLoop) {
                    s.reLoop(true);
                }
            }
        };
        // Set breakpoint on load
        if (s.params.breakpoints) {
            s.setBreakpoint();
        }
        
        /*=========================
          Preparation - Define Container, Wrapper and Pagination
          ===========================*/
        s.container = $(container);
        if (s.container.length === 0) return;
        if (s.container.length > 1) {
            var swipers = [];
            s.container.each(function () {
                var container = this;
                swipers.push(new Swiper(this, params));
            });
            return swipers;
        }
        
        // Save instance in container HTML Element and in data
        s.container[0].swiper = s;
        s.container.data('swiper', s);
        
        s.classNames.push(s.params.containerModifierClass + s.params.direction);
        
        if (s.params.freeMode) {
            s.classNames.push(s.params.containerModifierClass + 'free-mode');
        }
        if (!s.support.flexbox) {
            s.classNames.push(s.params.containerModifierClass + 'no-flexbox');
            s.params.slidesPerColumn = 1;
        }
        if (s.params.autoHeight) {
            s.classNames.push(s.params.containerModifierClass + 'autoheight');
        }
        // Enable slides progress when required
        if (s.params.parallax || s.params.watchSlidesVisibility) {
            s.params.watchSlidesProgress = true;
        }
        // Max resistance when touchReleaseOnEdges
        if (s.params.touchReleaseOnEdges) {
            s.params.resistanceRatio = 0;
        }
        // Coverflow / 3D
        if (['cube', 'coverflow', 'flip'].indexOf(s.params.effect) >= 0) {
            if (s.support.transforms3d) {
                s.params.watchSlidesProgress = true;
                s.classNames.push(s.params.containerModifierClass + '3d');
            }
            else {
                s.params.effect = 'slide';
            }
        }
        if (s.params.effect !== 'slide') {
            s.classNames.push(s.params.containerModifierClass + s.params.effect);
        }
        if (s.params.effect === 'cube') {
            s.params.resistanceRatio = 0;
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.centeredSlides = false;
            s.params.spaceBetween = 0;
            s.params.virtualTranslate = true;
            s.params.setWrapperSize = false;
        }
        if (s.params.effect === 'fade' || s.params.effect === 'flip') {
            s.params.slidesPerView = 1;
            s.params.slidesPerColumn = 1;
            s.params.slidesPerGroup = 1;
            s.params.watchSlidesProgress = true;
            s.params.spaceBetween = 0;
            s.params.setWrapperSize = false;
            if (typeof initialVirtualTranslate === 'undefined') {
                s.params.virtualTranslate = true;
            }
        }
        
        // Grab Cursor
        if (s.params.grabCursor && s.support.touch) {
            s.params.grabCursor = false;
        }
        
        // Wrapper
        s.wrapper = s.container.children('.' + s.params.wrapperClass);
        
        // Pagination
        if (s.params.pagination) {
            s.paginationContainer = $(s.params.pagination);
            if (s.params.uniqueNavElements && typeof s.params.pagination === 'string' && s.paginationContainer.length > 1 && s.container.find(s.params.pagination).length === 1) {
                s.paginationContainer = s.container.find(s.params.pagination);
            }
        
            if (s.params.paginationType === 'bullets' && s.params.paginationClickable) {
                s.paginationContainer.addClass(s.params.paginationModifierClass + 'clickable');
            }
            else {
                s.params.paginationClickable = false;
            }
            s.paginationContainer.addClass(s.params.paginationModifierClass + s.params.paginationType);
        }
        // Next/Prev Buttons
        if (s.params.nextButton || s.params.prevButton) {
            if (s.params.nextButton) {
                s.nextButton = $(s.params.nextButton);
                if (s.params.uniqueNavElements && typeof s.params.nextButton === 'string' && s.nextButton.length > 1 && s.container.find(s.params.nextButton).length === 1) {
                    s.nextButton = s.container.find(s.params.nextButton);
                }
            }
            if (s.params.prevButton) {
                s.prevButton = $(s.params.prevButton);
                if (s.params.uniqueNavElements && typeof s.params.prevButton === 'string' && s.prevButton.length > 1 && s.container.find(s.params.prevButton).length === 1) {
                    s.prevButton = s.container.find(s.params.prevButton);
                }
            }
        }
        
        // Is Horizontal
        s.isHorizontal = function () {
            return s.params.direction === 'horizontal';
        };
        // s.isH = isH;
        
        // RTL
        s.rtl = s.isHorizontal() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
        if (s.rtl) {
            s.classNames.push(s.params.containerModifierClass + 'rtl');
        }
        
        // Wrong RTL support
        if (s.rtl) {
            s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
        }
        
        // Columns
        if (s.params.slidesPerColumn > 1) {
            s.classNames.push(s.params.containerModifierClass + 'multirow');
        }
        
        // Check for Android
        if (s.device.android) {
            s.classNames.push(s.params.containerModifierClass + 'android');
        }
        
        // Add classes
        s.container.addClass(s.classNames.join(' '));
        
        // Translate
        s.translate = 0;
        
        // Progress
        s.progress = 0;
        
        // Velocity
        s.velocity = 0;
        
        /*=========================
          Locks, unlocks
          ===========================*/
        s.lockSwipeToNext = function () {
            s.params.allowSwipeToNext = false;
            if (s.params.allowSwipeToPrev === false && s.params.grabCursor) {
                s.unsetGrabCursor();
            }
        };
        s.lockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = false;
            if (s.params.allowSwipeToNext === false && s.params.grabCursor) {
                s.unsetGrabCursor();
            }
        };
        s.lockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
            if (s.params.grabCursor) s.unsetGrabCursor();
        };
        s.unlockSwipeToNext = function () {
            s.params.allowSwipeToNext = true;
            if (s.params.allowSwipeToPrev === true && s.params.grabCursor) {
                s.setGrabCursor();
            }
        };
        s.unlockSwipeToPrev = function () {
            s.params.allowSwipeToPrev = true;
            if (s.params.allowSwipeToNext === true && s.params.grabCursor) {
                s.setGrabCursor();
            }
        };
        s.unlockSwipes = function () {
            s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
            if (s.params.grabCursor) s.setGrabCursor();
        };
        
        /*=========================
          Round helper
          ===========================*/
        function round(a) {
            return Math.floor(a);
        }
        /*=========================
          Set grab cursor
          ===========================*/
        s.setGrabCursor = function(moving) {
            s.container[0].style.cursor = 'move';
            s.container[0].style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
            s.container[0].style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
            s.container[0].style.cursor = moving ? 'grabbing': 'grab';
        };
        s.unsetGrabCursor = function () {
            s.container[0].style.cursor = '';
        };
        if (s.params.grabCursor) {
            s.setGrabCursor();
        }
        /*=========================
          Update on Images Ready
          ===========================*/
        s.imagesToLoad = [];
        s.imagesLoaded = 0;
        
        s.loadImage = function (imgElement, src, srcset, sizes, checkForComplete, callback) {
            var image;
            function onReady () {
                if (callback) callback();
            }
            if (!imgElement.complete || !checkForComplete) {
                if (src) {
                    image = new window.Image();
                    image.onload = onReady;
                    image.onerror = onReady;
                    if (sizes) {
                        image.sizes = sizes;
                    }
                    if (srcset) {
                        image.srcset = srcset;
                    }
                    if (src) {
                        image.src = src;
                    }
                } else {
                    onReady();
                }
        
            } else {//image already loaded...
                onReady();
            }
        };
        s.preloadImages = function () {
            s.imagesToLoad = s.container.find('img');
            function _onReady() {
                if (typeof s === 'undefined' || s === null) return;
                if (s.imagesLoaded !== undefined) s.imagesLoaded++;
                if (s.imagesLoaded === s.imagesToLoad.length) {
                    if (s.params.updateOnImagesReady) s.update();
                    s.emit('onImagesReady', s);
                }
            }
            for (var i = 0; i < s.imagesToLoad.length; i++) {
                s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), (s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset')), s.imagesToLoad[i].sizes || s.imagesToLoad[i].getAttribute('sizes'), true, _onReady);
            }
        };
        
        /*=========================
          Autoplay
          ===========================*/
        s.autoplayTimeoutId = undefined;
        s.autoplaying = false;
        s.autoplayPaused = false;
        function autoplay() {
            var autoplayDelay = s.params.autoplay;
            var activeSlide = s.slides.eq(s.activeIndex);
            if (activeSlide.attr('data-swiper-autoplay')) {
                autoplayDelay = activeSlide.attr('data-swiper-autoplay') || s.params.autoplay;
            }
            s.autoplayTimeoutId = setTimeout(function () {
                if (s.params.loop) {
                    s.fixLoop();
                    s._slideNext();
                    s.emit('onAutoplay', s);
                }
                else {
                    if (!s.isEnd) {
                        s._slideNext();
                        s.emit('onAutoplay', s);
                    }
                    else {
                        if (!params.autoplayStopOnLast) {
                            s._slideTo(0);
                            s.emit('onAutoplay', s);
                        }
                        else {
                            s.stopAutoplay();
                        }
                    }
                }
            }, autoplayDelay);
        }
        s.startAutoplay = function () {
            if (typeof s.autoplayTimeoutId !== 'undefined') return false;
            if (!s.params.autoplay) return false;
            if (s.autoplaying) return false;
            s.autoplaying = true;
            s.emit('onAutoplayStart', s);
            autoplay();
        };
        s.stopAutoplay = function (internal) {
            if (!s.autoplayTimeoutId) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplaying = false;
            s.autoplayTimeoutId = undefined;
            s.emit('onAutoplayStop', s);
        };
        s.pauseAutoplay = function (speed) {
            if (s.autoplayPaused) return;
            if (s.autoplayTimeoutId) clearTimeout(s.autoplayTimeoutId);
            s.autoplayPaused = true;
            if (speed === 0) {
                s.autoplayPaused = false;
                autoplay();
            }
            else {
                s.wrapper.transitionEnd(function () {
                    if (!s) return;
                    s.autoplayPaused = false;
                    if (!s.autoplaying) {
                        s.stopAutoplay();
                    }
                    else {
                        autoplay();
                    }
                });
            }
        };
        /*=========================
          Min/Max Translate
          ===========================*/
        s.minTranslate = function () {
            return (-s.snapGrid[0]);
        };
        s.maxTranslate = function () {
            return (-s.snapGrid[s.snapGrid.length - 1]);
        };
        /*=========================
          Slider/slides sizes
          ===========================*/
        s.updateAutoHeight = function () {
            var activeSlides = [];
            var newHeight = 0;
        
            // Find slides currently in view
            if(s.params.slidesPerView !== 'auto' && s.params.slidesPerView > 1) {
                for (i = 0; i < Math.ceil(s.params.slidesPerView); i++) {
                    var index = s.activeIndex + i;
                    if(index > s.slides.length) break;
                    activeSlides.push(s.slides.eq(index)[0]);
                }
            } else {
                activeSlides.push(s.slides.eq(s.activeIndex)[0]);
            }
        
            // Find new height from heighest slide in view
            for (i = 0; i < activeSlides.length; i++) {
                if (typeof activeSlides[i] !== 'undefined') {
                    var height = activeSlides[i].offsetHeight;
                    newHeight = height > newHeight ? height : newHeight;
                }
            }
        
            // Update Height
            if (newHeight) s.wrapper.css('height', newHeight + 'px');
        };
        s.updateContainerSize = function () {
            var width, height;
            if (typeof s.params.width !== 'undefined') {
                width = s.params.width;
            }
            else {
                width = s.container[0].clientWidth;
            }
            if (typeof s.params.height !== 'undefined') {
                height = s.params.height;
            }
            else {
                height = s.container[0].clientHeight;
            }
            if (width === 0 && s.isHorizontal() || height === 0 && !s.isHorizontal()) {
                return;
            }
        
            //Subtract paddings
            width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
            height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
        
            // Store values
            s.width = width;
            s.height = height;
            s.size = s.isHorizontal() ? s.width : s.height;
        };
        
        s.updateSlidesSize = function () {
            s.slides = s.wrapper.children('.' + s.params.slideClass);
            s.snapGrid = [];
            s.slidesGrid = [];
            s.slidesSizesGrid = [];
        
            var spaceBetween = s.params.spaceBetween,
                slidePosition = -s.params.slidesOffsetBefore,
                i,
                prevSlideSize = 0,
                index = 0;
            if (typeof s.size === 'undefined') return;
            if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
                spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
            }
        
            s.virtualSize = -spaceBetween;
            // reset margins
            if (s.rtl) s.slides.css({marginLeft: '', marginTop: ''});
            else s.slides.css({marginRight: '', marginBottom: ''});
        
            var slidesNumberEvenToRows;
            if (s.params.slidesPerColumn > 1) {
                if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
                    slidesNumberEvenToRows = s.slides.length;
                }
                else {
                    slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
                }
                if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
                    slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
                }
            }
        
            // Calc slides
            var slideSize;
            var slidesPerColumn = s.params.slidesPerColumn;
            var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
            var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
            for (i = 0; i < s.slides.length; i++) {
                slideSize = 0;
                var slide = s.slides.eq(i);
                if (s.params.slidesPerColumn > 1) {
                    // Set slides order
                    var newSlideOrderIndex;
                    var column, row;
                    if (s.params.slidesPerColumnFill === 'column') {
                        column = Math.floor(i / slidesPerColumn);
                        row = i - column * slidesPerColumn;
                        if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn-1)) {
                            if (++row >= slidesPerColumn) {
                                row = 0;
                                column++;
                            }
                        }
                        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                        slide
                            .css({
                                '-webkit-box-ordinal-group': newSlideOrderIndex,
                                '-moz-box-ordinal-group': newSlideOrderIndex,
                                '-ms-flex-order': newSlideOrderIndex,
                                '-webkit-order': newSlideOrderIndex,
                                'order': newSlideOrderIndex
                            });
                    }
                    else {
                        row = Math.floor(i / slidesPerRow);
                        column = i - row * slidesPerRow;
                    }
                    slide
                        .css(
                            'margin-' + (s.isHorizontal() ? 'top' : 'left'),
                            (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')
                        )
                        .attr('data-swiper-column', column)
                        .attr('data-swiper-row', row);
        
                }
                if (slide.css('display') === 'none') continue;
                if (s.params.slidesPerView === 'auto') {
                    slideSize = s.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
                    if (s.params.roundLengths) slideSize = round(slideSize);
                }
                else {
                    slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
                    if (s.params.roundLengths) slideSize = round(slideSize);
        
                    if (s.isHorizontal()) {
                        s.slides[i].style.width = slideSize + 'px';
                    }
                    else {
                        s.slides[i].style.height = slideSize + 'px';
                    }
                }
                s.slides[i].swiperSlideSize = slideSize;
                s.slidesSizesGrid.push(slideSize);
        
        
                if (s.params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (i === 0) slidePosition = slidePosition - s.size / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                    if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                }
                else {
                    if ((index) % s.params.slidesPerGroup === 0) s.snapGrid.push(slidePosition);
                    s.slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
        
                s.virtualSize += slideSize + spaceBetween;
        
                prevSlideSize = slideSize;
        
                index ++;
            }
            s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
            var newSlidesGrid;
        
            if (
                s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
                s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
            }
            if (!s.support.flexbox || s.params.setWrapperSize) {
                if (s.isHorizontal()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
                else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
            }
        
            if (s.params.slidesPerColumn > 1) {
                s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
                s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
                if (s.isHorizontal()) s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
                else s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
                if (s.params.centeredSlides) {
                    newSlidesGrid = [];
                    for (i = 0; i < s.snapGrid.length; i++) {
                        if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0]) newSlidesGrid.push(s.snapGrid[i]);
                    }
                    s.snapGrid = newSlidesGrid;
                }
            }
        
            // Remove last grid elements depending on width
            if (!s.params.centeredSlides) {
                newSlidesGrid = [];
                for (i = 0; i < s.snapGrid.length; i++) {
                    if (s.snapGrid[i] <= s.virtualSize - s.size) {
                        newSlidesGrid.push(s.snapGrid[i]);
                    }
                }
                s.snapGrid = newSlidesGrid;
                if (Math.floor(s.virtualSize - s.size) - Math.floor(s.snapGrid[s.snapGrid.length - 1]) > 1) {
                    s.snapGrid.push(s.virtualSize - s.size);
                }
            }
            if (s.snapGrid.length === 0) s.snapGrid = [0];
        
            if (s.params.spaceBetween !== 0) {
                if (s.isHorizontal()) {
                    if (s.rtl) s.slides.css({marginLeft: spaceBetween + 'px'});
                    else s.slides.css({marginRight: spaceBetween + 'px'});
                }
                else s.slides.css({marginBottom: spaceBetween + 'px'});
            }
            if (s.params.watchSlidesProgress) {
                s.updateSlidesOffset();
            }
        };
        s.updateSlidesOffset = function () {
            for (var i = 0; i < s.slides.length; i++) {
                s.slides[i].swiperSlideOffset = s.isHorizontal() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
            }
        };
        
        /*=========================
          Slider/slides progress
          ===========================*/
        s.updateSlidesProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            if (s.slides.length === 0) return;
            if (typeof s.slides[0].swiperSlideOffset === 'undefined') s.updateSlidesOffset();
        
            var offsetCenter = -translate;
            if (s.rtl) offsetCenter = translate;
        
            // Visible Slides
            s.slides.removeClass(s.params.slideVisibleClass);
            for (var i = 0; i < s.slides.length; i++) {
                var slide = s.slides[i];
                var slideProgress = (offsetCenter + (s.params.centeredSlides ? s.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
                if (s.params.watchSlidesVisibility) {
                    var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
                    var slideAfter = slideBefore + s.slidesSizesGrid[i];
                    var isVisible =
                        (slideBefore >= 0 && slideBefore < s.size) ||
                        (slideAfter > 0 && slideAfter <= s.size) ||
                        (slideBefore <= 0 && slideAfter >= s.size);
                    if (isVisible) {
                        s.slides.eq(i).addClass(s.params.slideVisibleClass);
                    }
                }
                slide.progress = s.rtl ? -slideProgress : slideProgress;
            }
        };
        s.updateProgress = function (translate) {
            if (typeof translate === 'undefined') {
                translate = s.translate || 0;
            }
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            var wasBeginning = s.isBeginning;
            var wasEnd = s.isEnd;
            if (translatesDiff === 0) {
                s.progress = 0;
                s.isBeginning = s.isEnd = true;
            }
            else {
                s.progress = (translate - s.minTranslate()) / (translatesDiff);
                s.isBeginning = s.progress <= 0;
                s.isEnd = s.progress >= 1;
            }
            if (s.isBeginning && !wasBeginning) s.emit('onReachBeginning', s);
            if (s.isEnd && !wasEnd) s.emit('onReachEnd', s);
        
            if (s.params.watchSlidesProgress) s.updateSlidesProgress(translate);
            s.emit('onProgress', s, s.progress);
        };
        s.updateActiveIndex = function () {
            var translate = s.rtl ? s.translate : -s.translate;
            var newActiveIndex, i, snapIndex;
            for (i = 0; i < s.slidesGrid.length; i ++) {
                if (typeof s.slidesGrid[i + 1] !== 'undefined') {
                    if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
                        newActiveIndex = i;
                    }
                    else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
                        newActiveIndex = i + 1;
                    }
                }
                else {
                    if (translate >= s.slidesGrid[i]) {
                        newActiveIndex = i;
                    }
                }
            }
            // Normalize slideIndex
            if(s.params.normalizeSlideIndex){
                if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined') newActiveIndex = 0;
            }
            // for (i = 0; i < s.slidesGrid.length; i++) {
                // if (- translate >= s.slidesGrid[i]) {
                    // newActiveIndex = i;
                // }
            // }
            snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
            if (snapIndex >= s.snapGrid.length) snapIndex = s.snapGrid.length - 1;
        
            if (newActiveIndex === s.activeIndex) {
                return;
            }
            s.snapIndex = snapIndex;
            s.previousIndex = s.activeIndex;
            s.activeIndex = newActiveIndex;
            s.updateClasses();
            s.updateRealIndex();
        };
        s.updateRealIndex = function(){
            s.realIndex = s.slides.eq(s.activeIndex).attr('data-swiper-slide-index') || s.activeIndex;
        };
        
        /*=========================
          Classes
          ===========================*/
        s.updateClasses = function () {
            s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass + ' ' + s.params.slideDuplicateActiveClass + ' ' + s.params.slideDuplicateNextClass + ' ' + s.params.slideDuplicatePrevClass);
            var activeSlide = s.slides.eq(s.activeIndex);
            // Active classes
            activeSlide.addClass(s.params.slideActiveClass);
            if (params.loop) {
                // Duplicate to all looped slides
                if (activeSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
                }
                else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + s.realIndex + '"]').addClass(s.params.slideDuplicateActiveClass);
                }
            }
            // Next Slide
            var nextSlide = activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
            if (s.params.loop && nextSlide.length === 0) {
                nextSlide = s.slides.eq(0);
                nextSlide.addClass(s.params.slideNextClass);
            }
            // Prev Slide
            var prevSlide = activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
            if (s.params.loop && prevSlide.length === 0) {
                prevSlide = s.slides.eq(-1);
                prevSlide.addClass(s.params.slidePrevClass);
            }
            if (params.loop) {
                // Duplicate to all looped slides
                if (nextSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
                }
                else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicateNextClass);
                }
                if (prevSlide.hasClass(s.params.slideDuplicateClass)) {
                    s.wrapper.children('.' + s.params.slideClass + ':not(.' + s.params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
                }
                else {
                    s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]').addClass(s.params.slideDuplicatePrevClass);
                }
            }
        
            // Pagination
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                // Current/Total
                var current,
                    total = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                if (s.params.loop) {
                    current = Math.ceil((s.activeIndex - s.loopedSlides)/s.params.slidesPerGroup);
                    if (current > s.slides.length - 1 - s.loopedSlides * 2) {
                        current = current - (s.slides.length - s.loopedSlides * 2);
                    }
                    if (current > total - 1) current = current - total;
                    if (current < 0 && s.params.paginationType !== 'bullets') current = total + current;
                }
                else {
                    if (typeof s.snapIndex !== 'undefined') {
                        current = s.snapIndex;
                    }
                    else {
                        current = s.activeIndex || 0;
                    }
                }
                // Types
                if (s.params.paginationType === 'bullets' && s.bullets && s.bullets.length > 0) {
                    s.bullets.removeClass(s.params.bulletActiveClass);
                    if (s.paginationContainer.length > 1) {
                        s.bullets.each(function () {
                            if ($(this).index() === current) $(this).addClass(s.params.bulletActiveClass);
                        });
                    }
                    else {
                        s.bullets.eq(current).addClass(s.params.bulletActiveClass);
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    s.paginationContainer.find('.' + s.params.paginationCurrentClass).text(current + 1);
                    s.paginationContainer.find('.' + s.params.paginationTotalClass).text(total);
                }
                if (s.params.paginationType === 'progress') {
                    var scale = (current + 1) / total,
                        scaleX = scale,
                        scaleY = 1;
                    if (!s.isHorizontal()) {
                        scaleY = scale;
                        scaleX = 1;
                    }
                    s.paginationContainer.find('.' + s.params.paginationProgressbarClass).transform('translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')').transition(s.params.speed);
                }
                if (s.params.paginationType === 'custom' && s.params.paginationCustomRender) {
                    s.paginationContainer.html(s.params.paginationCustomRender(s, current + 1, total));
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        
            // Next/active buttons
            if (!s.params.loop) {
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    if (s.isBeginning) {
                        s.prevButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.prevButton);
                    }
                    else {
                        s.prevButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.prevButton);
                    }
                }
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    if (s.isEnd) {
                        s.nextButton.addClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.disable(s.nextButton);
                    }
                    else {
                        s.nextButton.removeClass(s.params.buttonDisabledClass);
                        if (s.params.a11y && s.a11y) s.a11y.enable(s.nextButton);
                    }
                }
            }
        };
        
        /*=========================
          Pagination
          ===========================*/
        s.updatePagination = function () {
            if (!s.params.pagination) return;
            if (s.paginationContainer && s.paginationContainer.length > 0) {
                var paginationHTML = '';
                if (s.params.paginationType === 'bullets') {
                    var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
                    for (var i = 0; i < numberOfBullets; i++) {
                        if (s.params.paginationBulletRender) {
                            paginationHTML += s.params.paginationBulletRender(s, i, s.params.bulletClass);
                        }
                        else {
                            paginationHTML += '<' + s.params.paginationElement+' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
                        }
                    }
                    s.paginationContainer.html(paginationHTML);
                    s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
                    if (s.params.paginationClickable && s.params.a11y && s.a11y) {
                        s.a11y.initPagination();
                    }
                }
                if (s.params.paginationType === 'fraction') {
                    if (s.params.paginationFractionRender) {
                        paginationHTML = s.params.paginationFractionRender(s, s.params.paginationCurrentClass, s.params.paginationTotalClass);
                    }
                    else {
                        paginationHTML =
                            '<span class="' + s.params.paginationCurrentClass + '"></span>' +
                            ' / ' +
                            '<span class="' + s.params.paginationTotalClass+'"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType === 'progress') {
                    if (s.params.paginationProgressRender) {
                        paginationHTML = s.params.paginationProgressRender(s, s.params.paginationProgressbarClass);
                    }
                    else {
                        paginationHTML = '<span class="' + s.params.paginationProgressbarClass + '"></span>';
                    }
                    s.paginationContainer.html(paginationHTML);
                }
                if (s.params.paginationType !== 'custom') {
                    s.emit('onPaginationRendered', s, s.paginationContainer[0]);
                }
            }
        };
        /*=========================
          Common update method
          ===========================*/
        s.update = function (updateTranslate) {
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updateProgress();
            s.updatePagination();
            s.updateClasses();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            function forceSetTranslate() {
                var translate = s.rtl ? -s.translate : s.translate;
                newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
            }
            if (updateTranslate) {
                var translated, newTranslate;
                if (s.controller && s.controller.spline) {
                    s.controller.spline = undefined;
                }
                if (s.params.freeMode) {
                    forceSetTranslate();
                    if (s.params.autoHeight) {
                        s.updateAutoHeight();
                    }
                }
                else {
                    if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                        translated = s.slideTo(s.slides.length - 1, 0, false, true);
                    }
                    else {
                        translated = s.slideTo(s.activeIndex, 0, false, true);
                    }
                    if (!translated) {
                        forceSetTranslate();
                    }
                }
            }
            else if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
        };
        
        /*=========================
          Resize Handler
          ===========================*/
        s.onResize = function (forceUpdatePagination) {
            //Breakpoints
            if (s.params.breakpoints) {
                s.setBreakpoint();
            }
        
            // Disable locks on resize
            var allowSwipeToPrev = s.params.allowSwipeToPrev;
            var allowSwipeToNext = s.params.allowSwipeToNext;
            s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
        
            s.updateContainerSize();
            s.updateSlidesSize();
            if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination) s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
            }
            if (s.controller && s.controller.spline) {
                s.controller.spline = undefined;
            }
            var slideChangedBySlideTo = false;
            if (s.params.freeMode) {
                var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                s.setWrapperTranslate(newTranslate);
                s.updateActiveIndex();
                s.updateClasses();
        
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
            }
            else {
                s.updateClasses();
                if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                    slideChangedBySlideTo = s.slideTo(s.slides.length - 1, 0, false, true);
                }
                else {
                    slideChangedBySlideTo = s.slideTo(s.activeIndex, 0, false, true);
                }
            }
            if (s.params.lazyLoading && !slideChangedBySlideTo && s.lazy) {
                s.lazy.load();
            }
            // Return locks after resize
            s.params.allowSwipeToPrev = allowSwipeToPrev;
            s.params.allowSwipeToNext = allowSwipeToNext;
        };
        
        /*=========================
          Events
          ===========================*/
        
        //Define Touch Events
        s.touchEventsDesktop = {start: 'mousedown', move: 'mousemove', end: 'mouseup'};
        if (window.navigator.pointerEnabled) s.touchEventsDesktop = {start: 'pointerdown', move: 'pointermove', end: 'pointerup'};
        else if (window.navigator.msPointerEnabled) s.touchEventsDesktop = {start: 'MSPointerDown', move: 'MSPointerMove', end: 'MSPointerUp'};
        s.touchEvents = {
            start : s.support.touch || !s.params.simulateTouch  ? 'touchstart' : s.touchEventsDesktop.start,
            move : s.support.touch || !s.params.simulateTouch ? 'touchmove' : s.touchEventsDesktop.move,
            end : s.support.touch || !s.params.simulateTouch ? 'touchend' : s.touchEventsDesktop.end
        };
        
        
        // WP8 Touch Events Fix
        if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
            (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
        }
        
        // Attach/detach events
        s.initEvents = function (detach) {
            var actionDom = detach ? 'off' : 'on';
            var action = detach ? 'removeEventListener' : 'addEventListener';
            var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
            var target = s.support.touch ? touchEventsTarget : document;
        
            var moveCapture = s.params.nested ? true : false;
        
            //Touch Events
            if (s.browser.ie) {
                touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
                target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                target[action](s.touchEvents.end, s.onTouchEnd, false);
            }
            else {
                if (s.support.touch) {
                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? {passive: true, capture: false} : false;
                    touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, passiveListener);
                    touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
                    touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, passiveListener);
                }
                if ((params.simulateTouch && !s.device.ios && !s.device.android) || (params.simulateTouch && !s.support.touch && s.device.ios)) {
                    touchEventsTarget[action]('mousedown', s.onTouchStart, false);
                    document[action]('mousemove', s.onTouchMove, moveCapture);
                    document[action]('mouseup', s.onTouchEnd, false);
                }
            }
            window[action]('resize', s.onResize);
        
            // Next, Prev, Index
            if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                s.nextButton[actionDom]('click', s.onClickNext);
                if (s.params.a11y && s.a11y) s.nextButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                s.prevButton[actionDom]('click', s.onClickPrev);
                if (s.params.a11y && s.a11y) s.prevButton[actionDom]('keydown', s.a11y.onEnterKey);
            }
            if (s.params.pagination && s.params.paginationClickable) {
                s.paginationContainer[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
                if (s.params.a11y && s.a11y) s.paginationContainer[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
            }
        
            // Prevent Links Clicks
            if (s.params.preventClicks || s.params.preventClicksPropagation) touchEventsTarget[action]('click', s.preventClicks, true);
        };
        s.attachEvents = function () {
            s.initEvents();
        };
        s.detachEvents = function () {
            s.initEvents(true);
        };
        
        /*=========================
          Handle Clicks
          ===========================*/
        // Prevent Clicks
        s.allowClick = true;
        s.preventClicks = function (e) {
            if (!s.allowClick) {
                if (s.params.preventClicks) e.preventDefault();
                if (s.params.preventClicksPropagation && s.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        };
        // Clicks
        s.onClickNext = function (e) {
            e.preventDefault();
            if (s.isEnd && !s.params.loop) return;
            s.slideNext();
        };
        s.onClickPrev = function (e) {
            e.preventDefault();
            if (s.isBeginning && !s.params.loop) return;
            s.slidePrev();
        };
        s.onClickIndex = function (e) {
            e.preventDefault();
            var index = $(this).index() * s.params.slidesPerGroup;
            if (s.params.loop) index = index + s.loopedSlides;
            s.slideTo(index);
        };
        
        /*=========================
          Handle Touches
          ===========================*/
        function findElementInEvent(e, selector) {
            var el = $(e.target);
            if (!el.is(selector)) {
                if (typeof selector === 'string') {
                    el = el.parents(selector);
                }
                else if (selector.nodeType) {
                    var found;
                    el.parents().each(function (index, _el) {
                        if (_el === selector) found = selector;
                    });
                    if (!found) return undefined;
                    else return selector;
                }
            }
            if (el.length === 0) {
                return undefined;
            }
            return el[0];
        }
        s.updateClickedSlide = function (e) {
            var slide = findElementInEvent(e, '.' + s.params.slideClass);
            var slideFound = false;
            if (slide) {
                for (var i = 0; i < s.slides.length; i++) {
                    if (s.slides[i] === slide) slideFound = true;
                }
            }
        
            if (slide && slideFound) {
                s.clickedSlide = slide;
                s.clickedIndex = $(slide).index();
            }
            else {
                s.clickedSlide = undefined;
                s.clickedIndex = undefined;
                return;
            }
            if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
                var slideToIndex = s.clickedIndex,
                    realIndex,
                    duplicatedSlides;
                if (s.params.loop) {
                    if (s.animating) return;
                    realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');
                    if (s.params.centeredSlides) {
                        if ((slideToIndex < s.loopedSlides - s.params.slidesPerView/2) || (slideToIndex > s.slides.length - s.loopedSlides + s.params.slidesPerView/2)) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        }
                        else {
                            s.slideTo(slideToIndex);
                        }
                    }
                    else {
                        if (slideToIndex > s.slides.length - s.params.slidesPerView) {
                            s.fixLoop();
                            slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + s.params.slideDuplicateClass + ')').eq(0).index();
                            setTimeout(function () {
                                s.slideTo(slideToIndex);
                            }, 0);
                        }
                        else {
                            s.slideTo(slideToIndex);
                        }
                    }
                }
                else {
                    s.slideTo(slideToIndex);
                }
            }
        };
        
        var isTouched,
            isMoved,
            allowTouchCallbacks,
            touchStartTime,
            isScrolling,
            currentTranslate,
            startTranslate,
            allowThresholdMove,
            // Form elements to match
            formElements = 'input, select, textarea, button, video',
            // Last click time
            lastClickTime = Date.now(), clickTimeout,
            //Velocities
            velocities = [],
            allowMomentumBounce;
        
        // Animating Flag
        s.animating = false;
        
        // Touches information
        s.touches = {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
        };
        
        // Touch handlers
        var isTouchEvent, startMoving;
        s.onTouchStart = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            isTouchEvent = e.type === 'touchstart';
            if (!isTouchEvent && 'which' in e && e.which === 3) return;
            if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
                s.allowClick = true;
                return;
            }
            if (s.params.swipeHandler) {
                if (!findElementInEvent(e, s.params.swipeHandler)) return;
            }
        
            var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
            var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        
            // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore
            if(s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
                return;
            }
        
            isTouched = true;
            isMoved = false;
            allowTouchCallbacks = true;
            isScrolling = undefined;
            startMoving = undefined;
            s.touches.startX = startX;
            s.touches.startY = startY;
            touchStartTime = Date.now();
            s.allowClick = true;
            s.updateContainerSize();
            s.swipeDirection = undefined;
            if (s.params.threshold > 0) allowThresholdMove = false;
            if (e.type !== 'touchstart') {
                var preventDefault = true;
                if ($(e.target).is(formElements)) preventDefault = false;
                if (document.activeElement && $(document.activeElement).is(formElements)) {
                    document.activeElement.blur();
                }
                if (preventDefault) {
                    e.preventDefault();
                }
            }
            s.emit('onTouchStart', s, e);
        };
        
        s.onTouchMove = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (isTouchEvent && e.type === 'mousemove') return;
            if (e.preventedByNestedSwiper) {
                s.touches.startX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                s.touches.startY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                return;
            }
            if (s.params.onlyExternal) {
                // isMoved = true;
                s.allowClick = false;
                if (isTouched) {
                    s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                    s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
                    touchStartTime = Date.now();
                }
                return;
            }
            if (isTouchEvent && s.params.touchReleaseOnEdges && !s.params.loop) {
                if (!s.isHorizontal()) {
                    // Vertical
                    if (
                        (s.touches.currentY < s.touches.startY && s.translate <= s.maxTranslate()) ||
                        (s.touches.currentY > s.touches.startY && s.translate >= s.minTranslate())
                        ) {
                        return;
                    }
                }
                else {
                    if (
                        (s.touches.currentX < s.touches.startX && s.translate <= s.maxTranslate()) ||
                        (s.touches.currentX > s.touches.startX && s.translate >= s.minTranslate())
                        ) {
                        return;
                    }
                }
            }
            if (isTouchEvent && document.activeElement) {
                if (e.target === document.activeElement && $(e.target).is(formElements)) {
                    isMoved = true;
                    s.allowClick = false;
                    return;
                }
            }
            if (allowTouchCallbacks) {
                s.emit('onTouchMove', s, e);
            }
            if (e.targetTouches && e.targetTouches.length > 1) return;
        
            s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
            s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        
            if (typeof isScrolling === 'undefined') {
                var touchAngle;
                if (s.isHorizontal() && s.touches.currentY === s.touches.startY || !s.isHorizontal() && s.touches.currentX !== s.touches.startX) {
                    isScrolling = false;
                }
                else {
                    touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
                    isScrolling = s.isHorizontal() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
                }
            }
            if (isScrolling) {
                s.emit('onTouchMoveOpposite', s, e);
            }
            if (typeof startMoving === 'undefined' && s.browser.ieTouch) {
                if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
                    startMoving = true;
                }
            }
            if (!isTouched) return;
            if (isScrolling)  {
                isTouched = false;
                return;
            }
            if (!startMoving && s.browser.ieTouch) {
                return;
            }
            s.allowClick = false;
            s.emit('onSliderMove', s, e);
            e.preventDefault();
            if (s.params.touchMoveStopPropagation && !s.params.nested) {
                e.stopPropagation();
            }
        
            if (!isMoved) {
                if (params.loop) {
                    s.fixLoop();
                }
                startTranslate = s.getWrapperTranslate();
                s.setWrapperTransition(0);
                if (s.animating) {
                    s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
                }
                if (s.params.autoplay && s.autoplaying) {
                    if (s.params.autoplayDisableOnInteraction) {
                        s.stopAutoplay();
                    }
                    else {
                        s.pauseAutoplay();
                    }
                }
                allowMomentumBounce = false;
                //Grab Cursor
                if (s.params.grabCursor && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
                    s.setGrabCursor(true);
                }
            }
            isMoved = true;
        
            var diff = s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
        
            diff = diff * s.params.touchRatio;
            if (s.rtl) diff = -diff;
        
            s.swipeDirection = diff > 0 ? 'prev' : 'next';
            currentTranslate = diff + startTranslate;
        
            var disableParentSwiper = true;
            if ((diff > 0 && currentTranslate > s.minTranslate())) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
            }
            else if (diff < 0 && currentTranslate < s.maxTranslate()) {
                disableParentSwiper = false;
                if (s.params.resistance) currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
            }
        
            if (disableParentSwiper) {
                e.preventedByNestedSwiper = true;
            }
        
            // Directions locks
            if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
                currentTranslate = startTranslate;
            }
            if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
                currentTranslate = startTranslate;
            }
        
        
            // Threshold
            if (s.params.threshold > 0) {
                if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
                    if (!allowThresholdMove) {
                        allowThresholdMove = true;
                        s.touches.startX = s.touches.currentX;
                        s.touches.startY = s.touches.currentY;
                        currentTranslate = startTranslate;
                        s.touches.diff = s.isHorizontal() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                        return;
                    }
                }
                else {
                    currentTranslate = startTranslate;
                    return;
                }
            }
        
            if (!s.params.followFinger) return;
        
            // Update active index in free mode
            if (s.params.freeMode || s.params.watchSlidesProgress) {
                s.updateActiveIndex();
            }
            if (s.params.freeMode) {
                //Velocity
                if (velocities.length === 0) {
                    velocities.push({
                        position: s.touches[s.isHorizontal() ? 'startX' : 'startY'],
                        time: touchStartTime
                    });
                }
                velocities.push({
                    position: s.touches[s.isHorizontal() ? 'currentX' : 'currentY'],
                    time: (new window.Date()).getTime()
                });
            }
            // Update progress
            s.updateProgress(currentTranslate);
            // Update translate
            s.setWrapperTranslate(currentTranslate);
        };
        s.onTouchEnd = function (e) {
            if (e.originalEvent) e = e.originalEvent;
            if (allowTouchCallbacks) {
                s.emit('onTouchEnd', s, e);
            }
            allowTouchCallbacks = false;
            if (!isTouched) return;
            //Return Grab Cursor
            if (s.params.grabCursor && isMoved && isTouched  && (s.params.allowSwipeToNext === true || s.params.allowSwipeToPrev === true)) {
                s.setGrabCursor(false);
            }
        
            // Time diff
            var touchEndTime = Date.now();
            var timeDiff = touchEndTime - touchStartTime;
        
            // Tap, doubleTap, Click
            if (s.allowClick) {
                s.updateClickedSlide(e);
                s.emit('onTap', s, e);
                if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    clickTimeout = setTimeout(function () {
                        if (!s) return;
                        if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
                            s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
                        }
                        s.emit('onClick', s, e);
                    }, 300);
        
                }
                if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
                    if (clickTimeout) clearTimeout(clickTimeout);
                    s.emit('onDoubleTap', s, e);
                }
            }
        
            lastClickTime = Date.now();
            setTimeout(function () {
                if (s) s.allowClick = true;
            }, 0);
        
            if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
                isTouched = isMoved = false;
                return;
            }
            isTouched = isMoved = false;
        
            var currentPos;
            if (s.params.followFinger) {
                currentPos = s.rtl ? s.translate : -s.translate;
            }
            else {
                currentPos = -currentTranslate;
            }
            if (s.params.freeMode) {
                if (currentPos < -s.minTranslate()) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                else if (currentPos > -s.maxTranslate()) {
                    if (s.slides.length < s.snapGrid.length) {
                        s.slideTo(s.snapGrid.length - 1);
                    }
                    else {
                        s.slideTo(s.slides.length - 1);
                    }
                    return;
                }
        
                if (s.params.freeModeMomentum) {
                    if (velocities.length > 1) {
                        var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop();
        
                        var distance = lastMoveEvent.position - velocityEvent.position;
                        var time = lastMoveEvent.time - velocityEvent.time;
                        s.velocity = distance / time;
                        s.velocity = s.velocity / 2;
                        if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
                            s.velocity = 0;
                        }
                        // this implies that the user stopped moving a finger then released.
                        // There would be no events with distance zero, so the last event is stale.
                        if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
                            s.velocity = 0;
                        }
                    } else {
                        s.velocity = 0;
                    }
                    s.velocity = s.velocity * s.params.freeModeMomentumVelocityRatio;
        
                    velocities.length = 0;
                    var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
                    var momentumDistance = s.velocity * momentumDuration;
        
                    var newPosition = s.translate + momentumDistance;
                    if (s.rtl) newPosition = - newPosition;
                    var doBounce = false;
                    var afterBouncePosition;
                    var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
                    if (newPosition < s.maxTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition + s.maxTranslate() < -bounceAmount) {
                                newPosition = s.maxTranslate() - bounceAmount;
                            }
                            afterBouncePosition = s.maxTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        }
                        else {
                            newPosition = s.maxTranslate();
                        }
                    }
                    else if (newPosition > s.minTranslate()) {
                        if (s.params.freeModeMomentumBounce) {
                            if (newPosition - s.minTranslate() > bounceAmount) {
                                newPosition = s.minTranslate() + bounceAmount;
                            }
                            afterBouncePosition = s.minTranslate();
                            doBounce = true;
                            allowMomentumBounce = true;
                        }
                        else {
                            newPosition = s.minTranslate();
                        }
                    }
                    else if (s.params.freeModeSticky) {
                        var j = 0,
                            nextSlide;
                        for (j = 0; j < s.snapGrid.length; j += 1) {
                            if (s.snapGrid[j] > -newPosition) {
                                nextSlide = j;
                                break;
                            }
        
                        }
                        if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                            newPosition = s.snapGrid[nextSlide];
                        } else {
                            newPosition = s.snapGrid[nextSlide - 1];
                        }
                        if (!s.rtl) newPosition = - newPosition;
                    }
                    //Fix duration
                    if (s.velocity !== 0) {
                        if (s.rtl) {
                            momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
                        }
                        else {
                            momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
                        }
                    }
                    else if (s.params.freeModeSticky) {
                        s.slideReset();
                        return;
                    }
        
                    if (s.params.freeModeMomentumBounce && doBounce) {
                        s.updateProgress(afterBouncePosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        s.animating = true;
                        s.wrapper.transitionEnd(function () {
                            if (!s || !allowMomentumBounce) return;
                            s.emit('onMomentumBounce', s);
        
                            s.setWrapperTransition(s.params.speed);
                            s.setWrapperTranslate(afterBouncePosition);
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        });
                    } else if (s.velocity) {
                        s.updateProgress(newPosition);
                        s.setWrapperTransition(momentumDuration);
                        s.setWrapperTranslate(newPosition);
                        s.onTransitionStart();
                        if (!s.animating) {
                            s.animating = true;
                            s.wrapper.transitionEnd(function () {
                                if (!s) return;
                                s.onTransitionEnd();
                            });
                        }
        
                    } else {
                        s.updateProgress(newPosition);
                    }
        
                    s.updateActiveIndex();
                }
                if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
                    s.updateProgress();
                    s.updateActiveIndex();
                }
                return;
            }
        
            // Find current slide
            var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
            for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
                if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
                    if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
                    }
                }
                else {
                    if (currentPos >= s.slidesGrid[i]) {
                        stopIndex = i;
                        groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
                    }
                }
            }
        
            // Find current slide size
            var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
        
            if (timeDiff > s.params.longSwipesMs) {
                // Long touches
                if (!s.params.longSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    if (ratio >= s.params.longSwipesRatio) s.slideTo(stopIndex + s.params.slidesPerGroup);
                    else s.slideTo(stopIndex);
        
                }
                if (s.swipeDirection === 'prev') {
                    if (ratio > (1 - s.params.longSwipesRatio)) s.slideTo(stopIndex + s.params.slidesPerGroup);
                    else s.slideTo(stopIndex);
                }
            }
            else {
                // Short swipes
                if (!s.params.shortSwipes) {
                    s.slideTo(s.activeIndex);
                    return;
                }
                if (s.swipeDirection === 'next') {
                    s.slideTo(stopIndex + s.params.slidesPerGroup);
        
                }
                if (s.swipeDirection === 'prev') {
                    s.slideTo(stopIndex);
                }
            }
        };
        /*=========================
          Transitions
          ===========================*/
        s._slideTo = function (slideIndex, speed) {
            return s.slideTo(slideIndex, speed, true, true);
        };
        s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (typeof slideIndex === 'undefined') slideIndex = 0;
            if (slideIndex < 0) slideIndex = 0;
            s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
            if (s.snapIndex >= s.snapGrid.length) s.snapIndex = s.snapGrid.length - 1;
        
            var translate = - s.snapGrid[s.snapIndex];
            // Stop autoplay
            if (s.params.autoplay && s.autoplaying) {
                if (internal || !s.params.autoplayDisableOnInteraction) {
                    s.pauseAutoplay(speed);
                }
                else {
                    s.stopAutoplay();
                }
            }
            // Update progress
            s.updateProgress(translate);
        
            // Normalize slideIndex
            if(s.params.normalizeSlideIndex){
                for (var i = 0; i < s.slidesGrid.length; i++) {
                    if (- Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
                        slideIndex = i;
                    }
                }
            }
        
            // Directions locks
            if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
                if ((s.activeIndex || 0) !== slideIndex ) return false;
            }
        
            // Update Index
            if (typeof speed === 'undefined') speed = s.params.speed;
            s.previousIndex = s.activeIndex || 0;
            s.activeIndex = slideIndex;
            s.updateRealIndex();
            if ((s.rtl && -translate === s.translate) || (!s.rtl && translate === s.translate)) {
                // Update Height
                if (s.params.autoHeight) {
                    s.updateAutoHeight();
                }
                s.updateClasses();
                if (s.params.effect !== 'slide') {
                    s.setWrapperTranslate(translate);
                }
                return false;
            }
            s.updateClasses();
            s.onTransitionStart(runCallbacks);
        
            if (speed === 0 || s.browser.lteIE9) {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(0);
                s.onTransitionEnd(runCallbacks);
            }
            else {
                s.setWrapperTranslate(translate);
                s.setWrapperTransition(speed);
                if (!s.animating) {
                    s.animating = true;
                    s.wrapper.transitionEnd(function () {
                        if (!s) return;
                        s.onTransitionEnd(runCallbacks);
                    });
                }
        
            }
        
            return true;
        };
        
        s.onTransitionStart = function (runCallbacks) {
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.params.autoHeight) {
                s.updateAutoHeight();
            }
            if (s.lazy) s.lazy.onTransitionStart();
            if (runCallbacks) {
                s.emit('onTransitionStart', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeStart', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextStart', s);
                    }
                    else {
                        s.emit('onSlidePrevStart', s);
                    }
                }
        
            }
        };
        s.onTransitionEnd = function (runCallbacks) {
            s.animating = false;
            s.setWrapperTransition(0);
            if (typeof runCallbacks === 'undefined') runCallbacks = true;
            if (s.lazy) s.lazy.onTransitionEnd();
            if (runCallbacks) {
                s.emit('onTransitionEnd', s);
                if (s.activeIndex !== s.previousIndex) {
                    s.emit('onSlideChangeEnd', s);
                    if (s.activeIndex > s.previousIndex) {
                        s.emit('onSlideNextEnd', s);
                    }
                    else {
                        s.emit('onSlidePrevEnd', s);
                    }
                }
            }
            if (s.params.history && s.history) {
                s.history.setHistory(s.params.history, s.activeIndex);
            }
            if (s.params.hashnav && s.hashnav) {
                s.hashnav.setHash();
            }
        
        };
        s.slideNext = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
            }
            else return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
        };
        s._slideNext = function (speed) {
            return s.slideNext(true, speed, true);
        };
        s.slidePrev = function (runCallbacks, speed, internal) {
            if (s.params.loop) {
                if (s.animating) return false;
                s.fixLoop();
                var clientLeft = s.container[0].clientLeft;
                return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
            }
            else return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
        };
        s._slidePrev = function (speed) {
            return s.slidePrev(true, speed, true);
        };
        s.slideReset = function (runCallbacks, speed, internal) {
            return s.slideTo(s.activeIndex, speed, runCallbacks);
        };
        
        s.disableTouchControl = function () {
            s.params.onlyExternal = true;
            return true;
        };
        s.enableTouchControl = function () {
            s.params.onlyExternal = false;
            return true;
        };
        
        /*=========================
          Translate/transition helpers
          ===========================*/
        s.setWrapperTransition = function (duration, byController) {
            s.wrapper.transition(duration);
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTransition(duration);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTransition(duration);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTransition(duration);
            }
            if (s.params.control && s.controller) {
                s.controller.setTransition(duration, byController);
            }
            s.emit('onSetTransition', s, duration);
        };
        s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
            var x = 0, y = 0, z = 0;
            if (s.isHorizontal()) {
                x = s.rtl ? -translate : translate;
            }
            else {
                y = translate;
            }
        
            if (s.params.roundLengths) {
                x = round(x);
                y = round(y);
            }
        
            if (!s.params.virtualTranslate) {
                if (s.support.transforms3d) s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
                else s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
            }
        
            s.translate = s.isHorizontal() ? x : y;
        
            // Check if we need to update progress
            var progress;
            var translatesDiff = s.maxTranslate() - s.minTranslate();
            if (translatesDiff === 0) {
                progress = 0;
            }
            else {
                progress = (translate - s.minTranslate()) / (translatesDiff);
            }
            if (progress !== s.progress) {
                s.updateProgress(translate);
            }
        
            if (updateActiveIndex) s.updateActiveIndex();
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                s.effects[s.params.effect].setTranslate(s.translate);
            }
            if (s.params.parallax && s.parallax) {
                s.parallax.setTranslate(s.translate);
            }
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.setTranslate(s.translate);
            }
            if (s.params.control && s.controller) {
                s.controller.setTranslate(s.translate, byController);
            }
            s.emit('onSetTranslate', s, s.translate);
        };
        
        s.getTranslate = function (el, axis) {
            var matrix, curTransform, curStyle, transformMatrix;
        
            // automatic axis detection
            if (typeof axis === 'undefined') {
                axis = 'x';
            }
        
            if (s.params.virtualTranslate) {
                return s.rtl ? -s.translate : s.translate;
            }
        
            curStyle = window.getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(',').length > 6) {
                    curTransform = curTransform.split(', ').map(function(a){
                        return a.replace(',','.');
                    }).join(', ');
                }
                // Some old versions of Webkit choke when 'none' is passed; pass
                // empty string instead in this case
                transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
            }
            else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform  || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
                matrix = transformMatrix.toString().split(',');
            }
        
            if (axis === 'x') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m41;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[12]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[4]);
            }
            if (axis === 'y') {
                //Latest Chrome and webkits Fix
                if (window.WebKitCSSMatrix)
                    curTransform = transformMatrix.m42;
                //Crazy IE10 Matrix
                else if (matrix.length === 16)
                    curTransform = parseFloat(matrix[13]);
                //Normal Browsers
                else
                    curTransform = parseFloat(matrix[5]);
            }
            if (s.rtl && curTransform) curTransform = -curTransform;
            return curTransform || 0;
        };
        s.getWrapperTranslate = function (axis) {
            if (typeof axis === 'undefined') {
                axis = s.isHorizontal() ? 'x' : 'y';
            }
            return s.getTranslate(s.wrapper[0], axis);
        };
        
        /*=========================
          Observer
          ===========================*/
        s.observers = [];
        function initObserver(target, options) {
            options = options || {};
            // create an observer instance
            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
            var observer = new ObserverFunc(function (mutations) {
                mutations.forEach(function (mutation) {
                    s.onResize(true);
                    s.emit('onObserverUpdate', s, mutation);
                });
            });
        
            observer.observe(target, {
                attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
                childList: typeof options.childList === 'undefined' ? true : options.childList,
                characterData: typeof options.characterData === 'undefined' ? true : options.characterData
            });
        
            s.observers.push(observer);
        }
        s.initObservers = function () {
            if (s.params.observeParents) {
                var containerParents = s.container.parents();
                for (var i = 0; i < containerParents.length; i++) {
                    initObserver(containerParents[i]);
                }
            }
        
            // Observe container
            initObserver(s.container[0], {childList: false});
        
            // Observe wrapper
            initObserver(s.wrapper[0], {attributes: false});
        };
        s.disconnectObservers = function () {
            for (var i = 0; i < s.observers.length; i++) {
                s.observers[i].disconnect();
            }
            s.observers = [];
        };
        /*=========================
          Loop
          ===========================*/
        // Create looped slides
        s.createLoop = function () {
            // Remove duplicated slides
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
        
            var slides = s.wrapper.children('.' + s.params.slideClass);
        
            if(s.params.slidesPerView === 'auto' && !s.params.loopedSlides) s.params.loopedSlides = slides.length;
        
            s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
            s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
            if (s.loopedSlides > slides.length) {
                s.loopedSlides = slides.length;
            }
        
            var prependSlides = [], appendSlides = [], i;
            slides.each(function (index, el) {
                var slide = $(this);
                if (index < s.loopedSlides) appendSlides.push(el);
                if (index < slides.length && index >= slides.length - s.loopedSlides) prependSlides.push(el);
                slide.attr('data-swiper-slide-index', index);
            });
            for (i = 0; i < appendSlides.length; i++) {
                s.wrapper.append($(appendSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
            for (i = prependSlides.length - 1; i >= 0; i--) {
                s.wrapper.prepend($(prependSlides[i].cloneNode(true)).addClass(s.params.slideDuplicateClass));
            }
        };
        s.destroyLoop = function () {
            s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
            s.slides.removeAttr('data-swiper-slide-index');
        };
        s.reLoop = function (updatePosition) {
            var oldIndex = s.activeIndex - s.loopedSlides;
            s.destroyLoop();
            s.createLoop();
            s.updateSlidesSize();
            if (updatePosition) {
                s.slideTo(oldIndex + s.loopedSlides, 0, false);
            }
        
        };
        s.fixLoop = function () {
            var newIndex;
            //Fix For Negative Oversliding
            if (s.activeIndex < s.loopedSlides) {
                newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
            //Fix For Positive Oversliding
            else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
                newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
                newIndex = newIndex + s.loopedSlides;
                s.slideTo(newIndex, 0, false, true);
            }
        };
        /*=========================
          Append/Prepend/Remove Slides
          ===========================*/
        s.appendSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.append(slides[i]);
                }
            }
            else {
                s.wrapper.append(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
        };
        s.prependSlide = function (slides) {
            if (s.params.loop) {
                s.destroyLoop();
            }
            var newActiveIndex = s.activeIndex + 1;
            if (typeof slides === 'object' && slides.length) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i]) s.wrapper.prepend(slides[i]);
                }
                newActiveIndex = s.activeIndex + slides.length;
            }
            else {
                s.wrapper.prepend(slides);
            }
            if (s.params.loop) {
                s.createLoop();
            }
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            s.slideTo(newActiveIndex, 0, false);
        };
        s.removeSlide = function (slidesIndexes) {
            if (s.params.loop) {
                s.destroyLoop();
                s.slides = s.wrapper.children('.' + s.params.slideClass);
            }
            var newActiveIndex = s.activeIndex,
                indexToRemove;
            if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
                for (var i = 0; i < slidesIndexes.length; i++) {
                    indexToRemove = slidesIndexes[i];
                    if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                    if (indexToRemove < newActiveIndex) newActiveIndex--;
                }
                newActiveIndex = Math.max(newActiveIndex, 0);
            }
            else {
                indexToRemove = slidesIndexes;
                if (s.slides[indexToRemove]) s.slides.eq(indexToRemove).remove();
                if (indexToRemove < newActiveIndex) newActiveIndex--;
                newActiveIndex = Math.max(newActiveIndex, 0);
            }
        
            if (s.params.loop) {
                s.createLoop();
            }
        
            if (!(s.params.observer && s.support.observer)) {
                s.update(true);
            }
            if (s.params.loop) {
                s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
            }
            else {
                s.slideTo(newActiveIndex, 0, false);
            }
        
        };
        s.removeAllSlides = function () {
            var slidesIndexes = [];
            for (var i = 0; i < s.slides.length; i++) {
                slidesIndexes.push(i);
            }
            s.removeSlide(slidesIndexes);
        };
        

        /*=========================
          Effects
          ===========================*/
        s.effects = {
            fade: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var offset = slide[0].swiperSlideOffset;
                        var tx = -offset;
                        if (!s.params.virtualTranslate) tx = tx - s.translate;
                        var ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
                        var slideOpacity = s.params.fade.crossFade ?
                                Math.max(1 - Math.abs(slide[0].progress), 0) :
                                1 + Math.min(Math.max(slide[0].progress, -1), 0);
                        slide
                            .css({
                                opacity: slideOpacity
                            })
                            .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
        
                    }
        
                },
                setTransition: function (duration) {
                    s.slides.transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            flip: {
                setTranslate: function () {
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var progress = slide[0].progress;
                        if (s.params.flip.limitRotation) {
                            progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        }
                        var offset = slide[0].swiperSlideOffset;
                        var rotate = -180 * progress,
                            rotateY = rotate,
                            rotateX = 0,
                            tx = -offset,
                            ty = 0;
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                            rotateX = -rotateY;
                            rotateY = 0;
                        }
                        else if (s.rtl) {
                            rotateY = -rotateY;
                        }
        
                        slide[0].style.zIndex = -Math.abs(Math.round(progress)) + s.slides.length;
        
                        if (s.params.flip.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
        
                        slide
                            .transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px) rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)');
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.virtualTranslate && duration !== 0) {
                        var eventTriggered = false;
                        s.slides.eq(s.activeIndex).transitionEnd(function () {
                            if (eventTriggered) return;
                            if (!s) return;
                            if (!$(this).hasClass(s.params.slideActiveClass)) return;
                            eventTriggered = true;
                            s.animating = false;
                            var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                            for (var i = 0; i < triggerEvents.length; i++) {
                                s.wrapper.trigger(triggerEvents[i]);
                            }
                        });
                    }
                }
            },
            cube: {
                setTranslate: function () {
                    var wrapperRotate = 0, cubeShadow;
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow = s.wrapper.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.wrapper.append(cubeShadow);
                            }
                            cubeShadow.css({height: s.width + 'px'});
                        }
                        else {
                            cubeShadow = s.container.find('.swiper-cube-shadow');
                            if (cubeShadow.length === 0) {
                                cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                                s.container.append(cubeShadow);
                            }
                        }
                    }
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides.eq(i);
                        var slideAngle = i * 90;
                        var round = Math.floor(slideAngle / 360);
                        if (s.rtl) {
                            slideAngle = -slideAngle;
                            round = Math.floor(-slideAngle / 360);
                        }
                        var progress = Math.max(Math.min(slide[0].progress, 1), -1);
                        var tx = 0, ty = 0, tz = 0;
                        if (i % 4 === 0) {
                            tx = - round * 4 * s.size;
                            tz = 0;
                        }
                        else if ((i - 1) % 4 === 0) {
                            tx = 0;
                            tz = - round * 4 * s.size;
                        }
                        else if ((i - 2) % 4 === 0) {
                            tx = s.size + round * 4 * s.size;
                            tz = s.size;
                        }
                        else if ((i - 3) % 4 === 0) {
                            tx = - s.size;
                            tz = 3 * s.size + s.size * 4 * round;
                        }
                        if (s.rtl) {
                            tx = -tx;
                        }
        
                        if (!s.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
        
                        var transform = 'rotateX(' + (s.isHorizontal() ? 0 : -slideAngle) + 'deg) rotateY(' + (s.isHorizontal() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                        if (progress <= 1 && progress > -1) {
                            wrapperRotate = i * 90 + progress * 90;
                            if (s.rtl) wrapperRotate = -i * 90 - progress * 90;
                        }
                        slide.transform(transform);
                        if (s.params.cube.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
                            if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
                        }
                    }
                    s.wrapper.css({
                        '-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        '-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        '-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                        'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
                    });
        
                    if (s.params.cube.shadow) {
                        if (s.isHorizontal()) {
                            cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
                        }
                        else {
                            var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                            var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                            var scale1 = s.params.cube.shadowScale,
                                scale2 = s.params.cube.shadowScale / multiplier,
                                offset = s.params.cube.shadowOffset;
                            cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
                        }
                    }
                    var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
                    s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (s.isHorizontal() ? 0 : wrapperRotate) + 'deg) rotateY(' + (s.isHorizontal() ? -wrapperRotate : 0) + 'deg)');
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                    if (s.params.cube.shadow && !s.isHorizontal()) {
                        s.container.find('.swiper-cube-shadow').transition(duration);
                    }
                }
            },
            coverflow: {
                setTranslate: function () {
                    var transform = s.translate;
                    var center = s.isHorizontal() ? -transform + s.width / 2 : -transform + s.height / 2;
                    var rotate = s.isHorizontal() ? s.params.coverflow.rotate: -s.params.coverflow.rotate;
                    var translate = s.params.coverflow.depth;
                    //Each slide offset from center
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideSize = s.slidesSizesGrid[i];
                        var slideOffset = slide[0].swiperSlideOffset;
                        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
        
                        var rotateY = s.isHorizontal() ? rotate * offsetMultiplier : 0;
                        var rotateX = s.isHorizontal() ? 0 : rotate * offsetMultiplier;
                        // var rotateZ = 0
                        var translateZ = -translate * Math.abs(offsetMultiplier);
        
                        var translateY = s.isHorizontal() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
                        var translateX = s.isHorizontal() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;
        
                        //Fix for ultra small values
                        if (Math.abs(translateX) < 0.001) translateX = 0;
                        if (Math.abs(translateY) < 0.001) translateY = 0;
                        if (Math.abs(translateZ) < 0.001) translateZ = 0;
                        if (Math.abs(rotateY) < 0.001) rotateY = 0;
                        if (Math.abs(rotateX) < 0.001) rotateX = 0;
        
                        var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
        
                        slide.transform(slideTransform);
                        slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                        if (s.params.coverflow.slideShadows) {
                            //Set shadows
                            var shadowBefore = s.isHorizontal() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                            var shadowAfter = s.isHorizontal() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                            if (shadowBefore.length === 0) {
                                shadowBefore = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'left' : 'top') + '"></div>');
                                slide.append(shadowBefore);
                            }
                            if (shadowAfter.length === 0) {
                                shadowAfter = $('<div class="swiper-slide-shadow-' + (s.isHorizontal() ? 'right' : 'bottom') + '"></div>');
                                slide.append(shadowAfter);
                            }
                            if (shadowBefore.length) shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                            if (shadowAfter.length) shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                        }
                    }
        
                    //Set correct perspective for IE10
                    if (s.browser.ie) {
                        var ws = s.wrapper[0].style;
                        ws.perspectiveOrigin = center + 'px 50%';
                    }
                },
                setTransition: function (duration) {
                    s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
                }
            }
        };

        /*=========================
          Images Lazy Loading
          ===========================*/
        s.lazy = {
            initialImageLoaded: false,
            loadImageInSlide: function (index, loadInDuplicate) {
                if (typeof index === 'undefined') return;
                if (typeof loadInDuplicate === 'undefined') loadInDuplicate = true;
                if (s.slides.length === 0) return;
        
                var slide = s.slides.eq(index);
                var img = slide.find('.' + s.params.lazyLoadingClass + ':not(.' + s.params.lazyStatusLoadedClass + '):not(.' + s.params.lazyStatusLoadingClass + ')');
                if (slide.hasClass(s.params.lazyLoadingClass) && !slide.hasClass(s.params.lazyStatusLoadedClass) && !slide.hasClass(s.params.lazyStatusLoadingClass)) {
                    img = img.add(slide[0]);
                }
                if (img.length === 0) return;
        
                img.each(function () {
                    var _img = $(this);
                    _img.addClass(s.params.lazyStatusLoadingClass);
                    var background = _img.attr('data-background');
                    var src = _img.attr('data-src'),
                        srcset = _img.attr('data-srcset'),
                        sizes = _img.attr('data-sizes');
                    s.loadImage(_img[0], (src || background), srcset, sizes, false, function () {
                        if (background) {
                            _img.css('background-image', 'url("' + background + '")');
                            _img.removeAttr('data-background');
                        }
                        else {
                            if (srcset) {
                                _img.attr('srcset', srcset);
                                _img.removeAttr('data-srcset');
                            }
                            if (sizes) {
                                _img.attr('sizes', sizes);
                                _img.removeAttr('data-sizes');
                            }
                            if (src) {
                                _img.attr('src', src);
                                _img.removeAttr('data-src');
                            }
        
                        }
        
                        _img.addClass(s.params.lazyStatusLoadedClass).removeClass(s.params.lazyStatusLoadingClass);
                        slide.find('.' + s.params.lazyPreloaderClass + ', .' + s.params.preloaderClass).remove();
                        if (s.params.loop && loadInDuplicate) {
                            var slideOriginalIndex = slide.attr('data-swiper-slide-index');
                            if (slide.hasClass(s.params.slideDuplicateClass)) {
                                var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
                                s.lazy.loadImageInSlide(originalSlide.index(), false);
                            }
                            else {
                                var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                                s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
                            }
                        }
                        s.emit('onLazyImageReady', s, slide[0], _img[0]);
                    });
        
                    s.emit('onLazyImageLoad', s, slide[0], _img[0]);
                });
        
            },
            load: function () {
                var i;
                var slidesPerView = s.params.slidesPerView;
                if (slidesPerView === 'auto') {
                    slidesPerView = 0;
                }
                if (!s.lazy.initialImageLoaded) s.lazy.initialImageLoaded = true;
                if (s.params.watchSlidesVisibility) {
                    s.wrapper.children('.' + s.params.slideVisibleClass).each(function () {
                        s.lazy.loadImageInSlide($(this).index());
                    });
                }
                else {
                    if (slidesPerView > 1) {
                        for (i = s.activeIndex; i < s.activeIndex + slidesPerView ; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    }
                    else {
                        s.lazy.loadImageInSlide(s.activeIndex);
                    }
                }
                if (s.params.lazyLoadingInPrevNext) {
                    if (slidesPerView > 1 || (s.params.lazyLoadingInPrevNextAmount && s.params.lazyLoadingInPrevNextAmount > 1)) {
                        var amount = s.params.lazyLoadingInPrevNextAmount;
                        var spv = slidesPerView;
                        var maxIndex = Math.min(s.activeIndex + spv + Math.max(amount, spv), s.slides.length);
                        var minIndex = Math.max(s.activeIndex - Math.max(spv, amount), 0);
                        // Next Slides
                        for (i = s.activeIndex + slidesPerView; i < maxIndex; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                        // Prev Slides
                        for (i = minIndex; i < s.activeIndex ; i++) {
                            if (s.slides[i]) s.lazy.loadImageInSlide(i);
                        }
                    }
                    else {
                        var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
                        if (nextSlide.length > 0) s.lazy.loadImageInSlide(nextSlide.index());
        
                        var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
                        if (prevSlide.length > 0) s.lazy.loadImageInSlide(prevSlide.index());
                    }
                }
            },
            onTransitionStart: function () {
                if (s.params.lazyLoading) {
                    if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
                        s.lazy.load();
                    }
                }
            },
            onTransitionEnd: function () {
                if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
                    s.lazy.load();
                }
            }
        };
        

        /*=========================
          Scrollbar
          ===========================*/
        s.scrollbar = {
            isTouched: false,
            setDragPosition: function (e) {
                var sb = s.scrollbar;
                var x = 0, y = 0;
                var translate;
                var pointerPosition = s.isHorizontal() ?
                    ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX) :
                    ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY) ;
                var position = (pointerPosition) - sb.track.offset()[s.isHorizontal() ? 'left' : 'top'] - sb.dragSize / 2;
                var positionMin = -s.minTranslate() * sb.moveDivider;
                var positionMax = -s.maxTranslate() * sb.moveDivider;
                if (position < positionMin) {
                    position = positionMin;
                }
                else if (position > positionMax) {
                    position = positionMax;
                }
                position = -position / sb.moveDivider;
                s.updateProgress(position);
                s.setWrapperTranslate(position, true);
            },
            dragStart: function (e) {
                var sb = s.scrollbar;
                sb.isTouched = true;
                e.preventDefault();
                e.stopPropagation();
        
                sb.setDragPosition(e);
                clearTimeout(sb.dragTimeout);
        
                sb.track.transition(0);
                if (s.params.scrollbarHide) {
                    sb.track.css('opacity', 1);
                }
                s.wrapper.transition(100);
                sb.drag.transition(100);
                s.emit('onScrollbarDragStart', s);
            },
            dragMove: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
                sb.setDragPosition(e);
                s.wrapper.transition(0);
                sb.track.transition(0);
                sb.drag.transition(0);
                s.emit('onScrollbarDragMove', s);
            },
            dragEnd: function (e) {
                var sb = s.scrollbar;
                if (!sb.isTouched) return;
                sb.isTouched = false;
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.dragTimeout);
                    sb.dragTimeout = setTimeout(function () {
                        sb.track.css('opacity', 0);
                        sb.track.transition(400);
                    }, 1000);
        
                }
                s.emit('onScrollbarDragEnd', s);
                if (s.params.scrollbarSnapOnRelease) {
                    s.slideReset();
                }
            },
            draggableEvents: (function () {
                if ((s.params.simulateTouch === false && !s.support.touch)) return s.touchEventsDesktop;
                else return s.touchEvents;
            })(),
            enableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).on(sb.draggableEvents.start, sb.dragStart);
                $(target).on(sb.draggableEvents.move, sb.dragMove);
                $(target).on(sb.draggableEvents.end, sb.dragEnd);
            },
            disableDraggable: function () {
                var sb = s.scrollbar;
                var target = s.support.touch ? sb.track : document;
                $(sb.track).off(s.draggableEvents.start, sb.dragStart);
                $(target).off(s.draggableEvents.move, sb.dragMove);
                $(target).off(s.draggableEvents.end, sb.dragEnd);
            },
            set: function () {
                if (!s.params.scrollbar) return;
                var sb = s.scrollbar;
                sb.track = $(s.params.scrollbar);
                if (s.params.uniqueNavElements && typeof s.params.scrollbar === 'string' && sb.track.length > 1 && s.container.find(s.params.scrollbar).length === 1) {
                    sb.track = s.container.find(s.params.scrollbar);
                }
                sb.drag = sb.track.find('.swiper-scrollbar-drag');
                if (sb.drag.length === 0) {
                    sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
                    sb.track.append(sb.drag);
                }
                sb.drag[0].style.width = '';
                sb.drag[0].style.height = '';
                sb.trackSize = s.isHorizontal() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
        
                sb.divider = s.size / s.virtualSize;
                sb.moveDivider = sb.divider * (sb.trackSize / s.size);
                sb.dragSize = sb.trackSize * sb.divider;
        
                if (s.isHorizontal()) {
                    sb.drag[0].style.width = sb.dragSize + 'px';
                }
                else {
                    sb.drag[0].style.height = sb.dragSize + 'px';
                }
        
                if (sb.divider >= 1) {
                    sb.track[0].style.display = 'none';
                }
                else {
                    sb.track[0].style.display = '';
                }
                if (s.params.scrollbarHide) {
                    sb.track[0].style.opacity = 0;
                }
            },
            setTranslate: function () {
                if (!s.params.scrollbar) return;
                var diff;
                var sb = s.scrollbar;
                var translate = s.translate || 0;
                var newPos;
        
                var newSize = sb.dragSize;
                newPos = (sb.trackSize - sb.dragSize) * s.progress;
                if (s.rtl && s.isHorizontal()) {
                    newPos = -newPos;
                    if (newPos > 0) {
                        newSize = sb.dragSize - newPos;
                        newPos = 0;
                    }
                    else if (-newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize + newPos;
                    }
                }
                else {
                    if (newPos < 0) {
                        newSize = sb.dragSize + newPos;
                        newPos = 0;
                    }
                    else if (newPos + sb.dragSize > sb.trackSize) {
                        newSize = sb.trackSize - newPos;
                    }
                }
                if (s.isHorizontal()) {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
                    }
                    else {
                        sb.drag.transform('translateX(' + (newPos) + 'px)');
                    }
                    sb.drag[0].style.width = newSize + 'px';
                }
                else {
                    if (s.support.transforms3d) {
                        sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
                    }
                    else {
                        sb.drag.transform('translateY(' + (newPos) + 'px)');
                    }
                    sb.drag[0].style.height = newSize + 'px';
                }
                if (s.params.scrollbarHide) {
                    clearTimeout(sb.timeout);
                    sb.track[0].style.opacity = 1;
                    sb.timeout = setTimeout(function () {
                        sb.track[0].style.opacity = 0;
                        sb.track.transition(400);
                    }, 1000);
                }
            },
            setTransition: function (duration) {
                if (!s.params.scrollbar) return;
                s.scrollbar.drag.transition(duration);
            }
        };

        /*=========================
          Controller
          ===========================*/
        s.controller = {
            LinearSpline: function (x, y) {
                this.x = x;
                this.y = y;
                this.lastIndex = x.length - 1;
                // Given an x value (x2), return the expected y2 value:
                // (x1,y1) is the known point before given value,
                // (x3,y3) is the known point after given value.
                var i1, i3;
                var l = this.x.length;
        
                this.interpolate = function (x2) {
                    if (!x2) return 0;
        
                    // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                    i3 = binarySearch(this.x, x2);
                    i1 = i3 - 1;
        
                    // We have our indexes i1 & i3, so we can calculate already:
                    // y2 := ((x2x1)  (y3y1))  (x3x1) + y1
                    return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
                };
        
                var binarySearch = (function() {
                    var maxIndex, minIndex, guess;
                    return function(array, val) {
                        minIndex = -1;
                        maxIndex = array.length;
                        while (maxIndex - minIndex > 1)
                            if (array[guess = maxIndex + minIndex >> 1] <= val) {
                                minIndex = guess;
                            } else {
                                maxIndex = guess;
                            }
                        return maxIndex;
                    };
                })();
            },
            //xxx: for now i will just save one spline function to to
            getInterpolateFunction: function(c){
                if(!s.controller.spline) s.controller.spline = s.params.loop ?
                    new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) :
                    new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
            },
            setTranslate: function (translate, byController) {
               var controlled = s.params.control;
               var multiplier, controlledTranslate;
               function setControlledTranslate(c) {
                    // this will create an Interpolate function based on the snapGrids
                    // x is the Grid of the scrolled scroller and y will be the controlled scroller
                    // it makes sense to create this only once and recall it for the interpolation
                    // the function does a lot of value caching for performance
                    translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
                    if (s.params.controlBy === 'slide') {
                        s.controller.getInterpolateFunction(c);
                        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                        // but it did not work out
                        controlledTranslate = -s.controller.spline.interpolate(-translate);
                    }
        
                    if(!controlledTranslate || s.params.controlBy === 'container'){
                        multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
                        controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
                    }
        
                    if (s.params.controlInverse) {
                        controlledTranslate = c.maxTranslate() - controlledTranslate;
                    }
                    c.updateProgress(controlledTranslate);
                    c.setWrapperTranslate(controlledTranslate, false, s);
                    c.updateActiveIndex();
               }
               if (s.isArray(controlled)) {
                   for (var i = 0; i < controlled.length; i++) {
                       if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                           setControlledTranslate(controlled[i]);
                       }
                   }
               }
               else if (controlled instanceof Swiper && byController !== controlled) {
        
                   setControlledTranslate(controlled);
               }
            },
            setTransition: function (duration, byController) {
                var controlled = s.params.control;
                var i;
                function setControlledTransition(c) {
                    c.setWrapperTransition(duration, s);
                    if (duration !== 0) {
                        c.onTransitionStart();
                        c.wrapper.transitionEnd(function(){
                            if (!controlled) return;
                            if (c.params.loop && s.params.controlBy === 'slide') {
                                c.fixLoop();
                            }
                            c.onTransitionEnd();
        
                        });
                    }
                }
                if (s.isArray(controlled)) {
                    for (i = 0; i < controlled.length; i++) {
                        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                            setControlledTransition(controlled[i]);
                        }
                    }
                }
                else if (controlled instanceof Swiper && byController !== controlled) {
                    setControlledTransition(controlled);
                }
            }
        };

        /*=========================
          Hash Navigation
          ===========================*/
        s.hashnav = {
            onHashCange: function (e, a) {
                var newHash = document.location.hash.replace('#', '');
                var activeSlideHash = s.slides.eq(s.activeIndex).attr('data-hash');
                if (newHash !== activeSlideHash) {
                    s.slideTo(s.wrapper.children('.' + s.params.slideClass + '[data-hash="' + (newHash) + '"]').index());
                }
            },
            attachEvents: function (detach) {
                var action = detach ? 'off' : 'on';
                $(window)[action]('hashchange', s.hashnav.onHashCange);
            },
            setHash: function () {
                if (!s.hashnav.initialized || !s.params.hashnav) return;
                if (s.params.replaceState && window.history && window.history.replaceState) {
                    window.history.replaceState(null, null, ('#' + s.slides.eq(s.activeIndex).attr('data-hash') || ''));
                } else {
                    var slide = s.slides.eq(s.activeIndex);
                    var hash = slide.attr('data-hash') || slide.attr('data-history');
                    document.location.hash = hash || '';
                }
            },
            init: function () {
                if (!s.params.hashnav || s.params.history) return;
                s.hashnav.initialized = true;
                var hash = document.location.hash.replace('#', '');
                if (!hash) return;
                var speed = 0;
                for (var i = 0, length = s.slides.length; i < length; i++) {
                    var slide = s.slides.eq(i);
                    var slideHash = slide.attr('data-hash') || slide.attr('data-history');
                    if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                        var index = slide.index();
                        s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
                    }
                }
                if (s.params.hashnavWatchState) s.hashnav.attachEvents();
            },
            destroy: function () {
                if (s.params.hashnavWatchState) s.hashnav.attachEvents(true);
            }
        };

        /*=========================
          History Api with fallback to Hashnav
          ===========================*/
        s.history = {
            init: function () {
                if (!s.params.history) return;
                if (!window.history || !window.history.pushState) {
                    s.params.history = false;
                    s.params.hashnav = true;
                    return;
                }
                s.history.initialized = true;
                this.paths = this.getPathValues();
                if (!this.paths.key && !this.paths.value) return;
                this.scrollToSlide(0, this.paths.value, s.params.runCallbacksOnInit);
                if (!s.params.replaceState) {
                    window.addEventListener('popstate', this.setHistoryPopState);
                }
            },
            setHistoryPopState: function() {
                s.history.paths = s.history.getPathValues();
                s.history.scrollToSlide(s.params.speed, s.history.paths.value, false);
            },
            getPathValues: function() {
                var pathArray = window.location.pathname.slice(1).split('/');
                var total = pathArray.length;
                var key = pathArray[total - 2];
                var value = pathArray[total - 1];
                return { key: key, value: value };
            },
            setHistory: function (key, index) {
                if (!s.history.initialized || !s.params.history) return;
                var slide = s.slides.eq(index);
                var value = this.slugify(slide.attr('data-history'));
                if (!window.location.pathname.includes(key)) {
                    value = key + '/' + value;
                }
                if (s.params.replaceState) {
                    window.history.replaceState(null, null, value);
                } else {
                    window.history.pushState(null, null, value);
                }
            },
            slugify: function(text) {
                return text.toString().toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/[^\w\-]+/g, '')
                    .replace(/\-\-+/g, '-')
                    .replace(/^-+/, '')
                    .replace(/-+$/, '');
            },
            scrollToSlide: function(speed, value, runCallbacks) {
                if (value) {
                    for (var i = 0, length = s.slides.length; i < length; i++) {
                        var slide = s.slides.eq(i);
                        var slideHistory = this.slugify(slide.attr('data-history'));
                        if (slideHistory === value && !slide.hasClass(s.params.slideDuplicateClass)) {
                            var index = slide.index();
                            s.slideTo(index, speed, runCallbacks);
                        }
                    }
                } else {
                    s.slideTo(0, speed, runCallbacks);
                }
            }
        };

        /*=========================
          Keyboard Control
          ===========================*/
        function handleKeyboard(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var kc = e.keyCode || e.charCode;
            // Directions locks
            if (!s.params.allowSwipeToNext && (s.isHorizontal() && kc === 39 || !s.isHorizontal() && kc === 40)) {
                return false;
            }
            if (!s.params.allowSwipeToPrev && (s.isHorizontal() && kc === 37 || !s.isHorizontal() && kc === 38)) {
                return false;
            }
            if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                return;
            }
            if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
                return;
            }
            if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
                var inView = false;
                //Check that swiper should be inside of visible area of window
                if (s.container.parents('.' + s.params.slideClass).length > 0 && s.container.parents('.' + s.params.slideActiveClass).length === 0) {
                    return;
                }
                var windowScroll = {
                    left: window.pageXOffset,
                    top: window.pageYOffset
                };
                var windowWidth = window.innerWidth;
                var windowHeight = window.innerHeight;
                var swiperOffset = s.container.offset();
                if (s.rtl) swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
                var swiperCoord = [
                    [swiperOffset.left, swiperOffset.top],
                    [swiperOffset.left + s.width, swiperOffset.top],
                    [swiperOffset.left, swiperOffset.top + s.height],
                    [swiperOffset.left + s.width, swiperOffset.top + s.height]
                ];
                for (var i = 0; i < swiperCoord.length; i++) {
                    var point = swiperCoord[i];
                    if (
                        point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth &&
                        point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight
                    ) {
                        inView = true;
                    }
        
                }
                if (!inView) return;
            }
            if (s.isHorizontal()) {
                if (kc === 37 || kc === 39) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl)) s.slideNext();
                if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl)) s.slidePrev();
            }
            else {
                if (kc === 38 || kc === 40) {
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                }
                if (kc === 40) s.slideNext();
                if (kc === 38) s.slidePrev();
            }
        }
        s.disableKeyboardControl = function () {
            s.params.keyboardControl = false;
            $(document).off('keydown', handleKeyboard);
        };
        s.enableKeyboardControl = function () {
            s.params.keyboardControl = true;
            $(document).on('keydown', handleKeyboard);
        };
        

        /*=========================
          Mousewheel Control
          ===========================*/
        s.mousewheel = {
            event: false,
            lastScrollTime: (new window.Date()).getTime()
        };
        if (s.params.mousewheelControl) {
            /**
             * The best combination if you prefer spinX + spinY normalization.  It favors
             * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
             * 'wheel' event, making spin speed determination impossible.
             */
            s.mousewheel.event = (navigator.userAgent.indexOf('firefox') > -1) ?
                'DOMMouseScroll' :
                isEventSupported() ?
                    'wheel' : 'mousewheel';
        }
        
        function isEventSupported() {
            var eventName = 'onwheel';
            var isSupported = eventName in document;
        
            if (!isSupported) {
                var element = document.createElement('div');
                element.setAttribute(eventName, 'return;');
                isSupported = typeof element[eventName] === 'function';
            }
        
            if (!isSupported &&
                document.implementation &&
                document.implementation.hasFeature &&
                    // always returns true in newer browsers as per the standard.
                    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
                document.implementation.hasFeature('', '') !== true ) {
                // This is the only way to test support for the `wheel` event in IE9+.
                isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
            }
        
            return isSupported;
        }
        
        function handleMousewheel(e) {
            if (e.originalEvent) e = e.originalEvent; //jquery fix
            var delta = 0;
            var rtlFactor = s.rtl ? -1 : 1;
        
            var data = normalizeWheel( e );
        
            if (s.params.mousewheelForceToAxis) {
                if (s.isHorizontal()) {
                    if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
                    else return;
                }
                else {
                    if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
                    else return;
                }
            }
            else {
                delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? - data.pixelX * rtlFactor : - data.pixelY;
            }
        
            if (delta === 0) return;
        
            if (s.params.mousewheelInvert) delta = -delta;
        
            if (!s.params.freeMode) {
                if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
                    if (delta < 0) {
                        if ((!s.isEnd || s.params.loop) && !s.animating) {
                            s.slideNext();
                            s.emit('onScroll', s, e);
                        }
                        else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                    else {
                        if ((!s.isBeginning || s.params.loop) && !s.animating) {
                            s.slidePrev();
                            s.emit('onScroll', s, e);
                        }
                        else if (s.params.mousewheelReleaseOnEdges) return true;
                    }
                }
                s.mousewheel.lastScrollTime = (new window.Date()).getTime();
        
            }
            else {
                //Freemode or scrollContainer:
                var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
                var wasBeginning = s.isBeginning,
                    wasEnd = s.isEnd;
        
                if (position >= s.minTranslate()) position = s.minTranslate();
                if (position <= s.maxTranslate()) position = s.maxTranslate();
        
                s.setWrapperTransition(0);
                s.setWrapperTranslate(position);
                s.updateProgress();
                s.updateActiveIndex();
        
                if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
                    s.updateClasses();
                }
        
                if (s.params.freeModeSticky) {
                    clearTimeout(s.mousewheel.timeout);
                    s.mousewheel.timeout = setTimeout(function () {
                        s.slideReset();
                    }, 300);
                }
                else {
                    if (s.params.lazyLoading && s.lazy) {
                        s.lazy.load();
                    }
                }
                // Emit event
                s.emit('onScroll', s, e);
        
                // Stop autoplay
                if (s.params.autoplay && s.params.autoplayDisableOnInteraction) s.stopAutoplay();
        
                // Return page scroll on edge positions
                if (position === 0 || position === s.maxTranslate()) return;
            }
        
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
            return false;
        }
        s.disableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            var target = s.container;
            if (s.params.mousewheelEventsTarged !== 'container') {
                target = $(s.params.mousewheelEventsTarged);
            }
            target.off(s.mousewheel.event, handleMousewheel);
            return true;
        };
        
        s.enableMousewheelControl = function () {
            if (!s.mousewheel.event) return false;
            var target = s.container;
            if (s.params.mousewheelEventsTarged !== 'container') {
                target = $(s.params.mousewheelEventsTarged);
            }
            target.on(s.mousewheel.event, handleMousewheel);
            return true;
        };
        
        /**
         * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
         * complicated, thus this doc is long and (hopefully) detailed enough to answer
         * your questions.
         *
         * If you need to react to the mouse wheel in a predictable way, this code is
         * like your bestest friend. * hugs *
         *
         * As of today, there are 4 DOM event types you can listen to:
         *
         *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
         *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
         *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
         *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
         *
         * So what to do?  The is the best:
         *
         *   normalizeWheel.getEventType();
         *
         * In your event callback, use this code to get sane interpretation of the
         * deltas.  This code will return an object with properties:
         *
         *   spinX   -- normalized spin speed (use for zoom) - x plane
         *   spinY   -- " - y plane
         *   pixelX  -- normalized distance (to pixels) - x plane
         *   pixelY  -- " - y plane
         *
         * Wheel values are provided by the browser assuming you are using the wheel to
         * scroll a web page by a number of lines or pixels (or pages).  Values can vary
         * significantly on different platforms and browsers, forgetting that you can
         * scroll at different speeds.  Some devices (like trackpads) emit more events
         * at smaller increments with fine granularity, and some emit massive jumps with
         * linear speed or acceleration.
         *
         * This code does its best to normalize the deltas for you:
         *
         *   - spin is trying to normalize how far the wheel was spun (or trackpad
         *     dragged).  This is super useful for zoom support where you want to
         *     throw away the chunky scroll steps on the PC and make those equal to
         *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
         *     resolve a single slow step on a wheel to 1.
         *
         *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
         *     get the crazy differences between browsers, but at least it'll be in
         *     pixels!
         *
         *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
         *     should translate to positive value zooming IN, negative zooming OUT.
         *     This matches the newer 'wheel' event.
         *
         * Why are there spinX, spinY (or pixels)?
         *
         *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
         *     with a mouse.  It results in side-scrolling in the browser by default.
         *
         *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
         *
         *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
         *     probably is by browsers in conjunction with fancy 3D controllers .. but
         *     you know.
         *
         * Implementation info:
         *
         * Examples of 'wheel' event if you scroll slowly (down) by one step with an
         * average mouse:
         *
         *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
         *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
         *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
         *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
         *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
         *
         * On the trackpad:
         *
         *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
         *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
         *
         * On other/older browsers.. it's more complicated as there can be multiple and
         * also missing delta values.
         *
         * The 'wheel' event is more standard:
         *
         * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
         *
         * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
         * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
         * backward compatibility with older events.  Those other values help us
         * better normalize spin speed.  Example of what the browsers provide:
         *
         *                          | event.wheelDelta | event.detail
         *        ------------------+------------------+--------------
         *          Safari v5/OS X  |       -120       |       0
         *          Safari v5/Win7  |       -120       |       0
         *         Chrome v17/OS X  |       -120       |       0
         *         Chrome v17/Win7  |       -120       |       0
         *                IE9/Win7  |       -120       |   undefined
         *         Firefox v4/OS X  |     undefined    |       1
         *         Firefox v4/Win7  |     undefined    |       3
         *
         */
        function normalizeWheel( /*object*/ event ) /*object*/ {
            // Reasonable defaults
            var PIXEL_STEP = 10;
            var LINE_HEIGHT = 40;
            var PAGE_HEIGHT = 800;
        
            var sX = 0, sY = 0,       // spinX, spinY
                pX = 0, pY = 0;       // pixelX, pixelY
        
            // Legacy
            if( 'detail' in event ) {
                sY = event.detail;
            }
            if( 'wheelDelta' in event ) {
                sY = -event.wheelDelta / 120;
            }
            if( 'wheelDeltaY' in event ) {
                sY = -event.wheelDeltaY / 120;
            }
            if( 'wheelDeltaX' in event ) {
                sX = -event.wheelDeltaX / 120;
            }
        
            // side scrolling on FF with DOMMouseScroll
            if( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
                sX = sY;
                sY = 0;
            }
        
            pX = sX * PIXEL_STEP;
            pY = sY * PIXEL_STEP;
        
            if( 'deltaY' in event ) {
                pY = event.deltaY;
            }
            if( 'deltaX' in event ) {
                pX = event.deltaX;
            }
        
            if( (pX || pY) && event.deltaMode ) {
                if( event.deltaMode === 1 ) {          // delta in LINE units
                    pX *= LINE_HEIGHT;
                    pY *= LINE_HEIGHT;
                } else {                             // delta in PAGE units
                    pX *= PAGE_HEIGHT;
                    pY *= PAGE_HEIGHT;
                }
            }
        
            // Fall-back if spin cannot be determined
            if( pX && !sX ) {
                sX = (pX < 1) ? -1 : 1;
            }
            if( pY && !sY ) {
                sY = (pY < 1) ? -1 : 1;
            }
        
            return {
                spinX: sX,
                spinY: sY,
                pixelX: pX,
                pixelY: pY
            };
        }

        /*=========================
          Parallax
          ===========================*/
        function setParallaxTransform(el, progress) {
            el = $(el);
            var p, pX, pY;
            var rtlFactor = s.rtl ? -1 : 1;
        
            p = el.attr('data-swiper-parallax') || '0';
            pX = el.attr('data-swiper-parallax-x');
            pY = el.attr('data-swiper-parallax-y');
            if (pX || pY) {
                pX = pX || '0';
                pY = pY || '0';
            }
            else {
                if (s.isHorizontal()) {
                    pX = p;
                    pY = '0';
                }
                else {
                    pY = p;
                    pX = '0';
                }
            }
        
            if ((pX).indexOf('%') >= 0) {
                pX = parseInt(pX, 10) * progress * rtlFactor + '%';
            }
            else {
                pX = pX * progress * rtlFactor + 'px' ;
            }
            if ((pY).indexOf('%') >= 0) {
                pY = parseInt(pY, 10) * progress + '%';
            }
            else {
                pY = pY * progress + 'px' ;
            }
        
            el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
        }
        s.parallax = {
            setTranslate: function () {
                s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
                    setParallaxTransform(this, s.progress);
        
                });
                s.slides.each(function () {
                    var slide = $(this);
                    slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function () {
                        var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                        setParallaxTransform(this, progress);
                    });
                });
            },
            setTransition: function (duration) {
                if (typeof duration === 'undefined') duration = s.params.speed;
                s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function(){
                    var el = $(this);
                    var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
                    if (duration === 0) parallaxDuration = 0;
                    el.transition(parallaxDuration);
                });
            }
        };
        

        /*=========================
          Zoom
          ===========================*/
        s.zoom = {
            // "Global" Props
            scale: 1,
            currentScale: 1,
            isScaling: false,
            gesture: {
                slide: undefined,
                slideWidth: undefined,
                slideHeight: undefined,
                image: undefined,
                imageWrap: undefined,
                zoomMax: s.params.zoomMax
            },
            image: {
                isTouched: undefined,
                isMoved: undefined,
                currentX: undefined,
                currentY: undefined,
                minX: undefined,
                minY: undefined,
                maxX: undefined,
                maxY: undefined,
                width: undefined,
                height: undefined,
                startX: undefined,
                startY: undefined,
                touchesStart: {},
                touchesCurrent: {}
            },
            velocity: {
                x: undefined,
                y: undefined,
                prevPositionX: undefined,
                prevPositionY: undefined,
                prevTime: undefined
            },
            // Calc Scale From Multi-touches
            getDistanceBetweenTouches: function (e) {
                if (e.targetTouches.length < 2) return 1;
                var x1 = e.targetTouches[0].pageX,
                    y1 = e.targetTouches[0].pageY,
                    x2 = e.targetTouches[1].pageX,
                    y2 = e.targetTouches[1].pageY;
                var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                return distance;
            },
            // Events
            onGestureStart: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
                        return;
                    }
                    z.gesture.scaleStart = z.getDistanceBetweenTouches(e);
                }
                if (!z.gesture.slide || !z.gesture.slide.length) {
                    z.gesture.slide = $(this);
                    if (z.gesture.slide.length === 0) z.gesture.slide = s.slides.eq(s.activeIndex);
                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
                    z.gesture.zoomMax = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax ;
                    if (z.gesture.imageWrap.length === 0) {
                        z.gesture.image = undefined;
                        return;
                    }
                }
                z.gesture.image.transition(0);
                z.isScaling = true;
            },
            onGestureChange: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
                        return;
                    }
                    z.gesture.scaleMove = z.getDistanceBetweenTouches(e);
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (s.support.gestures) {
                    z.scale = e.scale * z.currentScale;
                }
                else {
                    z.scale = (z.gesture.scaleMove / z.gesture.scaleStart) * z.currentScale;
                }
                if (z.scale > z.gesture.zoomMax) {
                    z.scale = z.gesture.zoomMax - 1 + Math.pow((z.scale - z.gesture.zoomMax + 1), 0.5);
                }
                if (z.scale < s.params.zoomMin) {
                    z.scale =  s.params.zoomMin + 1 - Math.pow((s.params.zoomMin - z.scale + 1), 0.5);
                }
                z.gesture.image.transform('translate3d(0,0,0) scale(' + z.scale + ')');
            },
            onGestureEnd: function (e) {
                var z = s.zoom;
                if (!s.support.gestures) {
                    if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2) {
                        return;
                    }
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                z.scale = Math.max(Math.min(z.scale, z.gesture.zoomMax), s.params.zoomMin);
                z.gesture.image.transition(s.params.speed).transform('translate3d(0,0,0) scale(' + z.scale + ')');
                z.currentScale = z.scale;
                z.isScaling = false;
                if (z.scale === 1) z.gesture.slide = undefined;
            },
            onTouchStart: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (z.image.isTouched) return;
                if (s.device.os === 'android') e.preventDefault();
                z.image.isTouched = true;
                z.image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
                z.image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
            },
            onTouchMove: function (e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                s.allowClick = false;
                if (!z.image.isTouched || !z.gesture.slide) return;
        
                if (!z.image.isMoved) {
                    z.image.width = z.gesture.image[0].offsetWidth;
                    z.image.height = z.gesture.image[0].offsetHeight;
                    z.image.startX = s.getTranslate(z.gesture.imageWrap[0], 'x') || 0;
                    z.image.startY = s.getTranslate(z.gesture.imageWrap[0], 'y') || 0;
                    z.gesture.slideWidth = z.gesture.slide[0].offsetWidth;
                    z.gesture.slideHeight = z.gesture.slide[0].offsetHeight;
                    z.gesture.imageWrap.transition(0);
                }
                // Define if we need image drag
                var scaledWidth = z.image.width * z.scale;
                var scaledHeight = z.image.height * z.scale;
        
                if (scaledWidth < z.gesture.slideWidth && scaledHeight < z.gesture.slideHeight) return;
        
                z.image.minX = Math.min((z.gesture.slideWidth / 2 - scaledWidth / 2), 0);
                z.image.maxX = -z.image.minX;
                z.image.minY = Math.min((z.gesture.slideHeight / 2 - scaledHeight / 2), 0);
                z.image.maxY = -z.image.minY;
        
                z.image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
                z.image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        
                if (!z.image.isMoved && !z.isScaling) {
                    if (s.isHorizontal() &&
                        (Math.floor(z.image.minX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x < z.image.touchesStart.x) ||
                        (Math.floor(z.image.maxX) === Math.floor(z.image.startX) && z.image.touchesCurrent.x > z.image.touchesStart.x)
                        ) {
                        z.image.isTouched = false;
                        return;
                    }
                    else if (!s.isHorizontal() &&
                        (Math.floor(z.image.minY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y < z.image.touchesStart.y) ||
                        (Math.floor(z.image.maxY) === Math.floor(z.image.startY) && z.image.touchesCurrent.y > z.image.touchesStart.y)
                        ) {
                        z.image.isTouched = false;
                        return;
                    }
                }
                e.preventDefault();
                e.stopPropagation();
        
                z.image.isMoved = true;
                z.image.currentX = z.image.touchesCurrent.x - z.image.touchesStart.x + z.image.startX;
                z.image.currentY = z.image.touchesCurrent.y - z.image.touchesStart.y + z.image.startY;
        
                if (z.image.currentX < z.image.minX) {
                    z.image.currentX =  z.image.minX + 1 - Math.pow((z.image.minX - z.image.currentX + 1), 0.8);
                }
                if (z.image.currentX > z.image.maxX) {
                    z.image.currentX = z.image.maxX - 1 + Math.pow((z.image.currentX - z.image.maxX + 1), 0.8);
                }
        
                if (z.image.currentY < z.image.minY) {
                    z.image.currentY =  z.image.minY + 1 - Math.pow((z.image.minY - z.image.currentY + 1), 0.8);
                }
                if (z.image.currentY > z.image.maxY) {
                    z.image.currentY = z.image.maxY - 1 + Math.pow((z.image.currentY - z.image.maxY + 1), 0.8);
                }
        
                //Velocity
                if (!z.velocity.prevPositionX) z.velocity.prevPositionX = z.image.touchesCurrent.x;
                if (!z.velocity.prevPositionY) z.velocity.prevPositionY = z.image.touchesCurrent.y;
                if (!z.velocity.prevTime) z.velocity.prevTime = Date.now();
                z.velocity.x = (z.image.touchesCurrent.x - z.velocity.prevPositionX) / (Date.now() - z.velocity.prevTime) / 2;
                z.velocity.y = (z.image.touchesCurrent.y - z.velocity.prevPositionY) / (Date.now() - z.velocity.prevTime) / 2;
                if (Math.abs(z.image.touchesCurrent.x - z.velocity.prevPositionX) < 2) z.velocity.x = 0;
                if (Math.abs(z.image.touchesCurrent.y - z.velocity.prevPositionY) < 2) z.velocity.y = 0;
                z.velocity.prevPositionX = z.image.touchesCurrent.x;
                z.velocity.prevPositionY = z.image.touchesCurrent.y;
                z.velocity.prevTime = Date.now();
        
                z.gesture.imageWrap.transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
            },
            onTouchEnd: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.image || z.gesture.image.length === 0) return;
                if (!z.image.isTouched || !z.image.isMoved) {
                    z.image.isTouched = false;
                    z.image.isMoved = false;
                    return;
                }
                z.image.isTouched = false;
                z.image.isMoved = false;
                var momentumDurationX = 300;
                var momentumDurationY = 300;
                var momentumDistanceX = z.velocity.x * momentumDurationX;
                var newPositionX = z.image.currentX + momentumDistanceX;
                var momentumDistanceY = z.velocity.y * momentumDurationY;
                var newPositionY = z.image.currentY + momentumDistanceY;
        
                //Fix duration
                if (z.velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - z.image.currentX) / z.velocity.x);
                if (z.velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - z.image.currentY) / z.velocity.y);
                var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        
                z.image.currentX = newPositionX;
                z.image.currentY = newPositionY;
        
                // Define if we need image drag
                var scaledWidth = z.image.width * z.scale;
                var scaledHeight = z.image.height * z.scale;
                z.image.minX = Math.min((z.gesture.slideWidth / 2 - scaledWidth / 2), 0);
                z.image.maxX = -z.image.minX;
                z.image.minY = Math.min((z.gesture.slideHeight / 2 - scaledHeight / 2), 0);
                z.image.maxY = -z.image.minY;
                z.image.currentX = Math.max(Math.min(z.image.currentX, z.image.maxX), z.image.minX);
                z.image.currentY = Math.max(Math.min(z.image.currentY, z.image.maxY), z.image.minY);
        
                z.gesture.imageWrap.transition(momentumDuration).transform('translate3d(' + z.image.currentX + 'px, ' + z.image.currentY + 'px,0)');
            },
            onTransitionEnd: function (s) {
                var z = s.zoom;
                if (z.gesture.slide && s.previousIndex !== s.activeIndex) {
                    z.gesture.image.transform('translate3d(0,0,0) scale(1)');
                    z.gesture.imageWrap.transform('translate3d(0,0,0)');
                    z.gesture.slide = z.gesture.image = z.gesture.imageWrap = undefined;
                    z.scale = z.currentScale = 1;
                }
            },
            // Toggle Zoom
            toggleZoom: function (s, e) {
                var z = s.zoom;
                if (!z.gesture.slide) {
                    z.gesture.slide = s.clickedSlide ? $(s.clickedSlide) : s.slides.eq(s.activeIndex);
                    z.gesture.image = z.gesture.slide.find('img, svg, canvas');
                    z.gesture.imageWrap = z.gesture.image.parent('.' + s.params.zoomContainerClass);
                }
                if (!z.gesture.image || z.gesture.image.length === 0) return;
        
                var touchX, touchY, offsetX, offsetY, diffX, diffY, translateX, translateY, imageWidth, imageHeight, scaledWidth, scaledHeight, translateMinX, translateMinY, translateMaxX, translateMaxY, slideWidth, slideHeight;
        
                if (typeof z.image.touchesStart.x === 'undefined' && e) {
                    touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
                    touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
                }
                else {
                    touchX = z.image.touchesStart.x;
                    touchY = z.image.touchesStart.y;
                }
        
                if (z.scale && z.scale !== 1) {
                    // Zoom Out
                    z.scale = z.currentScale = 1;
                    z.gesture.imageWrap.transition(300).transform('translate3d(0,0,0)');
                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(1)');
                    z.gesture.slide = undefined;
                }
                else {
                    // Zoom In
                    z.scale = z.currentScale = z.gesture.imageWrap.attr('data-swiper-zoom') || s.params.zoomMax;
                    if (e) {
                        slideWidth = z.gesture.slide[0].offsetWidth;
                        slideHeight = z.gesture.slide[0].offsetHeight;
                        offsetX = z.gesture.slide.offset().left;
                        offsetY = z.gesture.slide.offset().top;
                        diffX = offsetX + slideWidth/2 - touchX;
                        diffY = offsetY + slideHeight/2 - touchY;
        
                        imageWidth = z.gesture.image[0].offsetWidth;
                        imageHeight = z.gesture.image[0].offsetHeight;
                        scaledWidth = imageWidth * z.scale;
                        scaledHeight = imageHeight * z.scale;
        
                        translateMinX = Math.min((slideWidth / 2 - scaledWidth / 2), 0);
                        translateMinY = Math.min((slideHeight / 2 - scaledHeight / 2), 0);
                        translateMaxX = -translateMinX;
                        translateMaxY = -translateMinY;
        
                        translateX = diffX * z.scale;
                        translateY = diffY * z.scale;
        
                        if (translateX < translateMinX) {
                            translateX =  translateMinX;
                        }
                        if (translateX > translateMaxX) {
                            translateX = translateMaxX;
                        }
        
                        if (translateY < translateMinY) {
                            translateY =  translateMinY;
                        }
                        if (translateY > translateMaxY) {
                            translateY = translateMaxY;
                        }
                    }
                    else {
                        translateX = 0;
                        translateY = 0;
                    }
                    z.gesture.imageWrap.transition(300).transform('translate3d(' + translateX + 'px, ' + translateY + 'px,0)');
                    z.gesture.image.transition(300).transform('translate3d(0,0,0) scale(' + z.scale + ')');
                }
            },
            // Attach/Detach Events
            attachEvents: function (detach) {
                var action = detach ? 'off' : 'on';
        
                if (s.params.zoom) {
                    var target = s.slides;
                    var passiveListener = s.touchEvents.start === 'touchstart' && s.support.passiveListener && s.params.passiveListeners ? {passive: true, capture: false} : false;
                    // Scale image
                    if (s.support.gestures) {
                        s.slides[action]('gesturestart', s.zoom.onGestureStart, passiveListener);
                        s.slides[action]('gesturechange', s.zoom.onGestureChange, passiveListener);
                        s.slides[action]('gestureend', s.zoom.onGestureEnd, passiveListener);
                    }
                    else if (s.touchEvents.start === 'touchstart') {
                        s.slides[action](s.touchEvents.start, s.zoom.onGestureStart, passiveListener);
                        s.slides[action](s.touchEvents.move, s.zoom.onGestureChange, passiveListener);
                        s.slides[action](s.touchEvents.end, s.zoom.onGestureEnd, passiveListener);
                    }
        
                    // Move image
                    s[action]('touchStart', s.zoom.onTouchStart);
                    s.slides.each(function (index, slide){
                        if ($(slide).find('.' + s.params.zoomContainerClass).length > 0) {
                            $(slide)[action](s.touchEvents.move, s.zoom.onTouchMove);
                        }
                    });
                    s[action]('touchEnd', s.zoom.onTouchEnd);
        
                    // Scale Out
                    s[action]('transitionEnd', s.zoom.onTransitionEnd);
                    if (s.params.zoomToggle) {
                        s.on('doubleTap', s.zoom.toggleZoom);
                    }
                }
            },
            init: function () {
                s.zoom.attachEvents();
            },
            destroy: function () {
                s.zoom.attachEvents(true);
            }
        };

        /*=========================
          Plugins API. Collect all and init all plugins
          ===========================*/
        s._plugins = [];
        for (var plugin in s.plugins) {
            var p = s.plugins[plugin](s, s.params[plugin]);
            if (p) s._plugins.push(p);
        }
        // Method to call all plugins event/method
        s.callPlugins = function (eventName) {
            for (var i = 0; i < s._plugins.length; i++) {
                if (eventName in s._plugins[i]) {
                    s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
        };

        /*=========================
          Events/Callbacks/Plugins Emitter
          ===========================*/
        function normalizeEventName (eventName) {
            if (eventName.indexOf('on') !== 0) {
                if (eventName[0] !== eventName[0].toUpperCase()) {
                    eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
                }
                else {
                    eventName = 'on' + eventName;
                }
            }
            return eventName;
        }
        s.emitterEventListeners = {
        
        };
        s.emit = function (eventName) {
            // Trigger callbacks
            if (s.params[eventName]) {
                s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
            var i;
            // Trigger events
            if (s.emitterEventListeners[eventName]) {
                for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                    s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                }
            }
            // Trigger plugins
            if (s.callPlugins) s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        };
        s.on = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            if (!s.emitterEventListeners[eventName]) s.emitterEventListeners[eventName] = [];
            s.emitterEventListeners[eventName].push(handler);
            return s;
        };
        s.off = function (eventName, handler) {
            var i;
            eventName = normalizeEventName(eventName);
            if (typeof handler === 'undefined') {
                // Remove all handlers for such event
                s.emitterEventListeners[eventName] = [];
                return s;
            }
            if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0) return;
            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
                if(s.emitterEventListeners[eventName][i] === handler) s.emitterEventListeners[eventName].splice(i, 1);
            }
            return s;
        };
        s.once = function (eventName, handler) {
            eventName = normalizeEventName(eventName);
            var _handler = function () {
                handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
                s.off(eventName, _handler);
            };
            s.on(eventName, _handler);
            return s;
        };

        // Accessibility tools
        s.a11y = {
            makeFocusable: function ($el) {
                $el.attr('tabIndex', '0');
                return $el;
            },
            addRole: function ($el, role) {
                $el.attr('role', role);
                return $el;
            },
        
            addLabel: function ($el, label) {
                $el.attr('aria-label', label);
                return $el;
            },
        
            disable: function ($el) {
                $el.attr('aria-disabled', true);
                return $el;
            },
        
            enable: function ($el) {
                $el.attr('aria-disabled', false);
                return $el;
            },
        
            onEnterKey: function (event) {
                if (event.keyCode !== 13) return;
                if ($(event.target).is(s.params.nextButton)) {
                    s.onClickNext(event);
                    if (s.isEnd) {
                        s.a11y.notify(s.params.lastSlideMessage);
                    }
                    else {
                        s.a11y.notify(s.params.nextSlideMessage);
                    }
                }
                else if ($(event.target).is(s.params.prevButton)) {
                    s.onClickPrev(event);
                    if (s.isBeginning) {
                        s.a11y.notify(s.params.firstSlideMessage);
                    }
                    else {
                        s.a11y.notify(s.params.prevSlideMessage);
                    }
                }
                if ($(event.target).is('.' + s.params.bulletClass)) {
                    $(event.target)[0].click();
                }
            },
        
            liveRegion: $('<span class="' + s.params.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>'),
        
            notify: function (message) {
                var notification = s.a11y.liveRegion;
                if (notification.length === 0) return;
                notification.html('');
                notification.html(message);
            },
            init: function () {
                // Setup accessibility
                if (s.params.nextButton && s.nextButton && s.nextButton.length > 0) {
                    s.a11y.makeFocusable(s.nextButton);
                    s.a11y.addRole(s.nextButton, 'button');
                    s.a11y.addLabel(s.nextButton, s.params.nextSlideMessage);
                }
                if (s.params.prevButton && s.prevButton && s.prevButton.length > 0) {
                    s.a11y.makeFocusable(s.prevButton);
                    s.a11y.addRole(s.prevButton, 'button');
                    s.a11y.addLabel(s.prevButton, s.params.prevSlideMessage);
                }
        
                $(s.container).append(s.a11y.liveRegion);
            },
            initPagination: function () {
                if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
                    s.bullets.each(function () {
                        var bullet = $(this);
                        s.a11y.makeFocusable(bullet);
                        s.a11y.addRole(bullet, 'button');
                        s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
                    });
                }
            },
            destroy: function () {
                if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0) s.a11y.liveRegion.remove();
            }
        };
        

        /*=========================
          Init/Destroy
          ===========================*/
        s.init = function () {
            if (s.params.loop) s.createLoop();
            s.updateContainerSize();
            s.updateSlidesSize();
            s.updatePagination();
            if (s.params.scrollbar && s.scrollbar) {
                s.scrollbar.set();
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.enableDraggable();
                }
            }
            if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
                if (!s.params.loop) s.updateProgress();
                s.effects[s.params.effect].setTranslate();
            }
            if (s.params.loop) {
                s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
            }
            else {
                s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
                if (s.params.initialSlide === 0) {
                    if (s.parallax && s.params.parallax) s.parallax.setTranslate();
                    if (s.lazy && s.params.lazyLoading) {
                        s.lazy.load();
                        s.lazy.initialImageLoaded = true;
                    }
                }
            }
            s.attachEvents();
            if (s.params.observer && s.support.observer) {
                s.initObservers();
            }
            if (s.params.preloadImages && !s.params.lazyLoading) {
                s.preloadImages();
            }
            if (s.params.zoom && s.zoom) {
                s.zoom.init();
            }
            if (s.params.autoplay) {
                s.startAutoplay();
            }
            if (s.params.keyboardControl) {
                if (s.enableKeyboardControl) s.enableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.enableMousewheelControl) s.enableMousewheelControl();
            }
            // Deprecated hashnavReplaceState changed to replaceState for use in hashnav and history
            if (s.params.hashnavReplaceState) {
                s.params.replaceState = s.params.hashnavReplaceState;
            }
            if (s.params.history) {
                if (s.history) s.history.init();
            }
            if (s.params.hashnav) {
                if (s.hashnav) s.hashnav.init();
            }
            if (s.params.a11y && s.a11y) s.a11y.init();
            s.emit('onInit', s);
        };
        
        // Cleanup dynamic styles
        s.cleanupStyles = function () {
            // Container
            s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
        
            // Wrapper
            s.wrapper.removeAttr('style');
        
            // Slides
            if (s.slides && s.slides.length) {
                s.slides
                    .removeClass([
                      s.params.slideVisibleClass,
                      s.params.slideActiveClass,
                      s.params.slideNextClass,
                      s.params.slidePrevClass
                    ].join(' '))
                    .removeAttr('style')
                    .removeAttr('data-swiper-column')
                    .removeAttr('data-swiper-row');
            }
        
            // Pagination/Bullets
            if (s.paginationContainer && s.paginationContainer.length) {
                s.paginationContainer.removeClass(s.params.paginationHiddenClass);
            }
            if (s.bullets && s.bullets.length) {
                s.bullets.removeClass(s.params.bulletActiveClass);
            }
        
            // Buttons
            if (s.params.prevButton) $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
            if (s.params.nextButton) $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
        
            // Scrollbar
            if (s.params.scrollbar && s.scrollbar) {
                if (s.scrollbar.track && s.scrollbar.track.length) s.scrollbar.track.removeAttr('style');
                if (s.scrollbar.drag && s.scrollbar.drag.length) s.scrollbar.drag.removeAttr('style');
            }
        };
        
        // Destroy
        s.destroy = function (deleteInstance, cleanupStyles) {
            // Detach evebts
            s.detachEvents();
            // Stop autoplay
            s.stopAutoplay();
            // Disable draggable
            if (s.params.scrollbar && s.scrollbar) {
                if (s.params.scrollbarDraggable) {
                    s.scrollbar.disableDraggable();
                }
            }
            // Destroy loop
            if (s.params.loop) {
                s.destroyLoop();
            }
            // Cleanup styles
            if (cleanupStyles) {
                s.cleanupStyles();
            }
            // Disconnect observer
            s.disconnectObservers();
        
            // Destroy zoom
            if (s.params.zoom && s.zoom) {
                s.zoom.destroy();
            }
            // Disable keyboard/mousewheel
            if (s.params.keyboardControl) {
                if (s.disableKeyboardControl) s.disableKeyboardControl();
            }
            if (s.params.mousewheelControl) {
                if (s.disableMousewheelControl) s.disableMousewheelControl();
            }
            // Disable a11y
            if (s.params.a11y && s.a11y) s.a11y.destroy();
            // Delete history popstate
            if (s.params.history && !s.params.replaceState) {
                window.removeEventListener('popstate', s.history.setHistoryPopState);
            }
            if (s.params.hashnav && s.hashnav)  {
                s.hashnav.destroy();
            }
            // Destroy callback
            s.emit('onDestroy');
            // Delete instance
            if (deleteInstance !== false) s = null;
        };
        
        s.init();
        

    
        // Return swiper instance
        return s;
    };
    

    /*==================================================
        Prototype
    ====================================================*/
    Swiper.prototype = {
        isSafari: (function () {
            var ua = navigator.userAgent.toLowerCase();
            return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
        })(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
        isArray: function (arr) {
            return Object.prototype.toString.apply(arr) === '[object Array]';
        },
        /*==================================================
        Browser
        ====================================================*/
        browser: {
            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1),
            lteIE9: (function() {
                // create temporary DIV
                var div = document.createElement('div');
                // add content to tmp DIV which is wrapped into the IE HTML conditional statement
                div.innerHTML = '<!--[if lte IE 9]><i></i><![endif]-->';
                // return true / false value based on what will browser render
                return div.getElementsByTagName('i').length === 1;
            })()
        },
        /*==================================================
        Devices
        ====================================================*/
        device: (function () {
            var ua = navigator.userAgent;
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
            return {
                ios: ipad || iphone || ipod,
                android: android
            };
        })(),
        /*==================================================
        Feature Detection
        ====================================================*/
        support: {
            touch : (window.Modernizr && Modernizr.touch === true) || (function () {
                return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
            })(),
    
            transforms3d : (window.Modernizr && Modernizr.csstransforms3d === true) || (function () {
                var div = document.createElement('div').style;
                return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
            })(),
    
            flexbox: (function () {
                var div = document.createElement('div').style;
                var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
                for (var i = 0; i < styles.length; i++) {
                    if (styles[i] in div) return true;
                }
            })(),
    
            observer: (function () {
                return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
            })(),
    
            passiveListener: (function () {
                var supportsPassive = false;
                try {
                    var opts = Object.defineProperty({}, 'passive', {
                        get: function() {
                            supportsPassive = true;
                        }
                    });
                    window.addEventListener('testPassiveListener', null, opts);
                } catch (e) {}
                return supportsPassive;
            })(),
    
            gestures: (function () {
                return 'ongesturestart' in window;
            })()
        },
        /*==================================================
        Plugins
        ====================================================*/
        plugins: {}
    };
    

    /*===========================
    Dom7 Library
    ===========================*/
    var Dom7 = (function () {
        var Dom7 = function (arr) {
            var _this = this, i = 0;
            // Create array-like object
            for (i = 0; i < arr.length; i++) {
                _this[i] = arr[i];
            }
            _this.length = arr.length;
            // Return collection with methods
            return this;
        };
        var $ = function (selector, context) {
            var arr = [], i = 0;
            if (selector && !context) {
                if (selector instanceof Dom7) {
                    return selector;
                }
            }
            if (selector) {
                // String
                if (typeof selector === 'string') {
                    var els, tempParent, html = selector.trim();
                    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                        var toCreate = 'div';
                        if (html.indexOf('<li') === 0) toCreate = 'ul';
                        if (html.indexOf('<tr') === 0) toCreate = 'tbody';
                        if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
                        if (html.indexOf('<tbody') === 0) toCreate = 'table';
                        if (html.indexOf('<option') === 0) toCreate = 'select';
                        tempParent = document.createElement(toCreate);
                        tempParent.innerHTML = selector;
                        for (i = 0; i < tempParent.childNodes.length; i++) {
                            arr.push(tempParent.childNodes[i]);
                        }
                    }
                    else {
                        if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                            // Pure ID selector
                            els = [document.getElementById(selector.split('#')[1])];
                        }
                        else {
                            // Other selectors
                            els = (context || document).querySelectorAll(selector);
                        }
                        for (i = 0; i < els.length; i++) {
                            if (els[i]) arr.push(els[i]);
                        }
                    }
                }
                // Node/element
                else if (selector.nodeType || selector === window || selector === document) {
                    arr.push(selector);
                }
                //Array of elements or instance of Dom
                else if (selector.length > 0 && selector[0].nodeType) {
                    for (i = 0; i < selector.length; i++) {
                        arr.push(selector[i]);
                    }
                }
            }
            return new Dom7(arr);
        };
        Dom7.prototype = {
            // Classes and attriutes
            addClass: function (className) {
                if (typeof className === 'undefined') {
                    return this;
                }
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.add(classes[i]);
                    }
                }
                return this;
            },
            removeClass: function (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.remove(classes[i]);
                    }
                }
                return this;
            },
            hasClass: function (className) {
                if (!this[0]) return false;
                else return this[0].classList.contains(className);
            },
            toggleClass: function (className) {
                var classes = className.split(' ');
                for (var i = 0; i < classes.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        this[j].classList.toggle(classes[i]);
                    }
                }
                return this;
            },
            attr: function (attrs, value) {
                if (arguments.length === 1 && typeof attrs === 'string') {
                    // Get attr
                    if (this[0]) return this[0].getAttribute(attrs);
                    else return undefined;
                }
                else {
                    // Set attrs
                    for (var i = 0; i < this.length; i++) {
                        if (arguments.length === 2) {
                            // String
                            this[i].setAttribute(attrs, value);
                        }
                        else {
                            // Object
                            for (var attrName in attrs) {
                                this[i][attrName] = attrs[attrName];
                                this[i].setAttribute(attrName, attrs[attrName]);
                            }
                        }
                    }
                    return this;
                }
            },
            removeAttr: function (attr) {
                for (var i = 0; i < this.length; i++) {
                    this[i].removeAttribute(attr);
                }
                return this;
            },
            data: function (key, value) {
                if (typeof value === 'undefined') {
                    // Get value
                    if (this[0]) {
                        var dataKey = this[0].getAttribute('data-' + key);
                        if (dataKey) return dataKey;
                        else if (this[0].dom7ElementDataStorage && (key in this[0].dom7ElementDataStorage)) return this[0].dom7ElementDataStorage[key];
                        else return undefined;
                    }
                    else return undefined;
                }
                else {
                    // Set value
                    for (var i = 0; i < this.length; i++) {
                        var el = this[i];
                        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
                        el.dom7ElementDataStorage[key] = value;
                    }
                    return this;
                }
            },
            // Transforms
            transform : function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            },
            transition: function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            },
            //Events
            on: function (eventName, targetSelector, listener, capture) {
                function handleLiveEvent(e) {
                    var target = e.target;
                    if ($(target).is(targetSelector)) listener.call(target, e);
                    else {
                        var parents = $(target).parents();
                        for (var k = 0; k < parents.length; k++) {
                            if ($(parents[k]).is(targetSelector)) listener.call(parents[k], e);
                        }
                    }
                }
                var events = eventName.split(' ');
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof targetSelector === 'function' || targetSelector === false) {
                        // Usual events
                        if (typeof targetSelector === 'function') {
                            listener = arguments[1];
                            capture = arguments[2] || false;
                        }
                        for (j = 0; j < events.length; j++) {
                            this[i].addEventListener(events[j], listener, capture);
                        }
                    }
                    else {
                        //Live events
                        for (j = 0; j < events.length; j++) {
                            if (!this[i].dom7LiveListeners) this[i].dom7LiveListeners = [];
                            this[i].dom7LiveListeners.push({listener: listener, liveListener: handleLiveEvent});
                            this[i].addEventListener(events[j], handleLiveEvent, capture);
                        }
                    }
                }
    
                return this;
            },
            off: function (eventName, targetSelector, listener, capture) {
                var events = eventName.split(' ');
                for (var i = 0; i < events.length; i++) {
                    for (var j = 0; j < this.length; j++) {
                        if (typeof targetSelector === 'function' || targetSelector === false) {
                            // Usual events
                            if (typeof targetSelector === 'function') {
                                listener = arguments[1];
                                capture = arguments[2] || false;
                            }
                            this[j].removeEventListener(events[i], listener, capture);
                        }
                        else {
                            // Live event
                            if (this[j].dom7LiveListeners) {
                                for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
                                    if (this[j].dom7LiveListeners[k].listener === listener) {
                                        this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                                    }
                                }
                            }
                        }
                    }
                }
                return this;
            },
            once: function (eventName, targetSelector, listener, capture) {
                var dom = this;
                if (typeof targetSelector === 'function') {
                    targetSelector = false;
                    listener = arguments[1];
                    capture = arguments[2];
                }
                function proxy(e) {
                    listener(e);
                    dom.off(eventName, targetSelector, proxy, capture);
                }
                dom.on(eventName, targetSelector, proxy, capture);
            },
            trigger: function (eventName, eventData) {
                for (var i = 0; i < this.length; i++) {
                    var evt;
                    try {
                        evt = new window.CustomEvent(eventName, {detail: eventData, bubbles: true, cancelable: true});
                    }
                    catch (e) {
                        evt = document.createEvent('Event');
                        evt.initEvent(eventName, true, true);
                        evt.detail = eventData;
                    }
                    this[i].dispatchEvent(evt);
                }
                return this;
            },
            transitionEnd: function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i, j, dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            },
            // Sizing/Styles
            width: function () {
                if (this[0] === window) {
                    return window.innerWidth;
                }
                else {
                    if (this.length > 0) {
                        return parseFloat(this.css('width'));
                    }
                    else {
                        return null;
                    }
                }
            },
            outerWidth: function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins)
                        return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
                    else
                        return this[0].offsetWidth;
                }
                else return null;
            },
            height: function () {
                if (this[0] === window) {
                    return window.innerHeight;
                }
                else {
                    if (this.length > 0) {
                        return parseFloat(this.css('height'));
                    }
                    else {
                        return null;
                    }
                }
            },
            outerHeight: function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins)
                        return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));
                    else
                        return this[0].offsetHeight;
                }
                else return null;
            },
            offset: function () {
                if (this.length > 0) {
                    var el = this[0];
                    var box = el.getBoundingClientRect();
                    var body = document.body;
                    var clientTop  = el.clientTop  || body.clientTop  || 0;
                    var clientLeft = el.clientLeft || body.clientLeft || 0;
                    var scrollTop  = window.pageYOffset || el.scrollTop;
                    var scrollLeft = window.pageXOffset || el.scrollLeft;
                    return {
                        top: box.top  + scrollTop  - clientTop,
                        left: box.left + scrollLeft - clientLeft
                    };
                }
                else {
                    return null;
                }
            },
            css: function (props, value) {
                var i;
                if (arguments.length === 1) {
                    if (typeof props === 'string') {
                        if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
                    }
                    else {
                        for (i = 0; i < this.length; i++) {
                            for (var prop in props) {
                                this[i].style[prop] = props[prop];
                            }
                        }
                        return this;
                    }
                }
                if (arguments.length === 2 && typeof props === 'string') {
                    for (i = 0; i < this.length; i++) {
                        this[i].style[props] = value;
                    }
                    return this;
                }
                return this;
            },
    
            //Dom manipulation
            each: function (callback) {
                for (var i = 0; i < this.length; i++) {
                    callback.call(this[i], i, this[i]);
                }
                return this;
            },
            html: function (html) {
                if (typeof html === 'undefined') {
                    return this[0] ? this[0].innerHTML : undefined;
                }
                else {
                    for (var i = 0; i < this.length; i++) {
                        this[i].innerHTML = html;
                    }
                    return this;
                }
            },
            text: function (text) {
                if (typeof text === 'undefined') {
                    if (this[0]) {
                        return this[0].textContent.trim();
                    }
                    else return null;
                }
                else {
                    for (var i = 0; i < this.length; i++) {
                        this[i].textContent = text;
                    }
                    return this;
                }
            },
            is: function (selector) {
                if (!this[0]) return false;
                var compareWith, i;
                if (typeof selector === 'string') {
                    var el = this[0];
                    if (el === document) return selector === document;
                    if (el === window) return selector === window;
    
                    if (el.matches) return el.matches(selector);
                    else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
                    else if (el.mozMatchesSelector) return el.mozMatchesSelector(selector);
                    else if (el.msMatchesSelector) return el.msMatchesSelector(selector);
                    else {
                        compareWith = $(selector);
                        for (i = 0; i < compareWith.length; i++) {
                            if (compareWith[i] === this[0]) return true;
                        }
                        return false;
                    }
                }
                else if (selector === document) return this[0] === document;
                else if (selector === window) return this[0] === window;
                else {
                    if (selector.nodeType || selector instanceof Dom7) {
                        compareWith = selector.nodeType ? [selector] : selector;
                        for (i = 0; i < compareWith.length; i++) {
                            if (compareWith[i] === this[0]) return true;
                        }
                        return false;
                    }
                    return false;
                }
    
            },
            index: function () {
                if (this[0]) {
                    var child = this[0];
                    var i = 0;
                    while ((child = child.previousSibling) !== null) {
                        if (child.nodeType === 1) i++;
                    }
                    return i;
                }
                else return undefined;
            },
            eq: function (index) {
                if (typeof index === 'undefined') return this;
                var length = this.length;
                var returnIndex;
                if (index > length - 1) {
                    return new Dom7([]);
                }
                if (index < 0) {
                    returnIndex = length + index;
                    if (returnIndex < 0) return new Dom7([]);
                    else return new Dom7([this[returnIndex]]);
                }
                return new Dom7([this[index]]);
            },
            append: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof newChild === 'string') {
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newChild;
                        while (tempDiv.firstChild) {
                            this[i].appendChild(tempDiv.firstChild);
                        }
                    }
                    else if (newChild instanceof Dom7) {
                        for (j = 0; j < newChild.length; j++) {
                            this[i].appendChild(newChild[j]);
                        }
                    }
                    else {
                        this[i].appendChild(newChild);
                    }
                }
                return this;
            },
            prepend: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++) {
                    if (typeof newChild === 'string') {
                        var tempDiv = document.createElement('div');
                        tempDiv.innerHTML = newChild;
                        for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                        }
                        // this[i].insertAdjacentHTML('afterbegin', newChild);
                    }
                    else if (newChild instanceof Dom7) {
                        for (j = 0; j < newChild.length; j++) {
                            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                        }
                    }
                    else {
                        this[i].insertBefore(newChild, this[i].childNodes[0]);
                    }
                }
                return this;
            },
            insertBefore: function (selector) {
                var before = $(selector);
                for (var i = 0; i < this.length; i++) {
                    if (before.length === 1) {
                        before[0].parentNode.insertBefore(this[i], before[0]);
                    }
                    else if (before.length > 1) {
                        for (var j = 0; j < before.length; j++) {
                            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                        }
                    }
                }
            },
            insertAfter: function (selector) {
                var after = $(selector);
                for (var i = 0; i < this.length; i++) {
                    if (after.length === 1) {
                        after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
                    }
                    else if (after.length > 1) {
                        for (var j = 0; j < after.length; j++) {
                            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                        }
                    }
                }
            },
            next: function (selector) {
                if (this.length > 0) {
                    if (selector) {
                        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) return new Dom7([this[0].nextElementSibling]);
                        else return new Dom7([]);
                    }
                    else {
                        if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
                        else return new Dom7([]);
                    }
                }
                else return new Dom7([]);
            },
            nextAll: function (selector) {
                var nextEls = [];
                var el = this[0];
                if (!el) return new Dom7([]);
                while (el.nextElementSibling) {
                    var next = el.nextElementSibling;
                    if (selector) {
                        if($(next).is(selector)) nextEls.push(next);
                    }
                    else nextEls.push(next);
                    el = next;
                }
                return new Dom7(nextEls);
            },
            prev: function (selector) {
                if (this.length > 0) {
                    if (selector) {
                        if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) return new Dom7([this[0].previousElementSibling]);
                        else return new Dom7([]);
                    }
                    else {
                        if (this[0].previousElementSibling) return new Dom7([this[0].previousElementSibling]);
                        else return new Dom7([]);
                    }
                }
                else return new Dom7([]);
            },
            prevAll: function (selector) {
                var prevEls = [];
                var el = this[0];
                if (!el) return new Dom7([]);
                while (el.previousElementSibling) {
                    var prev = el.previousElementSibling;
                    if (selector) {
                        if($(prev).is(selector)) prevEls.push(prev);
                    }
                    else prevEls.push(prev);
                    el = prev;
                }
                return new Dom7(prevEls);
            },
            parent: function (selector) {
                var parents = [];
                for (var i = 0; i < this.length; i++) {
                    if (selector) {
                        if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
                    }
                    else {
                        parents.push(this[i].parentNode);
                    }
                }
                return $($.unique(parents));
            },
            parents: function (selector) {
                var parents = [];
                for (var i = 0; i < this.length; i++) {
                    var parent = this[i].parentNode;
                    while (parent) {
                        if (selector) {
                            if ($(parent).is(selector)) parents.push(parent);
                        }
                        else {
                            parents.push(parent);
                        }
                        parent = parent.parentNode;
                    }
                }
                return $($.unique(parents));
            },
            find : function (selector) {
                var foundElements = [];
                for (var i = 0; i < this.length; i++) {
                    var found = this[i].querySelectorAll(selector);
                    for (var j = 0; j < found.length; j++) {
                        foundElements.push(found[j]);
                    }
                }
                return new Dom7(foundElements);
            },
            children: function (selector) {
                var children = [];
                for (var i = 0; i < this.length; i++) {
                    var childNodes = this[i].childNodes;
    
                    for (var j = 0; j < childNodes.length; j++) {
                        if (!selector) {
                            if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
                        }
                        else {
                            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) children.push(childNodes[j]);
                        }
                    }
                }
                return new Dom7($.unique(children));
            },
            remove: function () {
                for (var i = 0; i < this.length; i++) {
                    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
                }
                return this;
            },
            add: function () {
                var dom = this;
                var i, j;
                for (i = 0; i < arguments.length; i++) {
                    var toAdd = $(arguments[i]);
                    for (j = 0; j < toAdd.length; j++) {
                        dom[dom.length] = toAdd[j];
                        dom.length++;
                    }
                }
                return dom;
            }
        };
        $.fn = Dom7.prototype;
        $.unique = function (arr) {
            var unique = [];
            for (var i = 0; i < arr.length; i++) {
                if (unique.indexOf(arr[i]) === -1) unique.push(arr[i]);
            }
            return unique;
        };
    
        return $;
    })();
    

    /*===========================
     Get Dom libraries
     ===========================*/
    var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
    for (var i = 0; i < swiperDomPlugins.length; i++) {
    	if (window[swiperDomPlugins[i]]) {
    		addLibraryPlugin(window[swiperDomPlugins[i]]);
    	}
    }
    // Required DOM Plugins
    var domLib;
    if (typeof Dom7 === 'undefined') {
    	domLib = window.Dom7 || window.Zepto || window.jQuery;
    }
    else {
    	domLib = Dom7;
    }

    /*===========================
    Add .swiper plugin from Dom libraries
    ===========================*/
    function addLibraryPlugin(lib) {
        lib.fn.swiper = function (params) {
            var firstInstance;
            lib(this).each(function () {
                var s = new Swiper(this, params);
                if (!firstInstance) firstInstance = s;
            });
            return firstInstance;
        };
    }
    
    if (domLib) {
        if (!('transitionEnd' in domLib.fn)) {
            domLib.fn.transitionEnd = function (callback) {
                var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                    i, j, dom = this;
                function fireCallBack(e) {
                    /*jshint validthis:true */
                    if (e.target !== this) return;
                    callback.call(this, e);
                    for (i = 0; i < events.length; i++) {
                        dom.off(events[i], fireCallBack);
                    }
                }
                if (callback) {
                    for (i = 0; i < events.length; i++) {
                        dom.on(events[i], fireCallBack);
                    }
                }
                return this;
            };
        }
        if (!('transform' in domLib.fn)) {
            domLib.fn.transform = function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
                }
                return this;
            };
        }
        if (!('transition' in domLib.fn)) {
            domLib.fn.transition = function (duration) {
                if (typeof duration !== 'string') {
                    duration = duration + 'ms';
                }
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
                }
                return this;
            };
        }
        if (!('outerWidth' in domLib.fn)) {
            domLib.fn.outerWidth = function (includeMargins) {
                if (this.length > 0) {
                    if (includeMargins)
                        return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
                    else
                        return this[0].offsetWidth;
                }
                else return null;
            };
        }
    }

    window.Swiper = Swiper;
})();
/*===========================
Swiper AMD Export
===========================*/
if (typeof(module) !== 'undefined')
{
    module.exports = window.Swiper;
}
else if (typeof define === 'function' && define.amd) {
    define([], function () {
        'use strict';
        return window.Swiper;
    });
}
//# sourceMappingURL=maps/swiper.js.map

/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
  if ( typeof define === "function" && define.amd ) {

    // AMD. Register as an anonymous module.
    define([ "jquery" ], factory );
  } else {

    // Browser globals
    factory( jQuery );
  }
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
  return function( elems ) {
    var events, elem, i;
    for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
      try {

        // Only trigger remove when necessary to save time
        events = $._data( elem, "events" );
        if ( events && events.remove ) {
          $( elem ).triggerHandler( "remove" );
        }

      // Http://bugs.jquery.com/ticket/8235
      } catch ( e ) {}
    }
    orig( elems );
  };
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
  var existingConstructor, constructor, basePrototype;

  // ProxiedPrototype allows the provided prototype to remain unmodified
  // so that it can be used as a mixin for multiple widgets (#8876)
  var proxiedPrototype = {};

  var namespace = name.split( "." )[ 0 ];
  name = name.split( "." )[ 1 ];
  var fullName = namespace + "-" + name;

  if ( !prototype ) {
    prototype = base;
    base = $.Widget;
  }

  if ( $.isArray( prototype ) ) {
    prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
  }

  // Create selector for plugin
  $.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
    return !!$.data( elem, fullName );
  };

  $[ namespace ] = $[ namespace ] || {};
  existingConstructor = $[ namespace ][ name ];
  constructor = $[ namespace ][ name ] = function( options, element ) {

    // Allow instantiation without "new" keyword
    if ( !this._createWidget ) {
      return new constructor( options, element );
    }

    // Allow instantiation without initializing for simple inheritance
    // must use "new" keyword (the code above always passes args)
    if ( arguments.length ) {
      this._createWidget( options, element );
    }
  };

  // Extend with the existing constructor to carry over any static properties
  $.extend( constructor, existingConstructor, {
    version: prototype.version,

    // Copy the object used to create the prototype in case we need to
    // redefine the widget later
    _proto: $.extend( {}, prototype ),

    // Track widgets that inherit from this widget in case this widget is
    // redefined after a widget inherits from it
    _childConstructors: []
  } );

  basePrototype = new base();

  // We need to make the options hash a property directly on the new instance
  // otherwise we'll modify the options hash on the prototype that we're
  // inheriting from
  basePrototype.options = $.widget.extend( {}, basePrototype.options );
  $.each( prototype, function( prop, value ) {
    if ( !$.isFunction( value ) ) {
      proxiedPrototype[ prop ] = value;
      return;
    }
    proxiedPrototype[ prop ] = ( function() {
      function _super() {
        return base.prototype[ prop ].apply( this, arguments );
      }

      function _superApply( args ) {
        return base.prototype[ prop ].apply( this, args );
      }

      return function() {
        var __super = this._super;
        var __superApply = this._superApply;
        var returnValue;

        this._super = _super;
        this._superApply = _superApply;

        returnValue = value.apply( this, arguments );

        this._super = __super;
        this._superApply = __superApply;

        return returnValue;
      };
    } )();
  } );
  constructor.prototype = $.widget.extend( basePrototype, {

    // TODO: remove support for widgetEventPrefix
    // always use the name + a colon as the prefix, e.g., draggable:start
    // don't prefix for widgets that aren't DOM-based
    widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
  }, proxiedPrototype, {
    constructor: constructor,
    namespace: namespace,
    widgetName: name,
    widgetFullName: fullName
  } );

  // If this widget is being redefined then we need to find all widgets that
  // are inheriting from it and redefine all of them so that they inherit from
  // the new version of this widget. We're essentially trying to replace one
  // level in the prototype chain.
  if ( existingConstructor ) {
    $.each( existingConstructor._childConstructors, function( i, child ) {
      var childPrototype = child.prototype;

      // Redefine the child widget using the same prototype that was
      // originally used, but inherit from the new version of the base
      $.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
        child._proto );
    } );

    // Remove the list of existing child constructors from the old constructor
    // so the old child constructors can be garbage collected
    delete existingConstructor._childConstructors;
  } else {
    base._childConstructors.push( constructor );
  }

  $.widget.bridge( name, constructor );

  return constructor;
};

$.widget.extend = function( target ) {
  var input = widgetSlice.call( arguments, 1 );
  var inputIndex = 0;
  var inputLength = input.length;
  var key;
  var value;

  for ( ; inputIndex < inputLength; inputIndex++ ) {
    for ( key in input[ inputIndex ] ) {
      value = input[ inputIndex ][ key ];
      if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

        // Clone objects
        if ( $.isPlainObject( value ) ) {
          target[ key ] = $.isPlainObject( target[ key ] ) ?
            $.widget.extend( {}, target[ key ], value ) :

            // Don't extend strings, arrays, etc. with objects
            $.widget.extend( {}, value );

        // Copy everything else by reference
        } else {
          target[ key ] = value;
        }
      }
    }
  }
  return target;
};

$.widget.bridge = function( name, object ) {
  var fullName = object.prototype.widgetFullName || name;
  $.fn[ name ] = function( options ) {
    var isMethodCall = typeof options === "string";
    var args = widgetSlice.call( arguments, 1 );
    var returnValue = this;

    if ( isMethodCall ) {

      // If this is an empty collection, we need to have the instance method
      // return undefined instead of the jQuery instance
      if ( !this.length && options === "instance" ) {
        returnValue = undefined;
      } else {
        this.each( function() {
          var methodValue;
          var instance = $.data( this, fullName );

          if ( options === "instance" ) {
            returnValue = instance;
            return false;
          }

          if ( !instance ) {
            return $.error( "cannot call methods on " + name +
              " prior to initialization; " +
              "attempted to call method '" + options + "'" );
          }

          if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
            return $.error( "no such method '" + options + "' for " + name +
              " widget instance" );
          }

          methodValue = instance[ options ].apply( instance, args );

          if ( methodValue !== instance && methodValue !== undefined ) {
            returnValue = methodValue && methodValue.jquery ?
              returnValue.pushStack( methodValue.get() ) :
              methodValue;
            return false;
          }
        } );
      }
    } else {

      // Allow multiple hashes to be passed on init
      if ( args.length ) {
        options = $.widget.extend.apply( null, [ options ].concat( args ) );
      }

      this.each( function() {
        var instance = $.data( this, fullName );
        if ( instance ) {
          instance.option( options || {} );
          if ( instance._init ) {
            instance._init();
          }
        } else {
          $.data( this, fullName, new object( options, this ) );
        }
      } );
    }

    return returnValue;
  };
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
  widgetName: "widget",
  widgetEventPrefix: "",
  defaultElement: "<div>",

  options: {
    classes: {},
    disabled: false,

    // Callbacks
    create: null
  },

  _createWidget: function( options, element ) {
    element = $( element || this.defaultElement || this )[ 0 ];
    this.element = $( element );
    this.uuid = widgetUuid++;
    this.eventNamespace = "." + this.widgetName + this.uuid;

    this.bindings = $();
    this.hoverable = $();
    this.focusable = $();
    this.classesElementLookup = {};

    if ( element !== this ) {
      $.data( element, this.widgetFullName, this );
      this._on( true, this.element, {
        remove: function( event ) {
          if ( event.target === element ) {
            this.destroy();
          }
        }
      } );
      this.document = $( element.style ?

        // Element within the document
        element.ownerDocument :

        // Element is window or document
        element.document || element );
      this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
    }

    this.options = $.widget.extend( {},
      this.options,
      this._getCreateOptions(),
      options );

    this._create();

    if ( this.options.disabled ) {
      this._setOptionDisabled( this.options.disabled );
    }

    this._trigger( "create", null, this._getCreateEventData() );
    this._init();
  },

  _getCreateOptions: function() {
    return {};
  },

  _getCreateEventData: $.noop,

  _create: $.noop,

  _init: $.noop,

  destroy: function() {
    var that = this;

    this._destroy();
    $.each( this.classesElementLookup, function( key, value ) {
      that._removeClass( value, key );
    } );

    // We can probably remove the unbind calls in 2.0
    // all event bindings should go through this._on()
    this.element
      .off( this.eventNamespace )
      .removeData( this.widgetFullName );
    this.widget()
      .off( this.eventNamespace )
      .removeAttr( "aria-disabled" );

    // Clean up events and states
    this.bindings.off( this.eventNamespace );
  },

  _destroy: $.noop,

  widget: function() {
    return this.element;
  },

  option: function( key, value ) {
    var options = key;
    var parts;
    var curOption;
    var i;

    if ( arguments.length === 0 ) {

      // Don't return a reference to the internal hash
      return $.widget.extend( {}, this.options );
    }

    if ( typeof key === "string" ) {

      // Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
      options = {};
      parts = key.split( "." );
      key = parts.shift();
      if ( parts.length ) {
        curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
        for ( i = 0; i < parts.length - 1; i++ ) {
          curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
          curOption = curOption[ parts[ i ] ];
        }
        key = parts.pop();
        if ( arguments.length === 1 ) {
          return curOption[ key ] === undefined ? null : curOption[ key ];
        }
        curOption[ key ] = value;
      } else {
        if ( arguments.length === 1 ) {
          return this.options[ key ] === undefined ? null : this.options[ key ];
        }
        options[ key ] = value;
      }
    }

    this._setOptions( options );

    return this;
  },

  _setOptions: function( options ) {
    var key;

    for ( key in options ) {
      this._setOption( key, options[ key ] );
    }

    return this;
  },

  _setOption: function( key, value ) {
    if ( key === "classes" ) {
      this._setOptionClasses( value );
    }

    this.options[ key ] = value;

    if ( key === "disabled" ) {
      this._setOptionDisabled( value );
    }

    return this;
  },

  _setOptionClasses: function( value ) {
    var classKey, elements, currentElements;

    for ( classKey in value ) {
      currentElements = this.classesElementLookup[ classKey ];
      if ( value[ classKey ] === this.options.classes[ classKey ] ||
          !currentElements ||
          !currentElements.length ) {
        continue;
      }

      // We are doing this to create a new jQuery object because the _removeClass() call
      // on the next line is going to destroy the reference to the current elements being
      // tracked. We need to save a copy of this collection so that we can add the new classes
      // below.
      elements = $( currentElements.get() );
      this._removeClass( currentElements, classKey );

      // We don't use _addClass() here, because that uses this.options.classes
      // for generating the string of classes. We want to use the value passed in from
      // _setOption(), this is the new value of the classes option which was passed to
      // _setOption(). We pass this value directly to _classes().
      elements.addClass( this._classes( {
        element: elements,
        keys: classKey,
        classes: value,
        add: true
      } ) );
    }
  },

  _setOptionDisabled: function( value ) {
    this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

    // If the widget is becoming disabled, then nothing is interactive
    if ( value ) {
      this._removeClass( this.hoverable, null, "ui-state-hover" );
      this._removeClass( this.focusable, null, "ui-state-focus" );
    }
  },

  enable: function() {
    return this._setOptions( { disabled: false } );
  },

  disable: function() {
    return this._setOptions( { disabled: true } );
  },

  _classes: function( options ) {
    var full = [];
    var that = this;

    options = $.extend( {
      element: this.element,
      classes: this.options.classes || {}
    }, options );

    function processClassString( classes, checkOption ) {
      var current, i;
      for ( i = 0; i < classes.length; i++ ) {
        current = that.classesElementLookup[ classes[ i ] ] || $();
        if ( options.add ) {
          current = $( $.unique( current.get().concat( options.element.get() ) ) );
        } else {
          current = $( current.not( options.element ).get() );
        }
        that.classesElementLookup[ classes[ i ] ] = current;
        full.push( classes[ i ] );
        if ( checkOption && options.classes[ classes[ i ] ] ) {
          full.push( options.classes[ classes[ i ] ] );
        }
      }
    }

    this._on( options.element, {
      "remove": "_untrackClassesElement"
    } );

    if ( options.keys ) {
      processClassString( options.keys.match( /\S+/g ) || [], true );
    }
    if ( options.extra ) {
      processClassString( options.extra.match( /\S+/g ) || [] );
    }

    return full.join( " " );
  },

  _untrackClassesElement: function( event ) {
    var that = this;
    $.each( that.classesElementLookup, function( key, value ) {
      if ( $.inArray( event.target, value ) !== -1 ) {
        that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
      }
    } );
  },

  _removeClass: function( element, keys, extra ) {
    return this._toggleClass( element, keys, extra, false );
  },

  _addClass: function( element, keys, extra ) {
    return this._toggleClass( element, keys, extra, true );
  },

  _toggleClass: function( element, keys, extra, add ) {
    add = ( typeof add === "boolean" ) ? add : extra;
    var shift = ( typeof element === "string" || element === null ),
      options = {
        extra: shift ? keys : extra,
        keys: shift ? element : keys,
        element: shift ? this.element : element,
        add: add
      };
    options.element.toggleClass( this._classes( options ), add );
    return this;
  },

  _on: function( suppressDisabledCheck, element, handlers ) {
    var delegateElement;
    var instance = this;

    // No suppressDisabledCheck flag, shuffle arguments
    if ( typeof suppressDisabledCheck !== "boolean" ) {
      handlers = element;
      element = suppressDisabledCheck;
      suppressDisabledCheck = false;
    }

    // No element argument, shuffle and use this.element
    if ( !handlers ) {
      handlers = element;
      element = this.element;
      delegateElement = this.widget();
    } else {
      element = delegateElement = $( element );
      this.bindings = this.bindings.add( element );
    }

    $.each( handlers, function( event, handler ) {
      function handlerProxy() {

        // Allow widgets to customize the disabled handling
        // - disabled as an array instead of boolean
        // - disabled class as method for disabling individual parts
        if ( !suppressDisabledCheck &&
            ( instance.options.disabled === true ||
            $( this ).hasClass( "ui-state-disabled" ) ) ) {
          return;
        }
        return ( typeof handler === "string" ? instance[ handler ] : handler )
          .apply( instance, arguments );
      }

      // Copy the guid so direct unbinding works
      if ( typeof handler !== "string" ) {
        handlerProxy.guid = handler.guid =
          handler.guid || handlerProxy.guid || $.guid++;
      }

      var match = event.match( /^([\w:-]*)\s*(.*)$/ );
      var eventName = match[ 1 ] + instance.eventNamespace;
      var selector = match[ 2 ];

      if ( selector ) {
        delegateElement.on( eventName, selector, handlerProxy );
      } else {
        element.on( eventName, handlerProxy );
      }
    } );
  },

  _off: function( element, eventName ) {
    eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
      this.eventNamespace;
    element.off( eventName ).off( eventName );

    // Clear the stack to avoid memory leaks (#10056)
    this.bindings = $( this.bindings.not( element ).get() );
    this.focusable = $( this.focusable.not( element ).get() );
    this.hoverable = $( this.hoverable.not( element ).get() );
  },

  _delay: function( handler, delay ) {
    function handlerProxy() {
      return ( typeof handler === "string" ? instance[ handler ] : handler )
        .apply( instance, arguments );
    }
    var instance = this;
    return setTimeout( handlerProxy, delay || 0 );
  },

  _hoverable: function( element ) {
    this.hoverable = this.hoverable.add( element );
    this._on( element, {
      mouseenter: function( event ) {
        this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
      },
      mouseleave: function( event ) {
        this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
      }
    } );
  },

  _focusable: function( element ) {
    this.focusable = this.focusable.add( element );
    this._on( element, {
      focusin: function( event ) {
        this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
      },
      focusout: function( event ) {
        this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
      }
    } );
  },

  _trigger: function( type, event, data ) {
    var prop, orig;
    var callback = this.options[ type ];

    data = data || {};
    event = $.Event( event );
    event.type = ( type === this.widgetEventPrefix ?
      type :
      this.widgetEventPrefix + type ).toLowerCase();

    // The original event may come from any element
    // so we need to reset the target on the new event
    event.target = this.element[ 0 ];

    // Copy original event properties over to the new event
    orig = event.originalEvent;
    if ( orig ) {
      for ( prop in orig ) {
        if ( !( prop in event ) ) {
          event[ prop ] = orig[ prop ];
        }
      }
    }

    this.element.trigger( event, data );
    return !( $.isFunction( callback ) &&
      callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
      event.isDefaultPrevented() );
  }
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
  $.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
    if ( typeof options === "string" ) {
      options = { effect: options };
    }

    var hasOptions;
    var effectName = !options ?
      method :
      options === true || typeof options === "number" ?
        defaultEffect :
        options.effect || defaultEffect;

    options = options || {};
    if ( typeof options === "number" ) {
      options = { duration: options };
    }

    hasOptions = !$.isEmptyObject( options );
    options.complete = callback;

    if ( options.delay ) {
      element.delay( options.delay );
    }

    if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
      element[ method ]( options );
    } else if ( effectName !== method && element[ effectName ] ) {
      element[ effectName ]( options.duration, options.easing, callback );
    } else {
      element.queue( function( next ) {
        $( this )[ method ]();
        if ( callback ) {
          callback.call( element[ 0 ] );
        }
        next();
      } );
    }
  };
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
  max = Math.max,
  abs = Math.abs,
  rhorizontal = /left|center|right/,
  rvertical = /top|center|bottom/,
  roffset = /[\+\-]\d+(\.[\d]+)?%?/,
  rposition = /^\w+/,
  rpercent = /%$/,
  _position = $.fn.position;

function getOffsets( offsets, width, height ) {
  return [
    parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
    parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
  ];
}

function parseCss( element, property ) {
  return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
  var raw = elem[ 0 ];
  if ( raw.nodeType === 9 ) {
    return {
      width: elem.width(),
      height: elem.height(),
      offset: { top: 0, left: 0 }
    };
  }
  if ( $.isWindow( raw ) ) {
    return {
      width: elem.width(),
      height: elem.height(),
      offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
    };
  }
  if ( raw.preventDefault ) {
    return {
      width: 0,
      height: 0,
      offset: { top: raw.pageY, left: raw.pageX }
    };
  }
  return {
    width: elem.outerWidth(),
    height: elem.outerHeight(),
    offset: elem.offset()
  };
}

$.position = {
  scrollbarWidth: function() {
    if ( cachedScrollbarWidth !== undefined ) {
      return cachedScrollbarWidth;
    }
    var w1, w2,
      div = $( "<div " +
        "style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
        "<div style='height:100px;width:auto;'></div></div>" ),
      innerDiv = div.children()[ 0 ];

    $( "body" ).append( div );
    w1 = innerDiv.offsetWidth;
    div.css( "overflow", "scroll" );

    w2 = innerDiv.offsetWidth;

    if ( w1 === w2 ) {
      w2 = div[ 0 ].clientWidth;
    }

    div.remove();

    return ( cachedScrollbarWidth = w1 - w2 );
  },
  getScrollInfo: function( within ) {
    var overflowX = within.isWindow || within.isDocument ? "" :
        within.element.css( "overflow-x" ),
      overflowY = within.isWindow || within.isDocument ? "" :
        within.element.css( "overflow-y" ),
      hasOverflowX = overflowX === "scroll" ||
        ( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
      hasOverflowY = overflowY === "scroll" ||
        ( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
    return {
      width: hasOverflowY ? $.position.scrollbarWidth() : 0,
      height: hasOverflowX ? $.position.scrollbarWidth() : 0
    };
  },
  getWithinInfo: function( element ) {
    var withinElement = $( element || window ),
      isWindow = $.isWindow( withinElement[ 0 ] ),
      isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
      hasOffset = !isWindow && !isDocument;
    return {
      element: withinElement,
      isWindow: isWindow,
      isDocument: isDocument,
      offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
      scrollLeft: withinElement.scrollLeft(),
      scrollTop: withinElement.scrollTop(),
      width: withinElement.outerWidth(),
      height: withinElement.outerHeight()
    };
  }
};

$.fn.position = function( options ) {
  if ( !options || !options.of ) {
    return _position.apply( this, arguments );
  }

  // Make a copy, we don't want to modify arguments
  options = $.extend( {}, options );

  var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
    target = $( options.of ),
    within = $.position.getWithinInfo( options.within ),
    scrollInfo = $.position.getScrollInfo( within ),
    collision = ( options.collision || "flip" ).split( " " ),
    offsets = {};

  dimensions = getDimensions( target );
  if ( target[ 0 ].preventDefault ) {

    // Force left top to allow flipping
    options.at = "left top";
  }
  targetWidth = dimensions.width;
  targetHeight = dimensions.height;
  targetOffset = dimensions.offset;

  // Clone to reuse original targetOffset later
  basePosition = $.extend( {}, targetOffset );

  // Force my and at to have valid horizontal and vertical positions
  // if a value is missing or invalid, it will be converted to center
  $.each( [ "my", "at" ], function() {
    var pos = ( options[ this ] || "" ).split( " " ),
      horizontalOffset,
      verticalOffset;

    if ( pos.length === 1 ) {
      pos = rhorizontal.test( pos[ 0 ] ) ?
        pos.concat( [ "center" ] ) :
        rvertical.test( pos[ 0 ] ) ?
          [ "center" ].concat( pos ) :
          [ "center", "center" ];
    }
    pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
    pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

    // Calculate offsets
    horizontalOffset = roffset.exec( pos[ 0 ] );
    verticalOffset = roffset.exec( pos[ 1 ] );
    offsets[ this ] = [
      horizontalOffset ? horizontalOffset[ 0 ] : 0,
      verticalOffset ? verticalOffset[ 0 ] : 0
    ];

    // Reduce to just the positions without the offsets
    options[ this ] = [
      rposition.exec( pos[ 0 ] )[ 0 ],
      rposition.exec( pos[ 1 ] )[ 0 ]
    ];
  } );

  // Normalize collision option
  if ( collision.length === 1 ) {
    collision[ 1 ] = collision[ 0 ];
  }

  if ( options.at[ 0 ] === "right" ) {
    basePosition.left += targetWidth;
  } else if ( options.at[ 0 ] === "center" ) {
    basePosition.left += targetWidth / 2;
  }

  if ( options.at[ 1 ] === "bottom" ) {
    basePosition.top += targetHeight;
  } else if ( options.at[ 1 ] === "center" ) {
    basePosition.top += targetHeight / 2;
  }

  atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
  basePosition.left += atOffset[ 0 ];
  basePosition.top += atOffset[ 1 ];

  return this.each( function() {
    var collisionPosition, using,
      elem = $( this ),
      elemWidth = elem.outerWidth(),
      elemHeight = elem.outerHeight(),
      marginLeft = parseCss( this, "marginLeft" ),
      marginTop = parseCss( this, "marginTop" ),
      collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
        scrollInfo.width,
      collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
        scrollInfo.height,
      position = $.extend( {}, basePosition ),
      myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

    if ( options.my[ 0 ] === "right" ) {
      position.left -= elemWidth;
    } else if ( options.my[ 0 ] === "center" ) {
      position.left -= elemWidth / 2;
    }

    if ( options.my[ 1 ] === "bottom" ) {
      position.top -= elemHeight;
    } else if ( options.my[ 1 ] === "center" ) {
      position.top -= elemHeight / 2;
    }

    position.left += myOffset[ 0 ];
    position.top += myOffset[ 1 ];

    collisionPosition = {
      marginLeft: marginLeft,
      marginTop: marginTop
    };

    $.each( [ "left", "top" ], function( i, dir ) {
      if ( $.ui.position[ collision[ i ] ] ) {
        $.ui.position[ collision[ i ] ][ dir ]( position, {
          targetWidth: targetWidth,
          targetHeight: targetHeight,
          elemWidth: elemWidth,
          elemHeight: elemHeight,
          collisionPosition: collisionPosition,
          collisionWidth: collisionWidth,
          collisionHeight: collisionHeight,
          offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
          my: options.my,
          at: options.at,
          within: within,
          elem: elem
        } );
      }
    } );

    if ( options.using ) {

      // Adds feedback as second argument to using callback, if present
      using = function( props ) {
        var left = targetOffset.left - position.left,
          right = left + targetWidth - elemWidth,
          top = targetOffset.top - position.top,
          bottom = top + targetHeight - elemHeight,
          feedback = {
            target: {
              element: target,
              left: targetOffset.left,
              top: targetOffset.top,
              width: targetWidth,
              height: targetHeight
            },
            element: {
              element: elem,
              left: position.left,
              top: position.top,
              width: elemWidth,
              height: elemHeight
            },
            horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
            vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
          };
        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
          feedback.horizontal = "center";
        }
        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
          feedback.vertical = "middle";
        }
        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
          feedback.important = "horizontal";
        } else {
          feedback.important = "vertical";
        }
        options.using.call( this, props, feedback );
      };
    }

    elem.offset( $.extend( position, { using: using } ) );
  } );
};

$.ui.position = {
  fit: {
    left: function( position, data ) {
      var within = data.within,
        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
        outerWidth = within.width,
        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
        overLeft = withinOffset - collisionPosLeft,
        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
        newOverRight;

      // Element is wider than within
      if ( data.collisionWidth > outerWidth ) {

        // Element is initially over the left side of within
        if ( overLeft > 0 && overRight <= 0 ) {
          newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
            withinOffset;
          position.left += overLeft - newOverRight;

        // Element is initially over right side of within
        } else if ( overRight > 0 && overLeft <= 0 ) {
          position.left = withinOffset;

        // Element is initially over both left and right sides of within
        } else {
          if ( overLeft > overRight ) {
            position.left = withinOffset + outerWidth - data.collisionWidth;
          } else {
            position.left = withinOffset;
          }
        }

      // Too far left -> align with left edge
      } else if ( overLeft > 0 ) {
        position.left += overLeft;

      // Too far right -> align with right edge
      } else if ( overRight > 0 ) {
        position.left -= overRight;

      // Adjust based on position and margin
      } else {
        position.left = max( position.left - collisionPosLeft, position.left );
      }
    },
    top: function( position, data ) {
      var within = data.within,
        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
        outerHeight = data.within.height,
        collisionPosTop = position.top - data.collisionPosition.marginTop,
        overTop = withinOffset - collisionPosTop,
        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
        newOverBottom;

      // Element is taller than within
      if ( data.collisionHeight > outerHeight ) {

        // Element is initially over the top of within
        if ( overTop > 0 && overBottom <= 0 ) {
          newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
            withinOffset;
          position.top += overTop - newOverBottom;

        // Element is initially over bottom of within
        } else if ( overBottom > 0 && overTop <= 0 ) {
          position.top = withinOffset;

        // Element is initially over both top and bottom of within
        } else {
          if ( overTop > overBottom ) {
            position.top = withinOffset + outerHeight - data.collisionHeight;
          } else {
            position.top = withinOffset;
          }
        }

      // Too far up -> align with top
      } else if ( overTop > 0 ) {
        position.top += overTop;

      // Too far down -> align with bottom edge
      } else if ( overBottom > 0 ) {
        position.top -= overBottom;

      // Adjust based on position and margin
      } else {
        position.top = max( position.top - collisionPosTop, position.top );
      }
    }
  },
  flip: {
    left: function( position, data ) {
      var within = data.within,
        withinOffset = within.offset.left + within.scrollLeft,
        outerWidth = within.width,
        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
        collisionPosLeft = position.left - data.collisionPosition.marginLeft,
        overLeft = collisionPosLeft - offsetLeft,
        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
        myOffset = data.my[ 0 ] === "left" ?
          -data.elemWidth :
          data.my[ 0 ] === "right" ?
            data.elemWidth :
            0,
        atOffset = data.at[ 0 ] === "left" ?
          data.targetWidth :
          data.at[ 0 ] === "right" ?
            -data.targetWidth :
            0,
        offset = -2 * data.offset[ 0 ],
        newOverRight,
        newOverLeft;

      if ( overLeft < 0 ) {
        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
          outerWidth - withinOffset;
        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
          position.left += myOffset + atOffset + offset;
        }
      } else if ( overRight > 0 ) {
        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
          atOffset + offset - offsetLeft;
        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
          position.left += myOffset + atOffset + offset;
        }
      }
    },
    top: function( position, data ) {
      var within = data.within,
        withinOffset = within.offset.top + within.scrollTop,
        outerHeight = within.height,
        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
        collisionPosTop = position.top - data.collisionPosition.marginTop,
        overTop = collisionPosTop - offsetTop,
        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
        top = data.my[ 1 ] === "top",
        myOffset = top ?
          -data.elemHeight :
          data.my[ 1 ] === "bottom" ?
            data.elemHeight :
            0,
        atOffset = data.at[ 1 ] === "top" ?
          data.targetHeight :
          data.at[ 1 ] === "bottom" ?
            -data.targetHeight :
            0,
        offset = -2 * data.offset[ 1 ],
        newOverTop,
        newOverBottom;
      if ( overTop < 0 ) {
        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
          outerHeight - withinOffset;
        if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
          position.top += myOffset + atOffset + offset;
        }
      } else if ( overBottom > 0 ) {
        newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
          offset - offsetTop;
        if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
          position.top += myOffset + atOffset + offset;
        }
      }
    }
  },
  flipfit: {
    left: function() {
      $.ui.position.flip.left.apply( this, arguments );
      $.ui.position.fit.left.apply( this, arguments );
    },
    top: function() {
      $.ui.position.flip.top.apply( this, arguments );
      $.ui.position.fit.top.apply( this, arguments );
    }
  }
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr[ ":" ], {
  data: $.expr.createPseudo ?
    $.expr.createPseudo( function( dataName ) {
      return function( elem ) {
        return !!$.data( elem, dataName );
      };
    } ) :

    // Support: jQuery <1.8
    function( elem, i, match ) {
      return !!$.data( elem, match[ 3 ] );
    }
} );

/*!
 * jQuery UI Disable Selection 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
  disableSelection: ( function() {
    var eventType = "onselectstart" in document.createElement( "div" ) ?
      "selectstart" :
      "mousedown";

    return function() {
      return this.on( eventType + ".ui-disableSelection", function( event ) {
        event.preventDefault();
      } );
    };
  } )(),

  enableSelection: function() {
    return this.off( ".ui-disableSelection" );
  }
} );


/*!
 * jQuery UI Effects 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Effects Core
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/category/effects-core/
//>>demos: http://jqueryui.com/effect/



var dataSpace = "ui-effects-",
  dataSpaceStyle = "ui-effects-style",
  dataSpaceAnimated = "ui-effects-animated",

  // Create a local jQuery because jQuery Color relies on it and the
  // global may not exist with AMD and a custom build (#10199)
  jQuery = $;

$.effects = {
  effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
( function( jQuery, undefined ) {

  var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
    "borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

  // Plusequals test for += 100 -= 100
  rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

  // A set of RE's that can match strings and generate color tuples.
  stringParsers = [ {
      re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      parse: function( execResult ) {
        return [
          execResult[ 1 ],
          execResult[ 2 ],
          execResult[ 3 ],
          execResult[ 4 ]
        ];
      }
    }, {
      re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      parse: function( execResult ) {
        return [
          execResult[ 1 ] * 2.55,
          execResult[ 2 ] * 2.55,
          execResult[ 3 ] * 2.55,
          execResult[ 4 ]
        ];
      }
    }, {

      // This regex ignores A-F because it's compared against an already lowercased string
      re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
      parse: function( execResult ) {
        return [
          parseInt( execResult[ 1 ], 16 ),
          parseInt( execResult[ 2 ], 16 ),
          parseInt( execResult[ 3 ], 16 )
        ];
      }
    }, {

      // This regex ignores A-F because it's compared against an already lowercased string
      re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
      parse: function( execResult ) {
        return [
          parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
          parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
          parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
        ];
      }
    }, {
      re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      space: "hsla",
      parse: function( execResult ) {
        return [
          execResult[ 1 ],
          execResult[ 2 ] / 100,
          execResult[ 3 ] / 100,
          execResult[ 4 ]
        ];
      }
    } ],

  // JQuery.Color( )
  color = jQuery.Color = function( color, green, blue, alpha ) {
    return new jQuery.Color.fn.parse( color, green, blue, alpha );
  },
  spaces = {
    rgba: {
      props: {
        red: {
          idx: 0,
          type: "byte"
        },
        green: {
          idx: 1,
          type: "byte"
        },
        blue: {
          idx: 2,
          type: "byte"
        }
      }
    },

    hsla: {
      props: {
        hue: {
          idx: 0,
          type: "degrees"
        },
        saturation: {
          idx: 1,
          type: "percent"
        },
        lightness: {
          idx: 2,
          type: "percent"
        }
      }
    }
  },
  propTypes = {
    "byte": {
      floor: true,
      max: 255
    },
    "percent": {
      max: 1
    },
    "degrees": {
      mod: 360,
      floor: true
    }
  },
  support = color.support = {},

  // Element for support tests
  supportElem = jQuery( "<p>" )[ 0 ],

  // Colors = jQuery.Color.names
  colors,

  // Local aliases of functions called often
  each = jQuery.each;

// Determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// Define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
  space.cache = "_" + spaceName;
  space.props.alpha = {
    idx: 3,
    type: "percent",
    def: 1
  };
} );

function clamp( value, prop, allowEmpty ) {
  var type = propTypes[ prop.type ] || {};

  if ( value == null ) {
    return ( allowEmpty || !prop.def ) ? null : prop.def;
  }

  // ~~ is an short way of doing floor for positive numbers
  value = type.floor ? ~~value : parseFloat( value );

  // IE will pass in empty strings as value for alpha,
  // which will hit this case
  if ( isNaN( value ) ) {
    return prop.def;
  }

  if ( type.mod ) {

    // We add mod before modding to make sure that negatives values
    // get converted properly: -10 -> 350
    return ( value + type.mod ) % type.mod;
  }

  // For now all property types without mod have min and max
  return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
  var inst = color(),
    rgba = inst._rgba = [];

  string = string.toLowerCase();

  each( stringParsers, function( i, parser ) {
    var parsed,
      match = parser.re.exec( string ),
      values = match && parser.parse( match ),
      spaceName = parser.space || "rgba";

    if ( values ) {
      parsed = inst[ spaceName ]( values );

      // If this was an rgba parse the assignment might happen twice
      // oh well....
      inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
      rgba = inst._rgba = parsed._rgba;

      // Exit each( stringParsers ) here because we matched
      return false;
    }
  } );

  // Found a stringParser that handled it
  if ( rgba.length ) {

    // If this came from a parsed string, force "transparent" when alpha is 0
    // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
    if ( rgba.join() === "0,0,0,0" ) {
      jQuery.extend( rgba, colors.transparent );
    }
    return inst;
  }

  // Named colors
  return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
  parse: function( red, green, blue, alpha ) {
    if ( red === undefined ) {
      this._rgba = [ null, null, null, null ];
      return this;
    }
    if ( red.jquery || red.nodeType ) {
      red = jQuery( red ).css( green );
      green = undefined;
    }

    var inst = this,
      type = jQuery.type( red ),
      rgba = this._rgba = [];

    // More than 1 argument specified - assume ( red, green, blue, alpha )
    if ( green !== undefined ) {
      red = [ red, green, blue, alpha ];
      type = "array";
    }

    if ( type === "string" ) {
      return this.parse( stringParse( red ) || colors._default );
    }

    if ( type === "array" ) {
      each( spaces.rgba.props, function( key, prop ) {
        rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
      } );
      return this;
    }

    if ( type === "object" ) {
      if ( red instanceof color ) {
        each( spaces, function( spaceName, space ) {
          if ( red[ space.cache ] ) {
            inst[ space.cache ] = red[ space.cache ].slice();
          }
        } );
      } else {
        each( spaces, function( spaceName, space ) {
          var cache = space.cache;
          each( space.props, function( key, prop ) {

            // If the cache doesn't exist, and we know how to convert
            if ( !inst[ cache ] && space.to ) {

              // If the value was null, we don't need to copy it
              // if the key was alpha, we don't need to copy it either
              if ( key === "alpha" || red[ key ] == null ) {
                return;
              }
              inst[ cache ] = space.to( inst._rgba );
            }

            // This is the only case where we allow nulls for ALL properties.
            // call clamp with alwaysAllowEmpty
            inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
          } );

          // Everything defined but alpha?
          if ( inst[ cache ] &&
              jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {

            // Use the default of 1
            inst[ cache ][ 3 ] = 1;
            if ( space.from ) {
              inst._rgba = space.from( inst[ cache ] );
            }
          }
        } );
      }
      return this;
    }
  },
  is: function( compare ) {
    var is = color( compare ),
      same = true,
      inst = this;

    each( spaces, function( _, space ) {
      var localCache,
        isCache = is[ space.cache ];
      if ( isCache ) {
        localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
        each( space.props, function( _, prop ) {
          if ( isCache[ prop.idx ] != null ) {
            same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
            return same;
          }
        } );
      }
      return same;
    } );
    return same;
  },
  _space: function() {
    var used = [],
      inst = this;
    each( spaces, function( spaceName, space ) {
      if ( inst[ space.cache ] ) {
        used.push( spaceName );
      }
    } );
    return used.pop();
  },
  transition: function( other, distance ) {
    var end = color( other ),
      spaceName = end._space(),
      space = spaces[ spaceName ],
      startColor = this.alpha() === 0 ? color( "transparent" ) : this,
      start = startColor[ space.cache ] || space.to( startColor._rgba ),
      result = start.slice();

    end = end[ space.cache ];
    each( space.props, function( key, prop ) {
      var index = prop.idx,
        startValue = start[ index ],
        endValue = end[ index ],
        type = propTypes[ prop.type ] || {};

      // If null, don't override start value
      if ( endValue === null ) {
        return;
      }

      // If null - use end
      if ( startValue === null ) {
        result[ index ] = endValue;
      } else {
        if ( type.mod ) {
          if ( endValue - startValue > type.mod / 2 ) {
            startValue += type.mod;
          } else if ( startValue - endValue > type.mod / 2 ) {
            startValue -= type.mod;
          }
        }
        result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
      }
    } );
    return this[ spaceName ]( result );
  },
  blend: function( opaque ) {

    // If we are already opaque - return ourself
    if ( this._rgba[ 3 ] === 1 ) {
      return this;
    }

    var rgb = this._rgba.slice(),
      a = rgb.pop(),
      blend = color( opaque )._rgba;

    return color( jQuery.map( rgb, function( v, i ) {
      return ( 1 - a ) * blend[ i ] + a * v;
    } ) );
  },
  toRgbaString: function() {
    var prefix = "rgba(",
      rgba = jQuery.map( this._rgba, function( v, i ) {
        return v == null ? ( i > 2 ? 1 : 0 ) : v;
      } );

    if ( rgba[ 3 ] === 1 ) {
      rgba.pop();
      prefix = "rgb(";
    }

    return prefix + rgba.join() + ")";
  },
  toHslaString: function() {
    var prefix = "hsla(",
      hsla = jQuery.map( this.hsla(), function( v, i ) {
        if ( v == null ) {
          v = i > 2 ? 1 : 0;
        }

        // Catch 1 and 2
        if ( i && i < 3 ) {
          v = Math.round( v * 100 ) + "%";
        }
        return v;
      } );

    if ( hsla[ 3 ] === 1 ) {
      hsla.pop();
      prefix = "hsl(";
    }
    return prefix + hsla.join() + ")";
  },
  toHexString: function( includeAlpha ) {
    var rgba = this._rgba.slice(),
      alpha = rgba.pop();

    if ( includeAlpha ) {
      rgba.push( ~~( alpha * 255 ) );
    }

    return "#" + jQuery.map( rgba, function( v ) {

      // Default to 0 when nulls exist
      v = ( v || 0 ).toString( 16 );
      return v.length === 1 ? "0" + v : v;
    } ).join( "" );
  },
  toString: function() {
    return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
  }
} );
color.fn.parse.prototype = color.fn;

// Hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
  h = ( h + 1 ) % 1;
  if ( h * 6 < 1 ) {
    return p + ( q - p ) * h * 6;
  }
  if ( h * 2 < 1 ) {
    return q;
  }
  if ( h * 3 < 2 ) {
    return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
  }
  return p;
}

spaces.hsla.to = function( rgba ) {
  if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
    return [ null, null, null, rgba[ 3 ] ];
  }
  var r = rgba[ 0 ] / 255,
    g = rgba[ 1 ] / 255,
    b = rgba[ 2 ] / 255,
    a = rgba[ 3 ],
    max = Math.max( r, g, b ),
    min = Math.min( r, g, b ),
    diff = max - min,
    add = max + min,
    l = add * 0.5,
    h, s;

  if ( min === max ) {
    h = 0;
  } else if ( r === max ) {
    h = ( 60 * ( g - b ) / diff ) + 360;
  } else if ( g === max ) {
    h = ( 60 * ( b - r ) / diff ) + 120;
  } else {
    h = ( 60 * ( r - g ) / diff ) + 240;
  }

  // Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
  // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
  if ( diff === 0 ) {
    s = 0;
  } else if ( l <= 0.5 ) {
    s = diff / add;
  } else {
    s = diff / ( 2 - add );
  }
  return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
  if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
    return [ null, null, null, hsla[ 3 ] ];
  }
  var h = hsla[ 0 ] / 360,
    s = hsla[ 1 ],
    l = hsla[ 2 ],
    a = hsla[ 3 ],
    q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
    p = 2 * l - q;

  return [
    Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
    Math.round( hue2rgb( p, q, h ) * 255 ),
    Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
    a
  ];
};

each( spaces, function( spaceName, space ) {
  var props = space.props,
    cache = space.cache,
    to = space.to,
    from = space.from;

  // Makes rgba() and hsla()
  color.fn[ spaceName ] = function( value ) {

    // Generate a cache for this space if it doesn't exist
    if ( to && !this[ cache ] ) {
      this[ cache ] = to( this._rgba );
    }
    if ( value === undefined ) {
      return this[ cache ].slice();
    }

    var ret,
      type = jQuery.type( value ),
      arr = ( type === "array" || type === "object" ) ? value : arguments,
      local = this[ cache ].slice();

    each( props, function( key, prop ) {
      var val = arr[ type === "object" ? key : prop.idx ];
      if ( val == null ) {
        val = local[ prop.idx ];
      }
      local[ prop.idx ] = clamp( val, prop );
    } );

    if ( from ) {
      ret = color( from( local ) );
      ret[ cache ] = local;
      return ret;
    } else {
      return color( local );
    }
  };

  // Makes red() green() blue() alpha() hue() saturation() lightness()
  each( props, function( key, prop ) {

    // Alpha is included in more than one space
    if ( color.fn[ key ] ) {
      return;
    }
    color.fn[ key ] = function( value ) {
      var vtype = jQuery.type( value ),
        fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
        local = this[ fn ](),
        cur = local[ prop.idx ],
        match;

      if ( vtype === "undefined" ) {
        return cur;
      }

      if ( vtype === "function" ) {
        value = value.call( this, cur );
        vtype = jQuery.type( value );
      }
      if ( value == null && prop.empty ) {
        return this;
      }
      if ( vtype === "string" ) {
        match = rplusequals.exec( value );
        if ( match ) {
          value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
        }
      }
      local[ prop.idx ] = value;
      return this[ fn ]( local );
    };
  } );
} );

// Add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
  var hooks = hook.split( " " );
  each( hooks, function( i, hook ) {
    jQuery.cssHooks[ hook ] = {
      set: function( elem, value ) {
        var parsed, curElem,
          backgroundColor = "";

        if ( value !== "transparent" && ( jQuery.type( value ) !== "string" ||
            ( parsed = stringParse( value ) ) ) ) {
          value = color( parsed || value );
          if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
            curElem = hook === "backgroundColor" ? elem.parentNode : elem;
            while (
              ( backgroundColor === "" || backgroundColor === "transparent" ) &&
              curElem && curElem.style
            ) {
              try {
                backgroundColor = jQuery.css( curElem, "backgroundColor" );
                curElem = curElem.parentNode;
              } catch ( e ) {
              }
            }

            value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
              backgroundColor :
              "_default" );
          }

          value = value.toRgbaString();
        }
        try {
          elem.style[ hook ] = value;
        } catch ( e ) {

          // Wrapped to prevent IE from throwing errors on "invalid" values like
          // 'auto' or 'inherit'
        }
      }
    };
    jQuery.fx.step[ hook ] = function( fx ) {
      if ( !fx.colorInit ) {
        fx.start = color( fx.elem, hook );
        fx.end = color( fx.end );
        fx.colorInit = true;
      }
      jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
    };
  } );

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
  expand: function( value ) {
    var expanded = {};

    each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
      expanded[ "border" + part + "Color" ] = value;
    } );
    return expanded;
  }
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {

  // 4.1. Basic color keywords
  aqua: "#00ffff",
  black: "#000000",
  blue: "#0000ff",
  fuchsia: "#ff00ff",
  gray: "#808080",
  green: "#008000",
  lime: "#00ff00",
  maroon: "#800000",
  navy: "#000080",
  olive: "#808000",
  purple: "#800080",
  red: "#ff0000",
  silver: "#c0c0c0",
  teal: "#008080",
  white: "#ffffff",
  yellow: "#ffff00",

  // 4.2.3. "transparent" color keyword
  transparent: [ null, null, null, 0 ],

  _default: "#ffffff"
};

} )( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
( function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
  shorthandStyles = {
    border: 1,
    borderBottom: 1,
    borderColor: 1,
    borderLeft: 1,
    borderRight: 1,
    borderTop: 1,
    borderWidth: 1,
    margin: 1,
    padding: 1
  };

$.each(
  [ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
  function( _, prop ) {
    $.fx.step[ prop ] = function( fx ) {
      if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
        jQuery.style( fx.elem, prop, fx.end );
        fx.setAttr = true;
      }
    };
  }
);

function getElementStyles( elem ) {
  var key, len,
    style = elem.ownerDocument.defaultView ?
      elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
      elem.currentStyle,
    styles = {};

  if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
    len = style.length;
    while ( len-- ) {
      key = style[ len ];
      if ( typeof style[ key ] === "string" ) {
        styles[ $.camelCase( key ) ] = style[ key ];
      }
    }

  // Support: Opera, IE <9
  } else {
    for ( key in style ) {
      if ( typeof style[ key ] === "string" ) {
        styles[ key ] = style[ key ];
      }
    }
  }

  return styles;
}

function styleDifference( oldStyle, newStyle ) {
  var diff = {},
    name, value;

  for ( name in newStyle ) {
    value = newStyle[ name ];
    if ( oldStyle[ name ] !== value ) {
      if ( !shorthandStyles[ name ] ) {
        if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
          diff[ name ] = value;
        }
      }
    }
  }

  return diff;
}

// Support: jQuery <1.8
if ( !$.fn.addBack ) {
  $.fn.addBack = function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter( selector )
    );
  };
}

$.effects.animateClass = function( value, duration, easing, callback ) {
  var o = $.speed( duration, easing, callback );

  return this.queue( function() {
    var animated = $( this ),
      baseClass = animated.attr( "class" ) || "",
      applyClassChange,
      allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

    // Map the animated objects to store the original styles.
    allAnimations = allAnimations.map( function() {
      var el = $( this );
      return {
        el: el,
        start: getElementStyles( this )
      };
    } );

    // Apply class change
    applyClassChange = function() {
      $.each( classAnimationActions, function( i, action ) {
        if ( value[ action ] ) {
          animated[ action + "Class" ]( value[ action ] );
        }
      } );
    };
    applyClassChange();

    // Map all animated objects again - calculate new styles and diff
    allAnimations = allAnimations.map( function() {
      this.end = getElementStyles( this.el[ 0 ] );
      this.diff = styleDifference( this.start, this.end );
      return this;
    } );

    // Apply original class
    animated.attr( "class", baseClass );

    // Map all animated objects again - this time collecting a promise
    allAnimations = allAnimations.map( function() {
      var styleInfo = this,
        dfd = $.Deferred(),
        opts = $.extend( {}, o, {
          queue: false,
          complete: function() {
            dfd.resolve( styleInfo );
          }
        } );

      this.el.animate( this.diff, opts );
      return dfd.promise();
    } );

    // Once all animations have completed:
    $.when.apply( $, allAnimations.get() ).done( function() {

      // Set the final class
      applyClassChange();

      // For each animated element,
      // clear all css properties that were animated
      $.each( arguments, function() {
        var el = this.el;
        $.each( this.diff, function( key ) {
          el.css( key, "" );
        } );
      } );

      // This is guarnteed to be there if you use jQuery.speed()
      // it also handles dequeuing the next anim...
      o.complete.call( animated[ 0 ] );
    } );
  } );
};

$.fn.extend( {
  addClass: ( function( orig ) {
    return function( classNames, speed, easing, callback ) {
      return speed ?
        $.effects.animateClass.call( this,
          { add: classNames }, speed, easing, callback ) :
        orig.apply( this, arguments );
    };
  } )( $.fn.addClass ),

  removeClass: ( function( orig ) {
    return function( classNames, speed, easing, callback ) {
      return arguments.length > 1 ?
        $.effects.animateClass.call( this,
          { remove: classNames }, speed, easing, callback ) :
        orig.apply( this, arguments );
    };
  } )( $.fn.removeClass ),

  toggleClass: ( function( orig ) {
    return function( classNames, force, speed, easing, callback ) {
      if ( typeof force === "boolean" || force === undefined ) {
        if ( !speed ) {

          // Without speed parameter
          return orig.apply( this, arguments );
        } else {
          return $.effects.animateClass.call( this,
            ( force ? { add: classNames } : { remove: classNames } ),
            speed, easing, callback );
        }
      } else {

        // Without force parameter
        return $.effects.animateClass.call( this,
          { toggle: classNames }, force, speed, easing );
      }
    };
  } )( $.fn.toggleClass ),

  switchClass: function( remove, add, speed, easing, callback ) {
    return $.effects.animateClass.call( this, {
      add: add,
      remove: remove
    }, speed, easing, callback );
  }
} );

} )();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

( function() {

if ( $.expr && $.expr.filters && $.expr.filters.animated ) {
  $.expr.filters.animated = ( function( orig ) {
    return function( elem ) {
      return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
    };
  } )( $.expr.filters.animated );
}

if ( $.uiBackCompat !== false ) {
  $.extend( $.effects, {

    // Saves a set of properties in a data storage
    save: function( element, set ) {
      var i = 0, length = set.length;
      for ( ; i < length; i++ ) {
        if ( set[ i ] !== null ) {
          element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
        }
      }
    },

    // Restores a set of previously saved properties from a data storage
    restore: function( element, set ) {
      var val, i = 0, length = set.length;
      for ( ; i < length; i++ ) {
        if ( set[ i ] !== null ) {
          val = element.data( dataSpace + set[ i ] );
          element.css( set[ i ], val );
        }
      }
    },

    setMode: function( el, mode ) {
      if ( mode === "toggle" ) {
        mode = el.is( ":hidden" ) ? "show" : "hide";
      }
      return mode;
    },

    // Wraps the element around a wrapper that copies position properties
    createWrapper: function( element ) {

      // If the element is already wrapped, return it
      if ( element.parent().is( ".ui-effects-wrapper" ) ) {
        return element.parent();
      }

      // Wrap the element
      var props = {
          width: element.outerWidth( true ),
          height: element.outerHeight( true ),
          "float": element.css( "float" )
        },
        wrapper = $( "<div></div>" )
          .addClass( "ui-effects-wrapper" )
          .css( {
            fontSize: "100%",
            background: "transparent",
            border: "none",
            margin: 0,
            padding: 0
          } ),

        // Store the size in case width/height are defined in % - Fixes #5245
        size = {
          width: element.width(),
          height: element.height()
        },
        active = document.activeElement;

      // Support: Firefox
      // Firefox incorrectly exposes anonymous content
      // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
      try {
        active.id;
      } catch ( e ) {
        active = document.body;
      }

      element.wrap( wrapper );

      // Fixes #7595 - Elements lose focus when wrapped.
      if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
        $( active ).trigger( "focus" );
      }

      // Hotfix for jQuery 1.4 since some change in wrap() seems to actually
      // lose the reference to the wrapped element
      wrapper = element.parent();

      // Transfer positioning properties to the wrapper
      if ( element.css( "position" ) === "static" ) {
        wrapper.css( { position: "relative" } );
        element.css( { position: "relative" } );
      } else {
        $.extend( props, {
          position: element.css( "position" ),
          zIndex: element.css( "z-index" )
        } );
        $.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
          props[ pos ] = element.css( pos );
          if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
            props[ pos ] = "auto";
          }
        } );
        element.css( {
          position: "relative",
          top: 0,
          left: 0,
          right: "auto",
          bottom: "auto"
        } );
      }
      element.css( size );

      return wrapper.css( props ).show();
    },

    removeWrapper: function( element ) {
      var active = document.activeElement;

      if ( element.parent().is( ".ui-effects-wrapper" ) ) {
        element.parent().replaceWith( element );

        // Fixes #7595 - Elements lose focus when wrapped.
        if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
          $( active ).trigger( "focus" );
        }
      }

      return element;
    }
  } );
}

$.extend( $.effects, {
  version: "1.12.1",

  define: function( name, mode, effect ) {
    if ( !effect ) {
      effect = mode;
      mode = "effect";
    }

    $.effects.effect[ name ] = effect;
    $.effects.effect[ name ].mode = mode;

    return effect;
  },

  scaledDimensions: function( element, percent, direction ) {
    if ( percent === 0 ) {
      return {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      };
    }

    var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,
      y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;

    return {
      height: element.height() * y,
      width: element.width() * x,
      outerHeight: element.outerHeight() * y,
      outerWidth: element.outerWidth() * x
    };

  },

  clipToBox: function( animation ) {
    return {
      width: animation.clip.right - animation.clip.left,
      height: animation.clip.bottom - animation.clip.top,
      left: animation.clip.left,
      top: animation.clip.top
    };
  },

  // Injects recently queued functions to be first in line (after "inprogress")
  unshift: function( element, queueLength, count ) {
    var queue = element.queue();

    if ( queueLength > 1 ) {
      queue.splice.apply( queue,
        [ 1, 0 ].concat( queue.splice( queueLength, count ) ) );
    }
    element.dequeue();
  },

  saveStyle: function( element ) {
    element.data( dataSpaceStyle, element[ 0 ].style.cssText );
  },

  restoreStyle: function( element ) {
    element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";
    element.removeData( dataSpaceStyle );
  },

  mode: function( element, mode ) {
    var hidden = element.is( ":hidden" );

    if ( mode === "toggle" ) {
      mode = hidden ? "show" : "hide";
    }
    if ( hidden ? mode === "hide" : mode === "show" ) {
      mode = "none";
    }
    return mode;
  },

  // Translates a [top,left] array into a baseline value
  getBaseline: function( origin, original ) {
    var y, x;

    switch ( origin[ 0 ] ) {
    case "top":
      y = 0;
      break;
    case "middle":
      y = 0.5;
      break;
    case "bottom":
      y = 1;
      break;
    default:
      y = origin[ 0 ] / original.height;
    }

    switch ( origin[ 1 ] ) {
    case "left":
      x = 0;
      break;
    case "center":
      x = 0.5;
      break;
    case "right":
      x = 1;
      break;
    default:
      x = origin[ 1 ] / original.width;
    }

    return {
      x: x,
      y: y
    };
  },

  // Creates a placeholder element so that the original element can be made absolute
  createPlaceholder: function( element ) {
    var placeholder,
      cssPosition = element.css( "position" ),
      position = element.position();

    // Lock in margins first to account for form elements, which
    // will change margin if you explicitly set height
    // see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
    // Support: Safari
    element.css( {
      marginTop: element.css( "marginTop" ),
      marginBottom: element.css( "marginBottom" ),
      marginLeft: element.css( "marginLeft" ),
      marginRight: element.css( "marginRight" )
    } )
    .outerWidth( element.outerWidth() )
    .outerHeight( element.outerHeight() );

    if ( /^(static|relative)/.test( cssPosition ) ) {
      cssPosition = "absolute";

      placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {

        // Convert inline to inline block to account for inline elements
        // that turn to inline block based on content (like img)
        display: /^(inline|ruby)/.test( element.css( "display" ) ) ?
          "inline-block" :
          "block",
        visibility: "hidden",

        // Margins need to be set to account for margin collapse
        marginTop: element.css( "marginTop" ),
        marginBottom: element.css( "marginBottom" ),
        marginLeft: element.css( "marginLeft" ),
        marginRight: element.css( "marginRight" ),
        "float": element.css( "float" )
      } )
      .outerWidth( element.outerWidth() )
      .outerHeight( element.outerHeight() )
      .addClass( "ui-effects-placeholder" );

      element.data( dataSpace + "placeholder", placeholder );
    }

    element.css( {
      position: cssPosition,
      left: position.left,
      top: position.top
    } );

    return placeholder;
  },

  removePlaceholder: function( element ) {
    var dataKey = dataSpace + "placeholder",
        placeholder = element.data( dataKey );

    if ( placeholder ) {
      placeholder.remove();
      element.removeData( dataKey );
    }
  },

  // Removes a placeholder if it exists and restores
  // properties that were modified during placeholder creation
  cleanUp: function( element ) {
    $.effects.restoreStyle( element );
    $.effects.removePlaceholder( element );
  },

  setTransition: function( element, list, factor, value ) {
    value = value || {};
    $.each( list, function( i, x ) {
      var unit = element.cssUnit( x );
      if ( unit[ 0 ] > 0 ) {
        value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
      }
    } );
    return value;
  }
} );

// Return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

  // Allow passing all options as the first parameter
  if ( $.isPlainObject( effect ) ) {
    options = effect;
    effect = effect.effect;
  }

  // Convert to an object
  effect = { effect: effect };

  // Catch (effect, null, ...)
  if ( options == null ) {
    options = {};
  }

  // Catch (effect, callback)
  if ( $.isFunction( options ) ) {
    callback = options;
    speed = null;
    options = {};
  }

  // Catch (effect, speed, ?)
  if ( typeof options === "number" || $.fx.speeds[ options ] ) {
    callback = speed;
    speed = options;
    options = {};
  }

  // Catch (effect, options, callback)
  if ( $.isFunction( speed ) ) {
    callback = speed;
    speed = null;
  }

  // Add options to effect
  if ( options ) {
    $.extend( effect, options );
  }

  speed = speed || options.duration;
  effect.duration = $.fx.off ? 0 :
    typeof speed === "number" ? speed :
    speed in $.fx.speeds ? $.fx.speeds[ speed ] :
    $.fx.speeds._default;

  effect.complete = callback || options.complete;

  return effect;
}

function standardAnimationOption( option ) {

  // Valid standard speeds (nothing, number, named speed)
  if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
    return true;
  }

  // Invalid strings - treat as "normal" speed
  if ( typeof option === "string" && !$.effects.effect[ option ] ) {
    return true;
  }

  // Complete callback
  if ( $.isFunction( option ) ) {
    return true;
  }

  // Options hash (but not naming an effect)
  if ( typeof option === "object" && !option.effect ) {
    return true;
  }

  // Didn't match any standard API
  return false;
}

$.fn.extend( {
  effect: function( /* effect, options, speed, callback */ ) {
    var args = _normalizeArguments.apply( this, arguments ),
      effectMethod = $.effects.effect[ args.effect ],
      defaultMode = effectMethod.mode,
      queue = args.queue,
      queueName = queue || "fx",
      complete = args.complete,
      mode = args.mode,
      modes = [],
      prefilter = function( next ) {
        var el = $( this ),
          normalizedMode = $.effects.mode( el, mode ) || defaultMode;

        // Sentinel for duck-punching the :animated psuedo-selector
        el.data( dataSpaceAnimated, true );

        // Save effect mode for later use,
        // we can't just call $.effects.mode again later,
        // as the .show() below destroys the initial state
        modes.push( normalizedMode );

        // See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
        if ( defaultMode && ( normalizedMode === "show" ||
            ( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {
          el.show();
        }

        if ( !defaultMode || normalizedMode !== "none" ) {
          $.effects.saveStyle( el );
        }

        if ( $.isFunction( next ) ) {
          next();
        }
      };

    if ( $.fx.off || !effectMethod ) {

      // Delegate to the original method (e.g., .show()) if possible
      if ( mode ) {
        return this[ mode ]( args.duration, complete );
      } else {
        return this.each( function() {
          if ( complete ) {
            complete.call( this );
          }
        } );
      }
    }

    function run( next ) {
      var elem = $( this );

      function cleanup() {
        elem.removeData( dataSpaceAnimated );

        $.effects.cleanUp( elem );

        if ( args.mode === "hide" ) {
          elem.hide();
        }

        done();
      }

      function done() {
        if ( $.isFunction( complete ) ) {
          complete.call( elem[ 0 ] );
        }

        if ( $.isFunction( next ) ) {
          next();
        }
      }

      // Override mode option on a per element basis,
      // as toggle can be either show or hide depending on element state
      args.mode = modes.shift();

      if ( $.uiBackCompat !== false && !defaultMode ) {
        if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {

          // Call the core method to track "olddisplay" properly
          elem[ mode ]();
          done();
        } else {
          effectMethod.call( elem[ 0 ], args, done );
        }
      } else {
        if ( args.mode === "none" ) {

          // Call the core method to track "olddisplay" properly
          elem[ mode ]();
          done();
        } else {
          effectMethod.call( elem[ 0 ], args, cleanup );
        }
      }
    }

    // Run prefilter on all elements first to ensure that
    // any showing or hiding happens before placeholder creation,
    // which ensures that any layout changes are correctly captured.
    return queue === false ?
      this.each( prefilter ).each( run ) :
      this.queue( queueName, prefilter ).queue( queueName, run );
  },

  show: ( function( orig ) {
    return function( option ) {
      if ( standardAnimationOption( option ) ) {
        return orig.apply( this, arguments );
      } else {
        var args = _normalizeArguments.apply( this, arguments );
        args.mode = "show";
        return this.effect.call( this, args );
      }
    };
  } )( $.fn.show ),

  hide: ( function( orig ) {
    return function( option ) {
      if ( standardAnimationOption( option ) ) {
        return orig.apply( this, arguments );
      } else {
        var args = _normalizeArguments.apply( this, arguments );
        args.mode = "hide";
        return this.effect.call( this, args );
      }
    };
  } )( $.fn.hide ),

  toggle: ( function( orig ) {
    return function( option ) {
      if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
        return orig.apply( this, arguments );
      } else {
        var args = _normalizeArguments.apply( this, arguments );
        args.mode = "toggle";
        return this.effect.call( this, args );
      }
    };
  } )( $.fn.toggle ),

  cssUnit: function( key ) {
    var style = this.css( key ),
      val = [];

    $.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
      if ( style.indexOf( unit ) > 0 ) {
        val = [ parseFloat( style ), unit ];
      }
    } );
    return val;
  },

  cssClip: function( clipObj ) {
    if ( clipObj ) {
      return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
        clipObj.bottom + "px " + clipObj.left + "px)" );
    }
    return parseClip( this.css( "clip" ), this );
  },

  transfer: function( options, done ) {
    var element = $( this ),
      target = $( options.to ),
      targetFixed = target.css( "position" ) === "fixed",
      body = $( "body" ),
      fixTop = targetFixed ? body.scrollTop() : 0,
      fixLeft = targetFixed ? body.scrollLeft() : 0,
      endPosition = target.offset(),
      animation = {
        top: endPosition.top - fixTop,
        left: endPosition.left - fixLeft,
        height: target.innerHeight(),
        width: target.innerWidth()
      },
      startPosition = element.offset(),
      transfer = $( "<div class='ui-effects-transfer'></div>" )
        .appendTo( "body" )
        .addClass( options.className )
        .css( {
          top: startPosition.top - fixTop,
          left: startPosition.left - fixLeft,
          height: element.innerHeight(),
          width: element.innerWidth(),
          position: targetFixed ? "fixed" : "absolute"
        } )
        .animate( animation, options.duration, options.easing, function() {
          transfer.remove();
          if ( $.isFunction( done ) ) {
            done();
          }
        } );
  }
} );

function parseClip( str, element ) {
    var outerWidth = element.outerWidth(),
      outerHeight = element.outerHeight(),
      clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
      values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];

    return {
      top: parseFloat( values[ 1 ] ) || 0,
      right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),
      bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),
      left: parseFloat( values[ 4 ] ) || 0
    };
}

$.fx.step.clip = function( fx ) {
  if ( !fx.clipInit ) {
    fx.start = $( fx.elem ).cssClip();
    if ( typeof fx.end === "string" ) {
      fx.end = parseClip( fx.end, fx.elem );
    }
    fx.clipInit = true;
  }

  $( fx.elem ).cssClip( {
    top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,
    right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,
    bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,
    left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left
  } );
};

} )();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

( function() {

// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
  baseEasings[ name ] = function( p ) {
    return Math.pow( p, i + 2 );
  };
} );

$.extend( baseEasings, {
  Sine: function( p ) {
    return 1 - Math.cos( p * Math.PI / 2 );
  },
  Circ: function( p ) {
    return 1 - Math.sqrt( 1 - p * p );
  },
  Elastic: function( p ) {
    return p === 0 || p === 1 ? p :
      -Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );
  },
  Back: function( p ) {
    return p * p * ( 3 * p - 2 );
  },
  Bounce: function( p ) {
    var pow2,
      bounce = 4;

    while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
    return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
  }
} );

$.each( baseEasings, function( name, easeIn ) {
  $.easing[ "easeIn" + name ] = easeIn;
  $.easing[ "easeOut" + name ] = function( p ) {
    return 1 - easeIn( 1 - p );
  };
  $.easing[ "easeInOut" + name ] = function( p ) {
    return p < 0.5 ?
      easeIn( p * 2 ) / 2 :
      1 - easeIn( p * -2 + 2 ) / 2;
  };
} );

} )();

var effect = $.effects;


/*!
 * jQuery UI Effects Blind 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Blind Effect
//>>group: Effects
//>>description: Blinds the element.
//>>docs: http://api.jqueryui.com/blind-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {
  var map = {
      up: [ "bottom", "top" ],
      vertical: [ "bottom", "top" ],
      down: [ "top", "bottom" ],
      left: [ "right", "left" ],
      horizontal: [ "right", "left" ],
      right: [ "left", "right" ]
    },
    element = $( this ),
    direction = options.direction || "up",
    start = element.cssClip(),
    animate = { clip: $.extend( {}, start ) },
    placeholder = $.effects.createPlaceholder( element );

  animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];

  if ( options.mode === "show" ) {
    element.cssClip( animate.clip );
    if ( placeholder ) {
      placeholder.css( $.effects.clipToBox( animate ) );
    }

    animate.clip = start;
  }

  if ( placeholder ) {
    placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );
  }

  element.animate( animate, {
    queue: false,
    duration: options.duration,
    easing: options.easing,
    complete: done
  } );
} );


/*!
 * jQuery UI Effects Bounce 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Bounce Effect
//>>group: Effects
//>>description: Bounces an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/bounce-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {
  var upAnim, downAnim, refValue,
    element = $( this ),

    // Defaults:
    mode = options.mode,
    hide = mode === "hide",
    show = mode === "show",
    direction = options.direction || "up",
    distance = options.distance,
    times = options.times || 5,

    // Number of internal animations
    anims = times * 2 + ( show || hide ? 1 : 0 ),
    speed = options.duration / anims,
    easing = options.easing,

    // Utility:
    ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
    motion = ( direction === "up" || direction === "left" ),
    i = 0,

    queuelen = element.queue().length;

  $.effects.createPlaceholder( element );

  refValue = element.css( ref );

  // Default distance for the BIGGEST bounce is the outer Distance / 3
  if ( !distance ) {
    distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
  }

  if ( show ) {
    downAnim = { opacity: 1 };
    downAnim[ ref ] = refValue;

    // If we are showing, force opacity 0 and set the initial position
    // then do the "first" animation
    element
      .css( "opacity", 0 )
      .css( ref, motion ? -distance * 2 : distance * 2 )
      .animate( downAnim, speed, easing );
  }

  // Start at the smallest distance if we are hiding
  if ( hide ) {
    distance = distance / Math.pow( 2, times - 1 );
  }

  downAnim = {};
  downAnim[ ref ] = refValue;

  // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
  for ( ; i < times; i++ ) {
    upAnim = {};
    upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

    element
      .animate( upAnim, speed, easing )
      .animate( downAnim, speed, easing );

    distance = hide ? distance * 2 : distance / 2;
  }

  // Last Bounce when Hiding
  if ( hide ) {
    upAnim = { opacity: 0 };
    upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

    element.animate( upAnim, speed, easing );
  }

  element.queue( done );

  $.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Clip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Clip Effect
//>>group: Effects
//>>description: Clips the element on and off like an old TV.
//>>docs: http://api.jqueryui.com/clip-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {
  var start,
    animate = {},
    element = $( this ),
    direction = options.direction || "vertical",
    both = direction === "both",
    horizontal = both || direction === "horizontal",
    vertical = both || direction === "vertical";

  start = element.cssClip();
  animate.clip = {
    top: vertical ? ( start.bottom - start.top ) / 2 : start.top,
    right: horizontal ? ( start.right - start.left ) / 2 : start.right,
    bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,
    left: horizontal ? ( start.right - start.left ) / 2 : start.left
  };

  $.effects.createPlaceholder( element );

  if ( options.mode === "show" ) {
    element.cssClip( animate.clip );
    animate.clip = start;
  }

  element.animate( animate, {
    queue: false,
    duration: options.duration,
    easing: options.easing,
    complete: done
  } );

} );


/*!
 * jQuery UI Effects Drop 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Drop Effect
//>>group: Effects
//>>description: Moves an element in one direction and hides it at the same time.
//>>docs: http://api.jqueryui.com/drop-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {

  var distance,
    element = $( this ),
    mode = options.mode,
    show = mode === "show",
    direction = options.direction || "left",
    ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
    motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",
    oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",
    animation = {
      opacity: 0
    };

  $.effects.createPlaceholder( element );

  distance = options.distance ||
    element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;

  animation[ ref ] = motion + distance;

  if ( show ) {
    element.css( animation );

    animation[ ref ] = oppositeMotion + distance;
    animation.opacity = 1;
  }

  // Animate
  element.animate( animation, {
    queue: false,
    duration: options.duration,
    easing: options.easing,
    complete: done
  } );
} );


/*!
 * jQuery UI Effects Explode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Explode Effect
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/explode-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {

  var i, j, left, top, mx, my,
    rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
    cells = rows,
    element = $( this ),
    mode = options.mode,
    show = mode === "show",

    // Show and then visibility:hidden the element before calculating offset
    offset = element.show().css( "visibility", "hidden" ).offset(),

    // Width and height of a piece
    width = Math.ceil( element.outerWidth() / cells ),
    height = Math.ceil( element.outerHeight() / rows ),
    pieces = [];

  // Children animate complete:
  function childComplete() {
    pieces.push( this );
    if ( pieces.length === rows * cells ) {
      animComplete();
    }
  }

  // Clone the element for each row and cell.
  for ( i = 0; i < rows; i++ ) { // ===>
    top = offset.top + i * height;
    my = i - ( rows - 1 ) / 2;

    for ( j = 0; j < cells; j++ ) { // |||
      left = offset.left + j * width;
      mx = j - ( cells - 1 ) / 2;

      // Create a clone of the now hidden main element that will be absolute positioned
      // within a wrapper div off the -left and -top equal to size of our pieces
      element
        .clone()
        .appendTo( "body" )
        .wrap( "<div></div>" )
        .css( {
          position: "absolute",
          visibility: "visible",
          left: -j * width,
          top: -i * height
        } )

        // Select the wrapper - make it overflow: hidden and absolute positioned based on
        // where the original was located +left and +top equal to the size of pieces
        .parent()
          .addClass( "ui-effects-explode" )
          .css( {
            position: "absolute",
            overflow: "hidden",
            width: width,
            height: height,
            left: left + ( show ? mx * width : 0 ),
            top: top + ( show ? my * height : 0 ),
            opacity: show ? 0 : 1
          } )
          .animate( {
            left: left + ( show ? 0 : mx * width ),
            top: top + ( show ? 0 : my * height ),
            opacity: show ? 1 : 0
          }, options.duration || 500, options.easing, childComplete );
    }
  }

  function animComplete() {
    element.css( {
      visibility: "visible"
    } );
    $( pieces ).remove();
    done();
  }
} );


/*!
 * jQuery UI Effects Fade 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fade Effect
//>>group: Effects
//>>description: Fades the element.
//>>docs: http://api.jqueryui.com/fade-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {
  var show = options.mode === "show";

  $( this )
    .css( "opacity", show ? 0 : 1 )
    .animate( {
      opacity: show ? 1 : 0
    }, {
      queue: false,
      duration: options.duration,
      easing: options.easing,
      complete: done
    } );
} );


/*!
 * jQuery UI Effects Fold 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fold Effect
//>>group: Effects
//>>description: Folds an element first horizontally and then vertically.
//>>docs: http://api.jqueryui.com/fold-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {

  // Create element
  var element = $( this ),
    mode = options.mode,
    show = mode === "show",
    hide = mode === "hide",
    size = options.size || 15,
    percent = /([0-9]+)%/.exec( size ),
    horizFirst = !!options.horizFirst,
    ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],
    duration = options.duration / 2,

    placeholder = $.effects.createPlaceholder( element ),

    start = element.cssClip(),
    animation1 = { clip: $.extend( {}, start ) },
    animation2 = { clip: $.extend( {}, start ) },

    distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],

    queuelen = element.queue().length;

  if ( percent ) {
    size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
  }
  animation1.clip[ ref[ 0 ] ] = size;
  animation2.clip[ ref[ 0 ] ] = size;
  animation2.clip[ ref[ 1 ] ] = 0;

  if ( show ) {
    element.cssClip( animation2.clip );
    if ( placeholder ) {
      placeholder.css( $.effects.clipToBox( animation2 ) );
    }

    animation2.clip = start;
  }

  // Animate
  element
    .queue( function( next ) {
      if ( placeholder ) {
        placeholder
          .animate( $.effects.clipToBox( animation1 ), duration, options.easing )
          .animate( $.effects.clipToBox( animation2 ), duration, options.easing );
      }

      next();
    } )
    .animate( animation1, duration, options.easing )
    .animate( animation2, duration, options.easing )
    .queue( done );

  $.effects.unshift( element, queuelen, 4 );
} );


/*!
 * jQuery UI Effects Highlight 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Highlight Effect
//>>group: Effects
//>>description: Highlights the background of an element in a defined color for a custom duration.
//>>docs: http://api.jqueryui.com/highlight-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {
  var element = $( this ),
    animation = {
      backgroundColor: element.css( "backgroundColor" )
    };

  if ( options.mode === "hide" ) {
    animation.opacity = 0;
  }

  $.effects.saveStyle( element );

  element
    .css( {
      backgroundImage: "none",
      backgroundColor: options.color || "#ffff99"
    } )
    .animate( animation, {
      queue: false,
      duration: options.duration,
      easing: options.easing,
      complete: done
    } );
} );


/*!
 * jQuery UI Effects Size 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Size Effect
//>>group: Effects
//>>description: Resize an element to a specified width and height.
//>>docs: http://api.jqueryui.com/size-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSize = $.effects.define( "size", function( options, done ) {

  // Create element
  var baseline, factor, temp,
    element = $( this ),

    // Copy for children
    cProps = [ "fontSize" ],
    vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
    hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

    // Set options
    mode = options.mode,
    restore = mode !== "effect",
    scale = options.scale || "both",
    origin = options.origin || [ "middle", "center" ],
    position = element.css( "position" ),
    pos = element.position(),
    original = $.effects.scaledDimensions( element ),
    from = options.from || original,
    to = options.to || $.effects.scaledDimensions( element, 0 );

  $.effects.createPlaceholder( element );

  if ( mode === "show" ) {
    temp = from;
    from = to;
    to = temp;
  }

  // Set scaling factor
  factor = {
    from: {
      y: from.height / original.height,
      x: from.width / original.width
    },
    to: {
      y: to.height / original.height,
      x: to.width / original.width
    }
  };

  // Scale the css box
  if ( scale === "box" || scale === "both" ) {

    // Vertical props scaling
    if ( factor.from.y !== factor.to.y ) {
      from = $.effects.setTransition( element, vProps, factor.from.y, from );
      to = $.effects.setTransition( element, vProps, factor.to.y, to );
    }

    // Horizontal props scaling
    if ( factor.from.x !== factor.to.x ) {
      from = $.effects.setTransition( element, hProps, factor.from.x, from );
      to = $.effects.setTransition( element, hProps, factor.to.x, to );
    }
  }

  // Scale the content
  if ( scale === "content" || scale === "both" ) {

    // Vertical props scaling
    if ( factor.from.y !== factor.to.y ) {
      from = $.effects.setTransition( element, cProps, factor.from.y, from );
      to = $.effects.setTransition( element, cProps, factor.to.y, to );
    }
  }

  // Adjust the position properties based on the provided origin points
  if ( origin ) {
    baseline = $.effects.getBaseline( origin, original );
    from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;
    from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;
    to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;
    to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;
  }
  element.css( from );

  // Animate the children if desired
  if ( scale === "content" || scale === "both" ) {

    vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );
    hProps = hProps.concat( [ "marginLeft", "marginRight" ] );

    // Only animate children with width attributes specified
    // TODO: is this right? should we include anything with css width specified as well
    element.find( "*[width]" ).each( function() {
      var child = $( this ),
        childOriginal = $.effects.scaledDimensions( child ),
        childFrom = {
          height: childOriginal.height * factor.from.y,
          width: childOriginal.width * factor.from.x,
          outerHeight: childOriginal.outerHeight * factor.from.y,
          outerWidth: childOriginal.outerWidth * factor.from.x
        },
        childTo = {
          height: childOriginal.height * factor.to.y,
          width: childOriginal.width * factor.to.x,
          outerHeight: childOriginal.height * factor.to.y,
          outerWidth: childOriginal.width * factor.to.x
        };

      // Vertical props scaling
      if ( factor.from.y !== factor.to.y ) {
        childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );
        childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );
      }

      // Horizontal props scaling
      if ( factor.from.x !== factor.to.x ) {
        childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );
        childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );
      }

      if ( restore ) {
        $.effects.saveStyle( child );
      }

      // Animate children
      child.css( childFrom );
      child.animate( childTo, options.duration, options.easing, function() {

        // Restore children
        if ( restore ) {
          $.effects.restoreStyle( child );
        }
      } );
    } );
  }

  // Animate
  element.animate( to, {
    queue: false,
    duration: options.duration,
    easing: options.easing,
    complete: function() {

      var offset = element.offset();

      if ( to.opacity === 0 ) {
        element.css( "opacity", from.opacity );
      }

      if ( !restore ) {
        element
          .css( "position", position === "static" ? "relative" : position )
          .offset( offset );

        // Need to save style here so that automatic style restoration
        // doesn't restore to the original styles from before the animation.
        $.effects.saveStyle( element );
      }

      done();
    }
  } );

} );


/*!
 * jQuery UI Effects Scale 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Scale Effect
//>>group: Effects
//>>description: Grows or shrinks an element and its content.
//>>docs: http://api.jqueryui.com/scale-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectScale = $.effects.define( "scale", function( options, done ) {

  // Create element
  var el = $( this ),
    mode = options.mode,
    percent = parseInt( options.percent, 10 ) ||
      ( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !== "effect" ? 0 : 100 ) ),

    newOptions = $.extend( true, {
      from: $.effects.scaledDimensions( el ),
      to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),
      origin: options.origin || [ "middle", "center" ]
    }, options );

  // Fade option to support puff
  if ( options.fade ) {
    newOptions.from.opacity = 1;
    newOptions.to.opacity = 0;
  }

  $.effects.effect.size.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Puff 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Puff Effect
//>>group: Effects
//>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
//>>docs: http://api.jqueryui.com/puff-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {
  var newOptions = $.extend( true, {}, options, {
    fade: true,
    percent: parseInt( options.percent, 10 ) || 150
  } );

  $.effects.effect.scale.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Pulsate 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Pulsate Effect
//>>group: Effects
//>>description: Pulsates an element n times by changing the opacity to zero and back.
//>>docs: http://api.jqueryui.com/pulsate-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {
  var element = $( this ),
    mode = options.mode,
    show = mode === "show",
    hide = mode === "hide",
    showhide = show || hide,

    // Showing or hiding leaves off the "last" animation
    anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
    duration = options.duration / anims,
    animateTo = 0,
    i = 1,
    queuelen = element.queue().length;

  if ( show || !element.is( ":visible" ) ) {
    element.css( "opacity", 0 ).show();
    animateTo = 1;
  }

  // Anims - 1 opacity "toggles"
  for ( ; i < anims; i++ ) {
    element.animate( { opacity: animateTo }, duration, options.easing );
    animateTo = 1 - animateTo;
  }

  element.animate( { opacity: animateTo }, duration, options.easing );

  element.queue( done );

  $.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Shake 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Shake Effect
//>>group: Effects
//>>description: Shakes an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/shake-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectShake = $.effects.define( "shake", function( options, done ) {

  var i = 1,
    element = $( this ),
    direction = options.direction || "left",
    distance = options.distance || 20,
    times = options.times || 3,
    anims = times * 2 + 1,
    speed = Math.round( options.duration / anims ),
    ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
    positiveMotion = ( direction === "up" || direction === "left" ),
    animation = {},
    animation1 = {},
    animation2 = {},

    queuelen = element.queue().length;

  $.effects.createPlaceholder( element );

  // Animation
  animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
  animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
  animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

  // Animate
  element.animate( animation, speed, options.easing );

  // Shakes
  for ( ; i < times; i++ ) {
    element
      .animate( animation1, speed, options.easing )
      .animate( animation2, speed, options.easing );
  }

  element
    .animate( animation1, speed, options.easing )
    .animate( animation, speed / 2, options.easing )
    .queue( done );

  $.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Slide 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slide Effect
//>>group: Effects
//>>description: Slides an element in and out of the viewport.
//>>docs: http://api.jqueryui.com/slide-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {
  var startClip, startRef,
    element = $( this ),
    map = {
      up: [ "bottom", "top" ],
      down: [ "top", "bottom" ],
      left: [ "right", "left" ],
      right: [ "left", "right" ]
    },
    mode = options.mode,
    direction = options.direction || "left",
    ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
    positiveMotion = ( direction === "up" || direction === "left" ),
    distance = options.distance ||
      element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),
    animation = {};

  $.effects.createPlaceholder( element );

  startClip = element.cssClip();
  startRef = element.position()[ ref ];

  // Define hide animation
  animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;
  animation.clip = element.cssClip();
  animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];

  // Reverse the animation if we're showing
  if ( mode === "show" ) {
    element.cssClip( animation.clip );
    element.css( ref, animation[ ref ] );
    animation.clip = startClip;
    animation[ ref ] = startRef;
  }

  // Actually animate
  element.animate( animation, {
    queue: false,
    duration: options.duration,
    easing: options.easing,
    complete: done
  } );
} );


/*!
 * jQuery UI Effects Transfer 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Transfer Effect
//>>group: Effects
//>>description: Displays a transfer effect from one element to another.
//>>docs: http://api.jqueryui.com/transfer-effect/
//>>demos: http://jqueryui.com/effect/



var effect;
if ( $.uiBackCompat !== false ) {
  effect = $.effects.define( "transfer", function( options, done ) {
    $( this ).transfer( options, done );
  } );
}
var effectsEffectTransfer = effect;


/*!
 * jQuery UI Focusable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :focusable Selector
//>>group: Core
//>>description: Selects elements which can be focused.
//>>docs: http://api.jqueryui.com/focusable-selector/



// Selectors
$.ui.focusable = function( element, hasTabindex ) {
  var map, mapName, img, focusableIfVisible, fieldset,
    nodeName = element.nodeName.toLowerCase();

  if ( "area" === nodeName ) {
    map = element.parentNode;
    mapName = map.name;
    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
      return false;
    }
    img = $( "img[usemap='#" + mapName + "']" );
    return img.length > 0 && img.is( ":visible" );
  }

  if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
    focusableIfVisible = !element.disabled;

    if ( focusableIfVisible ) {

      // Form controls within a disabled fieldset are disabled.
      // However, controls within the fieldset's legend do not get disabled.
      // Since controls generally aren't placed inside legends, we skip
      // this portion of the check.
      fieldset = $( element ).closest( "fieldset" )[ 0 ];
      if ( fieldset ) {
        focusableIfVisible = !fieldset.disabled;
      }
    }
  } else if ( "a" === nodeName ) {
    focusableIfVisible = element.href || hasTabindex;
  } else {
    focusableIfVisible = hasTabindex;
  }

  return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
};

// Support: IE 8 only
// IE 8 doesn't resolve inherit to visible/hidden for computed values
function visible( element ) {
  var visibility = element.css( "visibility" );
  while ( visibility === "inherit" ) {
    element = element.parent();
    visibility = element.css( "visibility" );
  }
  return visibility !== "hidden";
}

$.extend( $.expr[ ":" ], {
  focusable: function( element ) {
    return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
  }
} );

var focusable = $.ui.focusable;




// Support: IE8 Only
// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
// with a string, so we need to find the proper form.
var form = $.fn.form = function() {
  return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
};


/*!
 * jQuery UI Form Reset Mixin 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Form Reset Mixin
//>>group: Core
//>>description: Refresh input widgets when their form is reset
//>>docs: http://api.jqueryui.com/form-reset-mixin/



var formResetMixin = $.ui.formResetMixin = {
  _formResetHandler: function() {
    var form = $( this );

    // Wait for the form reset to actually happen before refreshing
    setTimeout( function() {
      var instances = form.data( "ui-form-reset-instances" );
      $.each( instances, function() {
        this.refresh();
      } );
    } );
  },

  _bindFormResetHandler: function() {
    this.form = this.element.form();
    if ( !this.form.length ) {
      return;
    }

    var instances = this.form.data( "ui-form-reset-instances" ) || [];
    if ( !instances.length ) {

      // We don't use _on() here because we use a single event handler per form
      this.form.on( "reset.ui-form-reset", this._formResetHandler );
    }
    instances.push( this );
    this.form.data( "ui-form-reset-instances", instances );
  },

  _unbindFormResetHandler: function() {
    if ( !this.form.length ) {
      return;
    }

    var instances = this.form.data( "ui-form-reset-instances" );
    instances.splice( $.inArray( this, instances ), 1 );
    if ( instances.length ) {
      this.form.data( "ui-form-reset-instances", instances );
    } else {
      this.form
        .removeData( "ui-form-reset-instances" )
        .off( "reset.ui-form-reset" );
    }
  }
};


/*!
 * jQuery UI Support for jQuery core 1.7.x 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

//>>label: jQuery 1.7 Support
//>>group: Core
//>>description: Support version 1.7.x of jQuery core



// Support: jQuery 1.7 only
// Not a great way to check versions, but since we only support 1.7+ and only
// need to detect <1.8, this is a simple check that should suffice. Checking
// for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
// and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
// 1.7 anymore). See #11197 for why we're not using feature detection.
if ( $.fn.jquery.substring( 0, 3 ) === "1.7" ) {

  // Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
  // Unlike jQuery Core 1.8+, these only support numeric values to set the
  // dimensions in pixels
  $.each( [ "Width", "Height" ], function( i, name ) {
    var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
      type = name.toLowerCase(),
      orig = {
        innerWidth: $.fn.innerWidth,
        innerHeight: $.fn.innerHeight,
        outerWidth: $.fn.outerWidth,
        outerHeight: $.fn.outerHeight
      };

    function reduce( elem, size, border, margin ) {
      $.each( side, function() {
        size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
        if ( border ) {
          size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
        }
        if ( margin ) {
          size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
        }
      } );
      return size;
    }

    $.fn[ "inner" + name ] = function( size ) {
      if ( size === undefined ) {
        return orig[ "inner" + name ].call( this );
      }

      return this.each( function() {
        $( this ).css( type, reduce( this, size ) + "px" );
      } );
    };

    $.fn[ "outer" + name ] = function( size, margin ) {
      if ( typeof size !== "number" ) {
        return orig[ "outer" + name ].call( this, size );
      }

      return this.each( function() {
        $( this ).css( type, reduce( this, size, true, margin ) + "px" );
      } );
    };
  } );

  $.fn.addBack = function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter( selector )
    );
  };
}

;
/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
  BACKSPACE: 8,
  COMMA: 188,
  DELETE: 46,
  DOWN: 40,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  HOME: 36,
  LEFT: 37,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PERIOD: 190,
  RIGHT: 39,
  SPACE: 32,
  TAB: 9,
  UP: 38
};




// Internal use only
var escapeSelector = $.ui.escapeSelector = ( function() {
  var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
  return function( selector ) {
    return selector.replace( selectorEscape, "\\$1" );
  };
} )();


/*!
 * jQuery UI Labels 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: labels
//>>group: Core
//>>description: Find all the labels associated with a given input
//>>docs: http://api.jqueryui.com/labels/



var labels = $.fn.labels = function() {
  var ancestor, selector, id, labels, ancestors;

  // Check control.labels first
  if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
    return this.pushStack( this[ 0 ].labels );
  }

  // Support: IE <= 11, FF <= 37, Android <= 2.3 only
  // Above browsers do not support control.labels. Everything below is to support them
  // as well as document fragments. control.labels does not work on document fragments
  labels = this.eq( 0 ).parents( "label" );

  // Look for the label based on the id
  id = this.attr( "id" );
  if ( id ) {

    // We don't search against the document in case the element
    // is disconnected from the DOM
    ancestor = this.eq( 0 ).parents().last();

    // Get a full set of top level ancestors
    ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

    // Create a selector for the label based on the id
    selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

    labels = labels.add( ancestors.find( selector ).addBack( selector ) );

  }

  // Return whatever we have found for labels
  return this.pushStack( labels );
};


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
  var position = this.css( "position" ),
    excludeStaticParent = position === "absolute",
    overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
    scrollParent = this.parents().filter( function() {
      var parent = $( this );
      if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
        return false;
      }
      return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
        parent.css( "overflow-x" ) );
    } ).eq( 0 );

  return position === "fixed" || !scrollParent.length ?
    $( this[ 0 ].ownerDocument || document ) :
    scrollParent;
};


/*!
 * jQuery UI Tabbable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :tabbable Selector
//>>group: Core
//>>description: Selects elements which can be tabbed to.
//>>docs: http://api.jqueryui.com/tabbable-selector/



var tabbable = $.extend( $.expr[ ":" ], {
  tabbable: function( element ) {
    var tabIndex = $.attr( element, "tabindex" ),
      hasTabindex = tabIndex != null;
    return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
  }
} );


/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
  uniqueId: ( function() {
    var uuid = 0;

    return function() {
      return this.each( function() {
        if ( !this.id ) {
          this.id = "ui-id-" + ( ++uuid );
        }
      } );
    };
  } )(),

  removeUniqueId: function() {
    return this.each( function() {
      if ( /^ui-id-\d+$/.test( this.id ) ) {
        $( this ).removeAttr( "id" );
      }
    } );
  }
} );


/*!
 * jQuery UI Accordion 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Accordion
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays collapsible content panels for presenting information in a limited amount of space.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/accordion/
//>>demos: http://jqueryui.com/accordion/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/accordion.css
//>>css.theme: ../../themes/base/theme.css



var widgetsAccordion = $.widget( "ui.accordion", {
  version: "1.12.1",
  options: {
    active: 0,
    animate: {},
    classes: {
      "ui-accordion-header": "ui-corner-top",
      "ui-accordion-header-collapsed": "ui-corner-all",
      "ui-accordion-content": "ui-corner-bottom"
    },
    collapsible: false,
    event: "click",
    header: "> li > :first-child, > :not(li):even",
    heightStyle: "auto",
    icons: {
      activeHeader: "ui-icon-triangle-1-s",
      header: "ui-icon-triangle-1-e"
    },

    // Callbacks
    activate: null,
    beforeActivate: null
  },

  hideProps: {
    borderTopWidth: "hide",
    borderBottomWidth: "hide",
    paddingTop: "hide",
    paddingBottom: "hide",
    height: "hide"
  },

  showProps: {
    borderTopWidth: "show",
    borderBottomWidth: "show",
    paddingTop: "show",
    paddingBottom: "show",
    height: "show"
  },

  _create: function() {
    var options = this.options;

    this.prevShow = this.prevHide = $();
    this._addClass( "ui-accordion", "ui-widget ui-helper-reset" );
    this.element.attr( "role", "tablist" );

    // Don't allow collapsible: false and active: false / null
    if ( !options.collapsible && ( options.active === false || options.active == null ) ) {
      options.active = 0;
    }

    this._processPanels();

    // handle negative values
    if ( options.active < 0 ) {
      options.active += this.headers.length;
    }
    this._refresh();
  },

  _getCreateEventData: function() {
    return {
      header: this.active,
      panel: !this.active.length ? $() : this.active.next()
    };
  },

  _createIcons: function() {
    var icon, children,
      icons = this.options.icons;

    if ( icons ) {
      icon = $( "<span>" );
      this._addClass( icon, "ui-accordion-header-icon", "ui-icon " + icons.header );
      icon.prependTo( this.headers );
      children = this.active.children( ".ui-accordion-header-icon" );
      this._removeClass( children, icons.header )
        ._addClass( children, null, icons.activeHeader )
        ._addClass( this.headers, "ui-accordion-icons" );
    }
  },

  _destroyIcons: function() {
    this._removeClass( this.headers, "ui-accordion-icons" );
    this.headers.children( ".ui-accordion-header-icon" ).remove();
  },

  _destroy: function() {
    var contents;

    // Clean up main element
    this.element.removeAttr( "role" );

    // Clean up headers
    this.headers
      .removeAttr( "role aria-expanded aria-selected aria-controls tabIndex" )
      .removeUniqueId();

    this._destroyIcons();

    // Clean up content panels
    contents = this.headers.next()
      .css( "display", "" )
      .removeAttr( "role aria-hidden aria-labelledby" )
      .removeUniqueId();

    if ( this.options.heightStyle !== "content" ) {
      contents.css( "height", "" );
    }
  },

  _setOption: function( key, value ) {
    if ( key === "active" ) {

      // _activate() will handle invalid values and update this.options
      this._activate( value );
      return;
    }

    if ( key === "event" ) {
      if ( this.options.event ) {
        this._off( this.headers, this.options.event );
      }
      this._setupEvents( value );
    }

    this._super( key, value );

    // Setting collapsible: false while collapsed; open first panel
    if ( key === "collapsible" && !value && this.options.active === false ) {
      this._activate( 0 );
    }

    if ( key === "icons" ) {
      this._destroyIcons();
      if ( value ) {
        this._createIcons();
      }
    }
  },

  _setOptionDisabled: function( value ) {
    this._super( value );

    this.element.attr( "aria-disabled", value );

    // Support: IE8 Only
    // #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
    // so we need to add the disabled class to the headers and panels
    this._toggleClass( null, "ui-state-disabled", !!value );
    this._toggleClass( this.headers.add( this.headers.next() ), null, "ui-state-disabled",
      !!value );
  },

  _keydown: function( event ) {
    if ( event.altKey || event.ctrlKey ) {
      return;
    }

    var keyCode = $.ui.keyCode,
      length = this.headers.length,
      currentIndex = this.headers.index( event.target ),
      toFocus = false;

    switch ( event.keyCode ) {
    case keyCode.RIGHT:
    case keyCode.DOWN:
      toFocus = this.headers[ ( currentIndex + 1 ) % length ];
      break;
    case keyCode.LEFT:
    case keyCode.UP:
      toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
      break;
    case keyCode.SPACE:
    case keyCode.ENTER:
      this._eventHandler( event );
      break;
    case keyCode.HOME:
      toFocus = this.headers[ 0 ];
      break;
    case keyCode.END:
      toFocus = this.headers[ length - 1 ];
      break;
    }

    if ( toFocus ) {
      $( event.target ).attr( "tabIndex", -1 );
      $( toFocus ).attr( "tabIndex", 0 );
      $( toFocus ).trigger( "focus" );
      event.preventDefault();
    }
  },

  _panelKeyDown: function( event ) {
    if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
      $( event.currentTarget ).prev().trigger( "focus" );
    }
  },

  refresh: function() {
    var options = this.options;
    this._processPanels();

    // Was collapsed or no panel
    if ( ( options.active === false && options.collapsible === true ) ||
        !this.headers.length ) {
      options.active = false;
      this.active = $();

    // active false only when collapsible is true
    } else if ( options.active === false ) {
      this._activate( 0 );

    // was active, but active panel is gone
    } else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {

      // all remaining panel are disabled
      if ( this.headers.length === this.headers.find( ".ui-state-disabled" ).length ) {
        options.active = false;
        this.active = $();

      // activate previous panel
      } else {
        this._activate( Math.max( 0, options.active - 1 ) );
      }

    // was active, active panel still exists
    } else {

      // make sure active index is correct
      options.active = this.headers.index( this.active );
    }

    this._destroyIcons();

    this._refresh();
  },

  _processPanels: function() {
    var prevHeaders = this.headers,
      prevPanels = this.panels;

    this.headers = this.element.find( this.options.header );
    this._addClass( this.headers, "ui-accordion-header ui-accordion-header-collapsed",
      "ui-state-default" );

    this.panels = this.headers.next().filter( ":not(.ui-accordion-content-active)" ).hide();
    this._addClass( this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content" );

    // Avoid memory leaks (#10056)
    if ( prevPanels ) {
      this._off( prevHeaders.not( this.headers ) );
      this._off( prevPanels.not( this.panels ) );
    }
  },

  _refresh: function() {
    var maxHeight,
      options = this.options,
      heightStyle = options.heightStyle,
      parent = this.element.parent();

    this.active = this._findActive( options.active );
    this._addClass( this.active, "ui-accordion-header-active", "ui-state-active" )
      ._removeClass( this.active, "ui-accordion-header-collapsed" );
    this._addClass( this.active.next(), "ui-accordion-content-active" );
    this.active.next().show();

    this.headers
      .attr( "role", "tab" )
      .each( function() {
        var header = $( this ),
          headerId = header.uniqueId().attr( "id" ),
          panel = header.next(),
          panelId = panel.uniqueId().attr( "id" );
        header.attr( "aria-controls", panelId );
        panel.attr( "aria-labelledby", headerId );
      } )
      .next()
        .attr( "role", "tabpanel" );

    this.headers
      .not( this.active )
        .attr( {
          "aria-selected": "false",
          "aria-expanded": "false",
          tabIndex: -1
        } )
        .next()
          .attr( {
            "aria-hidden": "true"
          } )
          .hide();

    // Make sure at least one header is in the tab order
    if ( !this.active.length ) {
      this.headers.eq( 0 ).attr( "tabIndex", 0 );
    } else {
      this.active.attr( {
        "aria-selected": "true",
        "aria-expanded": "true",
        tabIndex: 0
      } )
        .next()
          .attr( {
            "aria-hidden": "false"
          } );
    }

    this._createIcons();

    this._setupEvents( options.event );

    if ( heightStyle === "fill" ) {
      maxHeight = parent.height();
      this.element.siblings( ":visible" ).each( function() {
        var elem = $( this ),
          position = elem.css( "position" );

        if ( position === "absolute" || position === "fixed" ) {
          return;
        }
        maxHeight -= elem.outerHeight( true );
      } );

      this.headers.each( function() {
        maxHeight -= $( this ).outerHeight( true );
      } );

      this.headers.next()
        .each( function() {
          $( this ).height( Math.max( 0, maxHeight -
            $( this ).innerHeight() + $( this ).height() ) );
        } )
        .css( "overflow", "auto" );
    } else if ( heightStyle === "auto" ) {
      maxHeight = 0;
      this.headers.next()
        .each( function() {
          var isVisible = $( this ).is( ":visible" );
          if ( !isVisible ) {
            $( this ).show();
          }
          maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
          if ( !isVisible ) {
            $( this ).hide();
          }
        } )
        .height( maxHeight );
    }
  },

  _activate: function( index ) {
    var active = this._findActive( index )[ 0 ];

    // Trying to activate the already active panel
    if ( active === this.active[ 0 ] ) {
      return;
    }

    // Trying to collapse, simulate a click on the currently active header
    active = active || this.active[ 0 ];

    this._eventHandler( {
      target: active,
      currentTarget: active,
      preventDefault: $.noop
    } );
  },

  _findActive: function( selector ) {
    return typeof selector === "number" ? this.headers.eq( selector ) : $();
  },

  _setupEvents: function( event ) {
    var events = {
      keydown: "_keydown"
    };
    if ( event ) {
      $.each( event.split( " " ), function( index, eventName ) {
        events[ eventName ] = "_eventHandler";
      } );
    }

    this._off( this.headers.add( this.headers.next() ) );
    this._on( this.headers, events );
    this._on( this.headers.next(), { keydown: "_panelKeyDown" } );
    this._hoverable( this.headers );
    this._focusable( this.headers );
  },

  _eventHandler: function( event ) {
    var activeChildren, clickedChildren,
      options = this.options,
      active = this.active,
      clicked = $( event.currentTarget ),
      clickedIsActive = clicked[ 0 ] === active[ 0 ],
      collapsing = clickedIsActive && options.collapsible,
      toShow = collapsing ? $() : clicked.next(),
      toHide = active.next(),
      eventData = {
        oldHeader: active,
        oldPanel: toHide,
        newHeader: collapsing ? $() : clicked,
        newPanel: toShow
      };

    event.preventDefault();

    if (

        // click on active header, but not collapsible
        ( clickedIsActive && !options.collapsible ) ||

        // allow canceling activation
        ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
      return;
    }

    options.active = collapsing ? false : this.headers.index( clicked );

    // When the call to ._toggle() comes after the class changes
    // it causes a very odd bug in IE 8 (see #6720)
    this.active = clickedIsActive ? $() : clicked;
    this._toggle( eventData );

    // Switch classes
    // corner classes on the previously active header stay after the animation
    this._removeClass( active, "ui-accordion-header-active", "ui-state-active" );
    if ( options.icons ) {
      activeChildren = active.children( ".ui-accordion-header-icon" );
      this._removeClass( activeChildren, null, options.icons.activeHeader )
        ._addClass( activeChildren, null, options.icons.header );
    }

    if ( !clickedIsActive ) {
      this._removeClass( clicked, "ui-accordion-header-collapsed" )
        ._addClass( clicked, "ui-accordion-header-active", "ui-state-active" );
      if ( options.icons ) {
        clickedChildren = clicked.children( ".ui-accordion-header-icon" );
        this._removeClass( clickedChildren, null, options.icons.header )
          ._addClass( clickedChildren, null, options.icons.activeHeader );
      }

      this._addClass( clicked.next(), "ui-accordion-content-active" );
    }
  },

  _toggle: function( data ) {
    var toShow = data.newPanel,
      toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

    // Handle activating a panel during the animation for another activation
    this.prevShow.add( this.prevHide ).stop( true, true );
    this.prevShow = toShow;
    this.prevHide = toHide;

    if ( this.options.animate ) {
      this._animate( toShow, toHide, data );
    } else {
      toHide.hide();
      toShow.show();
      this._toggleComplete( data );
    }

    toHide.attr( {
      "aria-hidden": "true"
    } );
    toHide.prev().attr( {
      "aria-selected": "false",
      "aria-expanded": "false"
    } );

    // if we're switching panels, remove the old header from the tab order
    // if we're opening from collapsed state, remove the previous header from the tab order
    // if we're collapsing, then keep the collapsing header in the tab order
    if ( toShow.length && toHide.length ) {
      toHide.prev().attr( {
        "tabIndex": -1,
        "aria-expanded": "false"
      } );
    } else if ( toShow.length ) {
      this.headers.filter( function() {
        return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
      } )
        .attr( "tabIndex", -1 );
    }

    toShow
      .attr( "aria-hidden", "false" )
      .prev()
        .attr( {
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        } );
  },

  _animate: function( toShow, toHide, data ) {
    var total, easing, duration,
      that = this,
      adjust = 0,
      boxSizing = toShow.css( "box-sizing" ),
      down = toShow.length &&
        ( !toHide.length || ( toShow.index() < toHide.index() ) ),
      animate = this.options.animate || {},
      options = down && animate.down || animate,
      complete = function() {
        that._toggleComplete( data );
      };

    if ( typeof options === "number" ) {
      duration = options;
    }
    if ( typeof options === "string" ) {
      easing = options;
    }

    // fall back from options to animation in case of partial down settings
    easing = easing || options.easing || animate.easing;
    duration = duration || options.duration || animate.duration;

    if ( !toHide.length ) {
      return toShow.animate( this.showProps, duration, easing, complete );
    }
    if ( !toShow.length ) {
      return toHide.animate( this.hideProps, duration, easing, complete );
    }

    total = toShow.show().outerHeight();
    toHide.animate( this.hideProps, {
      duration: duration,
      easing: easing,
      step: function( now, fx ) {
        fx.now = Math.round( now );
      }
    } );
    toShow
      .hide()
      .animate( this.showProps, {
        duration: duration,
        easing: easing,
        complete: complete,
        step: function( now, fx ) {
          fx.now = Math.round( now );
          if ( fx.prop !== "height" ) {
            if ( boxSizing === "content-box" ) {
              adjust += fx.now;
            }
          } else if ( that.options.heightStyle !== "content" ) {
            fx.now = Math.round( total - toHide.outerHeight() - adjust );
            adjust = 0;
          }
        }
      } );
  },

  _toggleComplete: function( data ) {
    var toHide = data.oldPanel,
      prev = toHide.prev();

    this._removeClass( toHide, "ui-accordion-content-active" );
    this._removeClass( prev, "ui-accordion-header-active" )
      ._addClass( prev, "ui-accordion-header-collapsed" );

    // Work around for rendering bug in IE (#5421)
    if ( toHide.length ) {
      toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
    }
    this._trigger( "activate", null, data );
  }
} );



var safeActiveElement = $.ui.safeActiveElement = function( document ) {
  var activeElement;

  // Support: IE 9 only
  // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
  try {
    activeElement = document.activeElement;
  } catch ( error ) {
    activeElement = document.body;
  }

  // Support: IE 9 - 11 only
  // IE may return null instead of an element
  // Interestingly, this only seems to occur when NOT in an iframe
  if ( !activeElement ) {
    activeElement = document.body;
  }

  // Support: IE 11 only
  // IE11 returns a seemingly empty object in some cases when accessing
  // document.activeElement from an <iframe>
  if ( !activeElement.nodeName ) {
    activeElement = document.body;
  }

  return activeElement;
};


/*!
 * jQuery UI Menu 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Menu
//>>group: Widgets
//>>description: Creates nestable menus.
//>>docs: http://api.jqueryui.com/menu/
//>>demos: http://jqueryui.com/menu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/menu.css
//>>css.theme: ../../themes/base/theme.css



var widgetsMenu = $.widget( "ui.menu", {
  version: "1.12.1",
  defaultElement: "<ul>",
  delay: 300,
  options: {
    icons: {
      submenu: "ui-icon-caret-1-e"
    },
    items: "> *",
    menus: "ul",
    position: {
      my: "left top",
      at: "right top"
    },
    role: "menu",

    // Callbacks
    blur: null,
    focus: null,
    select: null
  },

  _create: function() {
    this.activeMenu = this.element;

    // Flag used to prevent firing of the click handler
    // as the event bubbles up through nested menus
    this.mouseHandled = false;
    this.element
      .uniqueId()
      .attr( {
        role: this.options.role,
        tabIndex: 0
      } );

    this._addClass( "ui-menu", "ui-widget ui-widget-content" );
    this._on( {

      // Prevent focus from sticking to links inside menu after clicking
      // them (focus should always stay on UL during navigation).
      "mousedown .ui-menu-item": function( event ) {
        event.preventDefault();
      },
      "click .ui-menu-item": function( event ) {
        var target = $( event.target );
        var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
        if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
          this.select( event );

          // Only set the mouseHandled flag if the event will bubble, see #9469.
          if ( !event.isPropagationStopped() ) {
            this.mouseHandled = true;
          }

          // Open submenu on click
          if ( target.has( ".ui-menu" ).length ) {
            this.expand( event );
          } else if ( !this.element.is( ":focus" ) &&
              active.closest( ".ui-menu" ).length ) {

            // Redirect focus to the menu
            this.element.trigger( "focus", [ true ] );

            // If the active item is on the top level, let it stay active.
            // Otherwise, blur the active item since it is no longer visible.
            if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
              clearTimeout( this.timer );
            }
          }
        }
      },
      "mouseenter .ui-menu-item": function( event ) {

        // Ignore mouse events while typeahead is active, see #10458.
        // Prevents focusing the wrong item when typeahead causes a scroll while the mouse
        // is over an item in the menu
        if ( this.previousFilter ) {
          return;
        }

        var actualTarget = $( event.target ).closest( ".ui-menu-item" ),
          target = $( event.currentTarget );

        // Ignore bubbled events on parent items, see #11641
        if ( actualTarget[ 0 ] !== target[ 0 ] ) {
          return;
        }

        // Remove ui-state-active class from siblings of the newly focused menu item
        // to avoid a jump caused by adjacent elements both having a class with a border
        this._removeClass( target.siblings().children( ".ui-state-active" ),
          null, "ui-state-active" );
        this.focus( event, target );
      },
      mouseleave: "collapseAll",
      "mouseleave .ui-menu": "collapseAll",
      focus: function( event, keepActiveItem ) {

        // If there's already an active item, keep it active
        // If not, activate the first item
        var item = this.active || this.element.find( this.options.items ).eq( 0 );

        if ( !keepActiveItem ) {
          this.focus( event, item );
        }
      },
      blur: function( event ) {
        this._delay( function() {
          var notContained = !$.contains(
            this.element[ 0 ],
            $.ui.safeActiveElement( this.document[ 0 ] )
          );
          if ( notContained ) {
            this.collapseAll( event );
          }
        } );
      },
      keydown: "_keydown"
    } );

    this.refresh();

    // Clicks outside of a menu collapse any open menus
    this._on( this.document, {
      click: function( event ) {
        if ( this._closeOnDocumentClick( event ) ) {
          this.collapseAll( event );
        }

        // Reset the mouseHandled flag
        this.mouseHandled = false;
      }
    } );
  },

  _destroy: function() {
    var items = this.element.find( ".ui-menu-item" )
        .removeAttr( "role aria-disabled" ),
      submenus = items.children( ".ui-menu-item-wrapper" )
        .removeUniqueId()
        .removeAttr( "tabIndex role aria-haspopup" );

    // Destroy (sub)menus
    this.element
      .removeAttr( "aria-activedescendant" )
      .find( ".ui-menu" ).addBack()
        .removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
          "tabIndex" )
        .removeUniqueId()
        .show();

    submenus.children().each( function() {
      var elem = $( this );
      if ( elem.data( "ui-menu-submenu-caret" ) ) {
        elem.remove();
      }
    } );
  },

  _keydown: function( event ) {
    var match, prev, character, skip,
      preventDefault = true;

    switch ( event.keyCode ) {
    case $.ui.keyCode.PAGE_UP:
      this.previousPage( event );
      break;
    case $.ui.keyCode.PAGE_DOWN:
      this.nextPage( event );
      break;
    case $.ui.keyCode.HOME:
      this._move( "first", "first", event );
      break;
    case $.ui.keyCode.END:
      this._move( "last", "last", event );
      break;
    case $.ui.keyCode.UP:
      this.previous( event );
      break;
    case $.ui.keyCode.DOWN:
      this.next( event );
      break;
    case $.ui.keyCode.LEFT:
      this.collapse( event );
      break;
    case $.ui.keyCode.RIGHT:
      if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
        this.expand( event );
      }
      break;
    case $.ui.keyCode.ENTER:
    case $.ui.keyCode.SPACE:
      this._activate( event );
      break;
    case $.ui.keyCode.ESCAPE:
      this.collapse( event );
      break;
    default:
      preventDefault = false;
      prev = this.previousFilter || "";
      skip = false;

      // Support number pad values
      character = event.keyCode >= 96 && event.keyCode <= 105 ?
        ( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );

      clearTimeout( this.filterTimer );

      if ( character === prev ) {
        skip = true;
      } else {
        character = prev + character;
      }

      match = this._filterMenuItems( character );
      match = skip && match.index( this.active.next() ) !== -1 ?
        this.active.nextAll( ".ui-menu-item" ) :
        match;

      // If no matches on the current filter, reset to the last character pressed
      // to move down the menu to the first item that starts with that character
      if ( !match.length ) {
        character = String.fromCharCode( event.keyCode );
        match = this._filterMenuItems( character );
      }

      if ( match.length ) {
        this.focus( event, match );
        this.previousFilter = character;
        this.filterTimer = this._delay( function() {
          delete this.previousFilter;
        }, 1000 );
      } else {
        delete this.previousFilter;
      }
    }

    if ( preventDefault ) {
      event.preventDefault();
    }
  },

  _activate: function( event ) {
    if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
      if ( this.active.children( "[aria-haspopup='true']" ).length ) {
        this.expand( event );
      } else {
        this.select( event );
      }
    }
  },

  refresh: function() {
    var menus, items, newSubmenus, newItems, newWrappers,
      that = this,
      icon = this.options.icons.submenu,
      submenus = this.element.find( this.options.menus );

    this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length );

    // Initialize nested menus
    newSubmenus = submenus.filter( ":not(.ui-menu)" )
      .hide()
      .attr( {
        role: this.options.role,
        "aria-hidden": "true",
        "aria-expanded": "false"
      } )
      .each( function() {
        var menu = $( this ),
          item = menu.prev(),
          submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );

        that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );
        item
          .attr( "aria-haspopup", "true" )
          .prepend( submenuCaret );
        menu.attr( "aria-labelledby", item.attr( "id" ) );
      } );

    this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );

    menus = submenus.add( this.element );
    items = menus.find( this.options.items );

    // Initialize menu-items containing spaces and/or dashes only as dividers
    items.not( ".ui-menu-item" ).each( function() {
      var item = $( this );
      if ( that._isDivider( item ) ) {
        that._addClass( item, "ui-menu-divider", "ui-widget-content" );
      }
    } );

    // Don't refresh list items that are already adapted
    newItems = items.not( ".ui-menu-item, .ui-menu-divider" );
    newWrappers = newItems.children()
      .not( ".ui-menu" )
        .uniqueId()
        .attr( {
          tabIndex: -1,
          role: this._itemRole()
        } );
    this._addClass( newItems, "ui-menu-item" )
      ._addClass( newWrappers, "ui-menu-item-wrapper" );

    // Add aria-disabled attribute to any disabled menu item
    items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

    // If the active item has been removed, blur the menu
    if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
      this.blur();
    }
  },

  _itemRole: function() {
    return {
      menu: "menuitem",
      listbox: "option"
    }[ this.options.role ];
  },

  _setOption: function( key, value ) {
    if ( key === "icons" ) {
      var icons = this.element.find( ".ui-menu-icon" );
      this._removeClass( icons, null, this.options.icons.submenu )
        ._addClass( icons, null, value.submenu );
    }
    this._super( key, value );
  },

  _setOptionDisabled: function( value ) {
    this._super( value );

    this.element.attr( "aria-disabled", String( value ) );
    this._toggleClass( null, "ui-state-disabled", !!value );
  },

  focus: function( event, item ) {
    var nested, focused, activeParent;
    this.blur( event, event && event.type === "focus" );

    this._scrollIntoView( item );

    this.active = item.first();

    focused = this.active.children( ".ui-menu-item-wrapper" );
    this._addClass( focused, null, "ui-state-active" );

    // Only update aria-activedescendant if there's a role
    // otherwise we assume focus is managed elsewhere
    if ( this.options.role ) {
      this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
    }

    // Highlight active parent menu item, if any
    activeParent = this.active
      .parent()
        .closest( ".ui-menu-item" )
          .children( ".ui-menu-item-wrapper" );
    this._addClass( activeParent, null, "ui-state-active" );

    if ( event && event.type === "keydown" ) {
      this._close();
    } else {
      this.timer = this._delay( function() {
        this._close();
      }, this.delay );
    }

    nested = item.children( ".ui-menu" );
    if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
      this._startOpening( nested );
    }
    this.activeMenu = item.parent();

    this._trigger( "focus", event, { item: item } );
  },

  _scrollIntoView: function( item ) {
    var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
    if ( this._hasScroll() ) {
      borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
      paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
      offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
      scroll = this.activeMenu.scrollTop();
      elementHeight = this.activeMenu.height();
      itemHeight = item.outerHeight();

      if ( offset < 0 ) {
        this.activeMenu.scrollTop( scroll + offset );
      } else if ( offset + itemHeight > elementHeight ) {
        this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
      }
    }
  },

  blur: function( event, fromFocus ) {
    if ( !fromFocus ) {
      clearTimeout( this.timer );
    }

    if ( !this.active ) {
      return;
    }

    this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
      null, "ui-state-active" );

    this._trigger( "blur", event, { item: this.active } );
    this.active = null;
  },

  _startOpening: function( submenu ) {
    clearTimeout( this.timer );

    // Don't open if already open fixes a Firefox bug that caused a .5 pixel
    // shift in the submenu position when mousing over the caret icon
    if ( submenu.attr( "aria-hidden" ) !== "true" ) {
      return;
    }

    this.timer = this._delay( function() {
      this._close();
      this._open( submenu );
    }, this.delay );
  },

  _open: function( submenu ) {
    var position = $.extend( {
      of: this.active
    }, this.options.position );

    clearTimeout( this.timer );
    this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
      .hide()
      .attr( "aria-hidden", "true" );

    submenu
      .show()
      .removeAttr( "aria-hidden" )
      .attr( "aria-expanded", "true" )
      .position( position );
  },

  collapseAll: function( event, all ) {
    clearTimeout( this.timer );
    this.timer = this._delay( function() {

      // If we were passed an event, look for the submenu that contains the event
      var currentMenu = all ? this.element :
        $( event && event.target ).closest( this.element.find( ".ui-menu" ) );

      // If we found no valid submenu ancestor, use the main menu to close all
      // sub menus anyway
      if ( !currentMenu.length ) {
        currentMenu = this.element;
      }

      this._close( currentMenu );

      this.blur( event );

      // Work around active item staying active after menu is blurred
      this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );

      this.activeMenu = currentMenu;
    }, this.delay );
  },

  // With no arguments, closes the currently active menu - if nothing is active
  // it closes all menus.  If passed an argument, it will search for menus BELOW
  _close: function( startMenu ) {
    if ( !startMenu ) {
      startMenu = this.active ? this.active.parent() : this.element;
    }

    startMenu.find( ".ui-menu" )
      .hide()
      .attr( "aria-hidden", "true" )
      .attr( "aria-expanded", "false" );
  },

  _closeOnDocumentClick: function( event ) {
    return !$( event.target ).closest( ".ui-menu" ).length;
  },

  _isDivider: function( item ) {

    // Match hyphen, em dash, en dash
    return !/[^\-\u2014\u2013\s]/.test( item.text() );
  },

  collapse: function( event ) {
    var newItem = this.active &&
      this.active.parent().closest( ".ui-menu-item", this.element );
    if ( newItem && newItem.length ) {
      this._close();
      this.focus( event, newItem );
    }
  },

  expand: function( event ) {
    var newItem = this.active &&
      this.active
        .children( ".ui-menu " )
          .find( this.options.items )
            .first();

    if ( newItem && newItem.length ) {
      this._open( newItem.parent() );

      // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
      this._delay( function() {
        this.focus( event, newItem );
      } );
    }
  },

  next: function( event ) {
    this._move( "next", "first", event );
  },

  previous: function( event ) {
    this._move( "prev", "last", event );
  },

  isFirstItem: function() {
    return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
  },

  isLastItem: function() {
    return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
  },

  _move: function( direction, filter, event ) {
    var next;
    if ( this.active ) {
      if ( direction === "first" || direction === "last" ) {
        next = this.active
          [ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
          .eq( -1 );
      } else {
        next = this.active
          [ direction + "All" ]( ".ui-menu-item" )
          .eq( 0 );
      }
    }
    if ( !next || !next.length || !this.active ) {
      next = this.activeMenu.find( this.options.items )[ filter ]();
    }

    this.focus( event, next );
  },

  nextPage: function( event ) {
    var item, base, height;

    if ( !this.active ) {
      this.next( event );
      return;
    }
    if ( this.isLastItem() ) {
      return;
    }
    if ( this._hasScroll() ) {
      base = this.active.offset().top;
      height = this.element.height();
      this.active.nextAll( ".ui-menu-item" ).each( function() {
        item = $( this );
        return item.offset().top - base - height < 0;
      } );

      this.focus( event, item );
    } else {
      this.focus( event, this.activeMenu.find( this.options.items )
        [ !this.active ? "first" : "last" ]() );
    }
  },

  previousPage: function( event ) {
    var item, base, height;
    if ( !this.active ) {
      this.next( event );
      return;
    }
    if ( this.isFirstItem() ) {
      return;
    }
    if ( this._hasScroll() ) {
      base = this.active.offset().top;
      height = this.element.height();
      this.active.prevAll( ".ui-menu-item" ).each( function() {
        item = $( this );
        return item.offset().top - base + height > 0;
      } );

      this.focus( event, item );
    } else {
      this.focus( event, this.activeMenu.find( this.options.items ).first() );
    }
  },

  _hasScroll: function() {
    return this.element.outerHeight() < this.element.prop( "scrollHeight" );
  },

  select: function( event ) {

    // TODO: It should never be possible to not have an active item at this
    // point, but the tests don't trigger mouseenter before click.
    this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
    var ui = { item: this.active };
    if ( !this.active.has( ".ui-menu" ).length ) {
      this.collapseAll( event, true );
    }
    this._trigger( "select", event, ui );
  },

  _filterMenuItems: function( character ) {
    var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
      regex = new RegExp( "^" + escapedCharacter, "i" );

    return this.activeMenu
      .find( this.options.items )

        // Only match on items, not dividers or other content (#10571)
        .filter( ".ui-menu-item" )
          .filter( function() {
            return regex.test(
              $.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) );
          } );
  }
} );


/*!
 * jQuery UI Autocomplete 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Autocomplete
//>>group: Widgets
//>>description: Lists suggested words as the user is typing.
//>>docs: http://api.jqueryui.com/autocomplete/
//>>demos: http://jqueryui.com/autocomplete/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/autocomplete.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.autocomplete", {
  version: "1.12.1",
  defaultElement: "<input>",
  options: {
    appendTo: null,
    autoFocus: false,
    delay: 300,
    minLength: 1,
    position: {
      my: "left top",
      at: "left bottom",
      collision: "none"
    },
    source: null,

    // Callbacks
    change: null,
    close: null,
    focus: null,
    open: null,
    response: null,
    search: null,
    select: null
  },

  requestIndex: 0,
  pending: 0,

  _create: function() {

    // Some browsers only repeat keydown events, not keypress events,
    // so we use the suppressKeyPress flag to determine if we've already
    // handled the keydown event. #7269
    // Unfortunately the code for & in keypress is the same as the up arrow,
    // so we use the suppressKeyPressRepeat flag to avoid handling keypress
    // events when we know the keydown event was used to modify the
    // search term. #7799
    var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
      nodeName = this.element[ 0 ].nodeName.toLowerCase(),
      isTextarea = nodeName === "textarea",
      isInput = nodeName === "input";

    // Textareas are always multi-line
    // Inputs are always single-line, even if inside a contentEditable element
    // IE also treats inputs as contentEditable
    // All other element types are determined by whether or not they're contentEditable
    this.isMultiLine = isTextarea || !isInput && this._isContentEditable( this.element );

    this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
    this.isNewMenu = true;

    this._addClass( "ui-autocomplete-input" );
    this.element.attr( "autocomplete", "off" );

    this._on( this.element, {
      keydown: function( event ) {
        if ( this.element.prop( "readOnly" ) ) {
          suppressKeyPress = true;
          suppressInput = true;
          suppressKeyPressRepeat = true;
          return;
        }

        suppressKeyPress = false;
        suppressInput = false;
        suppressKeyPressRepeat = false;
        var keyCode = $.ui.keyCode;
        switch ( event.keyCode ) {
        case keyCode.PAGE_UP:
          suppressKeyPress = true;
          this._move( "previousPage", event );
          break;
        case keyCode.PAGE_DOWN:
          suppressKeyPress = true;
          this._move( "nextPage", event );
          break;
        case keyCode.UP:
          suppressKeyPress = true;
          this._keyEvent( "previous", event );
          break;
        case keyCode.DOWN:
          suppressKeyPress = true;
          this._keyEvent( "next", event );
          break;
        case keyCode.ENTER:

          // when menu is open and has focus
          if ( this.menu.active ) {

            // #6055 - Opera still allows the keypress to occur
            // which causes forms to submit
            suppressKeyPress = true;
            event.preventDefault();
            this.menu.select( event );
          }
          break;
        case keyCode.TAB:
          if ( this.menu.active ) {
            this.menu.select( event );
          }
          break;
        case keyCode.ESCAPE:
          if ( this.menu.element.is( ":visible" ) ) {
            if ( !this.isMultiLine ) {
              this._value( this.term );
            }
            this.close( event );

            // Different browsers have different default behavior for escape
            // Single press can mean undo or clear
            // Double press in IE means clear the whole form
            event.preventDefault();
          }
          break;
        default:
          suppressKeyPressRepeat = true;

          // search timeout should be triggered before the input value is changed
          this._searchTimeout( event );
          break;
        }
      },
      keypress: function( event ) {
        if ( suppressKeyPress ) {
          suppressKeyPress = false;
          if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
            event.preventDefault();
          }
          return;
        }
        if ( suppressKeyPressRepeat ) {
          return;
        }

        // Replicate some key handlers to allow them to repeat in Firefox and Opera
        var keyCode = $.ui.keyCode;
        switch ( event.keyCode ) {
        case keyCode.PAGE_UP:
          this._move( "previousPage", event );
          break;
        case keyCode.PAGE_DOWN:
          this._move( "nextPage", event );
          break;
        case keyCode.UP:
          this._keyEvent( "previous", event );
          break;
        case keyCode.DOWN:
          this._keyEvent( "next", event );
          break;
        }
      },
      input: function( event ) {
        if ( suppressInput ) {
          suppressInput = false;
          event.preventDefault();
          return;
        }
        this._searchTimeout( event );
      },
      focus: function() {
        this.selectedItem = null;
        this.previous = this._value();
      },
      blur: function( event ) {
        if ( this.cancelBlur ) {
          delete this.cancelBlur;
          return;
        }

        clearTimeout( this.searching );
        this.close( event );
        this._change( event );
      }
    } );

    this._initSource();
    this.menu = $( "<ul>" )
      .appendTo( this._appendTo() )
      .menu( {

        // disable ARIA support, the live region takes care of that
        role: null
      } )
      .hide()
      .menu( "instance" );

    this._addClass( this.menu.element, "ui-autocomplete", "ui-front" );
    this._on( this.menu.element, {
      mousedown: function( event ) {

        // prevent moving focus out of the text field
        event.preventDefault();

        // IE doesn't prevent moving focus even with event.preventDefault()
        // so we set a flag to know when we should ignore the blur event
        this.cancelBlur = true;
        this._delay( function() {
          delete this.cancelBlur;

          // Support: IE 8 only
          // Right clicking a menu item or selecting text from the menu items will
          // result in focus moving out of the input. However, we've already received
          // and ignored the blur event because of the cancelBlur flag set above. So
          // we restore focus to ensure that the menu closes properly based on the user's
          // next actions.
          if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
            this.element.trigger( "focus" );
          }
        } );
      },
      menufocus: function( event, ui ) {
        var label, item;

        // support: Firefox
        // Prevent accidental activation of menu items in Firefox (#7024 #9118)
        if ( this.isNewMenu ) {
          this.isNewMenu = false;
          if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
            this.menu.blur();

            this.document.one( "mousemove", function() {
              $( event.target ).trigger( event.originalEvent );
            } );

            return;
          }
        }

        item = ui.item.data( "ui-autocomplete-item" );
        if ( false !== this._trigger( "focus", event, { item: item } ) ) {

          // use value to match what will end up in the input, if it was a key event
          if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
            this._value( item.value );
          }
        }

        // Announce the value in the liveRegion
        label = ui.item.attr( "aria-label" ) || item.value;
        if ( label && $.trim( label ).length ) {
          this.liveRegion.children().hide();
          $( "<div>" ).text( label ).appendTo( this.liveRegion );
        }
      },
      menuselect: function( event, ui ) {
        var item = ui.item.data( "ui-autocomplete-item" ),
          previous = this.previous;

        // Only trigger when focus was lost (click on menu)
        if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
          this.element.trigger( "focus" );
          this.previous = previous;

          // #6109 - IE triggers two focus events and the second
          // is asynchronous, so we need to reset the previous
          // term synchronously and asynchronously :-(
          this._delay( function() {
            this.previous = previous;
            this.selectedItem = item;
          } );
        }

        if ( false !== this._trigger( "select", event, { item: item } ) ) {
          this._value( item.value );
        }

        // reset the term after the select event
        // this allows custom select handling to work properly
        this.term = this._value();

        this.close( event );
        this.selectedItem = item;
      }
    } );

    this.liveRegion = $( "<div>", {
      role: "status",
      "aria-live": "assertive",
      "aria-relevant": "additions"
    } )
      .appendTo( this.document[ 0 ].body );

    this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

    // Turning off autocomplete prevents the browser from remembering the
    // value when navigating through history, so we re-enable autocomplete
    // if the page is unloaded before the widget is destroyed. #7790
    this._on( this.window, {
      beforeunload: function() {
        this.element.removeAttr( "autocomplete" );
      }
    } );
  },

  _destroy: function() {
    clearTimeout( this.searching );
    this.element.removeAttr( "autocomplete" );
    this.menu.element.remove();
    this.liveRegion.remove();
  },

  _setOption: function( key, value ) {
    this._super( key, value );
    if ( key === "source" ) {
      this._initSource();
    }
    if ( key === "appendTo" ) {
      this.menu.element.appendTo( this._appendTo() );
    }
    if ( key === "disabled" && value && this.xhr ) {
      this.xhr.abort();
    }
  },

  _isEventTargetInWidget: function( event ) {
    var menuElement = this.menu.element[ 0 ];

    return event.target === this.element[ 0 ] ||
      event.target === menuElement ||
      $.contains( menuElement, event.target );
  },

  _closeOnClickOutside: function( event ) {
    if ( !this._isEventTargetInWidget( event ) ) {
      this.close();
    }
  },

  _appendTo: function() {
    var element = this.options.appendTo;

    if ( element ) {
      element = element.jquery || element.nodeType ?
        $( element ) :
        this.document.find( element ).eq( 0 );
    }

    if ( !element || !element[ 0 ] ) {
      element = this.element.closest( ".ui-front, dialog" );
    }

    if ( !element.length ) {
      element = this.document[ 0 ].body;
    }

    return element;
  },

  _initSource: function() {
    var array, url,
      that = this;
    if ( $.isArray( this.options.source ) ) {
      array = this.options.source;
      this.source = function( request, response ) {
        response( $.ui.autocomplete.filter( array, request.term ) );
      };
    } else if ( typeof this.options.source === "string" ) {
      url = this.options.source;
      this.source = function( request, response ) {
        if ( that.xhr ) {
          that.xhr.abort();
        }
        that.xhr = $.ajax( {
          url: url,
          data: request,
          dataType: "json",
          success: function( data ) {
            response( data );
          },
          error: function() {
            response( [] );
          }
        } );
      };
    } else {
      this.source = this.options.source;
    }
  },

  _searchTimeout: function( event ) {
    clearTimeout( this.searching );
    this.searching = this._delay( function() {

      // Search if the value has changed, or if the user retypes the same value (see #7434)
      var equalValues = this.term === this._value(),
        menuVisible = this.menu.element.is( ":visible" ),
        modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

      if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
        this.selectedItem = null;
        this.search( null, event );
      }
    }, this.options.delay );
  },

  search: function( value, event ) {
    value = value != null ? value : this._value();

    // Always save the actual value, not the one passed as an argument
    this.term = this._value();

    if ( value.length < this.options.minLength ) {
      return this.close( event );
    }

    if ( this._trigger( "search", event ) === false ) {
      return;
    }

    return this._search( value );
  },

  _search: function( value ) {
    this.pending++;
    this._addClass( "ui-autocomplete-loading" );
    this.cancelSearch = false;

    this.source( { term: value }, this._response() );
  },

  _response: function() {
    var index = ++this.requestIndex;

    return $.proxy( function( content ) {
      if ( index === this.requestIndex ) {
        this.__response( content );
      }

      this.pending--;
      if ( !this.pending ) {
        this._removeClass( "ui-autocomplete-loading" );
      }
    }, this );
  },

  __response: function( content ) {
    if ( content ) {
      content = this._normalize( content );
    }
    this._trigger( "response", null, { content: content } );
    if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
      this._suggest( content );
      this._trigger( "open" );
    } else {

      // use ._close() instead of .close() so we don't cancel future searches
      this._close();
    }
  },

  close: function( event ) {
    this.cancelSearch = true;
    this._close( event );
  },

  _close: function( event ) {

    // Remove the handler that closes the menu on outside clicks
    this._off( this.document, "mousedown" );

    if ( this.menu.element.is( ":visible" ) ) {
      this.menu.element.hide();
      this.menu.blur();
      this.isNewMenu = true;
      this._trigger( "close", event );
    }
  },

  _change: function( event ) {
    if ( this.previous !== this._value() ) {
      this._trigger( "change", event, { item: this.selectedItem } );
    }
  },

  _normalize: function( items ) {

    // assume all items have the right format when the first item is complete
    if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
      return items;
    }
    return $.map( items, function( item ) {
      if ( typeof item === "string" ) {
        return {
          label: item,
          value: item
        };
      }
      return $.extend( {}, item, {
        label: item.label || item.value,
        value: item.value || item.label
      } );
    } );
  },

  _suggest: function( items ) {
    var ul = this.menu.element.empty();
    this._renderMenu( ul, items );
    this.isNewMenu = true;
    this.menu.refresh();

    // Size and position menu
    ul.show();
    this._resizeMenu();
    ul.position( $.extend( {
      of: this.element
    }, this.options.position ) );

    if ( this.options.autoFocus ) {
      this.menu.next();
    }

    // Listen for interactions outside of the widget (#6642)
    this._on( this.document, {
      mousedown: "_closeOnClickOutside"
    } );
  },

  _resizeMenu: function() {
    var ul = this.menu.element;
    ul.outerWidth( Math.max(

      // Firefox wraps long text (possibly a rounding bug)
      // so we add 1px to avoid the wrapping (#7513)
      ul.width( "" ).outerWidth() + 1,
      this.element.outerWidth()
    ) );
  },

  _renderMenu: function( ul, items ) {
    var that = this;
    $.each( items, function( index, item ) {
      that._renderItemData( ul, item );
    } );
  },

  _renderItemData: function( ul, item ) {
    return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
  },

  _renderItem: function( ul, item ) {
    return $( "<li>" )
      .append( $( "<div>" ).text( item.label ) )
      .appendTo( ul );
  },

  _move: function( direction, event ) {
    if ( !this.menu.element.is( ":visible" ) ) {
      this.search( null, event );
      return;
    }
    if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
        this.menu.isLastItem() && /^next/.test( direction ) ) {

      if ( !this.isMultiLine ) {
        this._value( this.term );
      }

      this.menu.blur();
      return;
    }
    this.menu[ direction ]( event );
  },

  widget: function() {
    return this.menu.element;
  },

  _value: function() {
    return this.valueMethod.apply( this.element, arguments );
  },

  _keyEvent: function( keyEvent, event ) {
    if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
      this._move( keyEvent, event );

      // Prevents moving cursor to beginning/end of the text field in some browsers
      event.preventDefault();
    }
  },

  // Support: Chrome <=50
  // We should be able to just use this.element.prop( "isContentEditable" )
  // but hidden elements always report false in Chrome.
  // https://code.google.com/p/chromium/issues/detail?id=313082
  _isContentEditable: function( element ) {
    if ( !element.length ) {
      return false;
    }

    var editable = element.prop( "contentEditable" );

    if ( editable === "inherit" ) {
      return this._isContentEditable( element.parent() );
    }

    return editable === "true";
  }
} );

$.extend( $.ui.autocomplete, {
  escapeRegex: function( value ) {
    return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
  },
  filter: function( array, term ) {
    var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
    return $.grep( array, function( value ) {
      return matcher.test( value.label || value.value || value );
    } );
  }
} );

// Live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
  options: {
    messages: {
      noResults: "No search results.",
      results: function( amount ) {
        return amount + ( amount > 1 ? " results are" : " result is" ) +
          " available, use up and down arrow keys to navigate.";
      }
    }
  },

  __response: function( content ) {
    var message;
    this._superApply( arguments );
    if ( this.options.disabled || this.cancelSearch ) {
      return;
    }
    if ( content && content.length ) {
      message = this.options.messages.results( content.length );
    } else {
      message = this.options.messages.noResults;
    }
    this.liveRegion.children().hide();
    $( "<div>" ).text( message ).appendTo( this.liveRegion );
  }
} );

var widgetsAutocomplete = $.ui.autocomplete;


/*!
 * jQuery UI Controlgroup 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Controlgroup
//>>group: Widgets
//>>description: Visually groups form control widgets
//>>docs: http://api.jqueryui.com/controlgroup/
//>>demos: http://jqueryui.com/controlgroup/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/controlgroup.css
//>>css.theme: ../../themes/base/theme.css


var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

var widgetsControlgroup = $.widget( "ui.controlgroup", {
  version: "1.12.1",
  defaultElement: "<div>",
  options: {
    direction: "horizontal",
    disabled: null,
    onlyVisible: true,
    items: {
      "button": "input[type=button], input[type=submit], input[type=reset], button, a",
      "controlgroupLabel": ".ui-controlgroup-label",
      "checkboxradio": "input[type='checkbox'], input[type='radio']",
      "selectmenu": "select",
      "spinner": ".ui-spinner-input"
    }
  },

  _create: function() {
    this._enhance();
  },

  // To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
  _enhance: function() {
    this.element.attr( "role", "toolbar" );
    this.refresh();
  },

  _destroy: function() {
    this._callChildMethod( "destroy" );
    this.childWidgets.removeData( "ui-controlgroup-data" );
    this.element.removeAttr( "role" );
    if ( this.options.items.controlgroupLabel ) {
      this.element
        .find( this.options.items.controlgroupLabel )
        .find( ".ui-controlgroup-label-contents" )
        .contents().unwrap();
    }
  },

  _initWidgets: function() {
    var that = this,
      childWidgets = [];

    // First we iterate over each of the items options
    $.each( this.options.items, function( widget, selector ) {
      var labels;
      var options = {};

      // Make sure the widget has a selector set
      if ( !selector ) {
        return;
      }

      if ( widget === "controlgroupLabel" ) {
        labels = that.element.find( selector );
        labels.each( function() {
          var element = $( this );

          if ( element.children( ".ui-controlgroup-label-contents" ).length ) {
            return;
          }
          element.contents()
            .wrapAll( "<span class='ui-controlgroup-label-contents'></span>" );
        } );
        that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );
        childWidgets = childWidgets.concat( labels.get() );
        return;
      }

      // Make sure the widget actually exists
      if ( !$.fn[ widget ] ) {
        return;
      }

      // We assume everything is in the middle to start because we can't determine
      // first / last elements until all enhancments are done.
      if ( that[ "_" + widget + "Options" ] ) {
        options = that[ "_" + widget + "Options" ]( "middle" );
      } else {
        options = { classes: {} };
      }

      // Find instances of this widget inside controlgroup and init them
      that.element
        .find( selector )
        .each( function() {
          var element = $( this );
          var instance = element[ widget ]( "instance" );

          // We need to clone the default options for this type of widget to avoid
          // polluting the variable options which has a wider scope than a single widget.
          var instanceOptions = $.widget.extend( {}, options );

          // If the button is the child of a spinner ignore it
          // TODO: Find a more generic solution
          if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {
            return;
          }

          // Create the widget if it doesn't exist
          if ( !instance ) {
            instance = element[ widget ]()[ widget ]( "instance" );
          }
          if ( instance ) {
            instanceOptions.classes =
              that._resolveClassesValues( instanceOptions.classes, instance );
          }
          element[ widget ]( instanceOptions );

          // Store an instance of the controlgroup to be able to reference
          // from the outermost element for changing options and refresh
          var widgetElement = element[ widget ]( "widget" );
          $.data( widgetElement[ 0 ], "ui-controlgroup-data",
            instance ? instance : element[ widget ]( "instance" ) );

          childWidgets.push( widgetElement[ 0 ] );
        } );
    } );

    this.childWidgets = $( $.unique( childWidgets ) );
    this._addClass( this.childWidgets, "ui-controlgroup-item" );
  },

  _callChildMethod: function( method ) {
    this.childWidgets.each( function() {
      var element = $( this ),
        data = element.data( "ui-controlgroup-data" );
      if ( data && data[ method ] ) {
        data[ method ]();
      }
    } );
  },

  _updateCornerClass: function( element, position ) {
    var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
    var add = this._buildSimpleOptions( position, "label" ).classes.label;

    this._removeClass( element, null, remove );
    this._addClass( element, null, add );
  },

  _buildSimpleOptions: function( position, key ) {
    var direction = this.options.direction === "vertical";
    var result = {
      classes: {}
    };
    result.classes[ key ] = {
      "middle": "",
      "first": "ui-corner-" + ( direction ? "top" : "left" ),
      "last": "ui-corner-" + ( direction ? "bottom" : "right" ),
      "only": "ui-corner-all"
    }[ position ];

    return result;
  },

  _spinnerOptions: function( position ) {
    var options = this._buildSimpleOptions( position, "ui-spinner" );

    options.classes[ "ui-spinner-up" ] = "";
    options.classes[ "ui-spinner-down" ] = "";

    return options;
  },

  _buttonOptions: function( position ) {
    return this._buildSimpleOptions( position, "ui-button" );
  },

  _checkboxradioOptions: function( position ) {
    return this._buildSimpleOptions( position, "ui-checkboxradio-label" );
  },

  _selectmenuOptions: function( position ) {
    var direction = this.options.direction === "vertical";
    return {
      width: direction ? "auto" : false,
      classes: {
        middle: {
          "ui-selectmenu-button-open": "",
          "ui-selectmenu-button-closed": ""
        },
        first: {
          "ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),
          "ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )
        },
        last: {
          "ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
          "ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )
        },
        only: {
          "ui-selectmenu-button-open": "ui-corner-top",
          "ui-selectmenu-button-closed": "ui-corner-all"
        }

      }[ position ]
    };
  },

  _resolveClassesValues: function( classes, instance ) {
    var result = {};
    $.each( classes, function( key ) {
      var current = instance.options.classes[ key ] || "";
      current = $.trim( current.replace( controlgroupCornerRegex, "" ) );
      result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );
    } );
    return result;
  },

  _setOption: function( key, value ) {
    if ( key === "direction" ) {
      this._removeClass( "ui-controlgroup-" + this.options.direction );
    }

    this._super( key, value );
    if ( key === "disabled" ) {
      this._callChildMethod( value ? "disable" : "enable" );
      return;
    }

    this.refresh();
  },

  refresh: function() {
    var children,
      that = this;

    this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );

    if ( this.options.direction === "horizontal" ) {
      this._addClass( null, "ui-helper-clearfix" );
    }
    this._initWidgets();

    children = this.childWidgets;

    // We filter here because we need to track all childWidgets not just the visible ones
    if ( this.options.onlyVisible ) {
      children = children.filter( ":visible" );
    }

    if ( children.length ) {

      // We do this last because we need to make sure all enhancment is done
      // before determining first and last
      $.each( [ "first", "last" ], function( index, value ) {
        var instance = children[ value ]().data( "ui-controlgroup-data" );

        if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {
          var options = that[ "_" + instance.widgetName + "Options" ](
            children.length === 1 ? "only" : value
          );
          options.classes = that._resolveClassesValues( options.classes, instance );
          instance.element[ instance.widgetName ]( options );
        } else {
          that._updateCornerClass( children[ value ](), value );
        }
      } );

      // Finally call the refresh method on each of the child widgets.
      this._callChildMethod( "refresh" );
    }
  }
} );

/*!
 * jQuery UI Checkboxradio 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Checkboxradio
//>>group: Widgets
//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
//>>docs: http://api.jqueryui.com/checkboxradio/
//>>demos: http://jqueryui.com/checkboxradio/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.structure: ../../themes/base/checkboxradio.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {
  version: "1.12.1",
  options: {
    disabled: null,
    label: null,
    icon: true,
    classes: {
      "ui-checkboxradio-label": "ui-corner-all",
      "ui-checkboxradio-icon": "ui-corner-all"
    }
  },

  _getCreateOptions: function() {
    var disabled, labels;
    var that = this;
    var options = this._super() || {};

    // We read the type here, because it makes more sense to throw a element type error first,
    // rather then the error for lack of a label. Often if its the wrong type, it
    // won't have a label (e.g. calling on a div, btn, etc)
    this._readType();

    labels = this.element.labels();

    // If there are multiple labels, use the last one
    this.label = $( labels[ labels.length - 1 ] );
    if ( !this.label.length ) {
      $.error( "No label found for checkboxradio widget" );
    }

    this.originalLabel = "";

    // We need to get the label text but this may also need to make sure it does not contain the
    // input itself.
    this.label.contents().not( this.element[ 0 ] ).each( function() {

      // The label contents could be text, html, or a mix. We concat each element to get a
      // string representation of the label, without the input as part of it.
      that.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;
    } );

    // Set the label option if we found label text
    if ( this.originalLabel ) {
      options.label = this.originalLabel;
    }

    disabled = this.element[ 0 ].disabled;
    if ( disabled != null ) {
      options.disabled = disabled;
    }
    return options;
  },

  _create: function() {
    var checked = this.element[ 0 ].checked;

    this._bindFormResetHandler();

    if ( this.options.disabled == null ) {
      this.options.disabled = this.element[ 0 ].disabled;
    }

    this._setOption( "disabled", this.options.disabled );
    this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );
    this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );

    if ( this.type === "radio" ) {
      this._addClass( this.label, "ui-checkboxradio-radio-label" );
    }

    if ( this.options.label && this.options.label !== this.originalLabel ) {
      this._updateLabel();
    } else if ( this.originalLabel ) {
      this.options.label = this.originalLabel;
    }

    this._enhance();

    if ( checked ) {
      this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );
      if ( this.icon ) {
        this._addClass( this.icon, null, "ui-state-hover" );
      }
    }

    this._on( {
      change: "_toggleClasses",
      focus: function() {
        this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );
      },
      blur: function() {
        this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );
      }
    } );
  },

  _readType: function() {
    var nodeName = this.element[ 0 ].nodeName.toLowerCase();
    this.type = this.element[ 0 ].type;
    if ( nodeName !== "input" || !/radio|checkbox/.test( this.type ) ) {
      $.error( "Can't create checkboxradio on element.nodeName=" + nodeName +
        " and element.type=" + this.type );
    }
  },

  // Support jQuery Mobile enhanced option
  _enhance: function() {
    this._updateIcon( this.element[ 0 ].checked );
  },

  widget: function() {
    return this.label;
  },

  _getRadioGroup: function() {
    var group;
    var name = this.element[ 0 ].name;
    var nameSelector = "input[name='" + $.ui.escapeSelector( name ) + "']";

    if ( !name ) {
      return $( [] );
    }

    if ( this.form.length ) {
      group = $( this.form[ 0 ].elements ).filter( nameSelector );
    } else {

      // Not inside a form, check all inputs that also are not inside a form
      group = $( nameSelector ).filter( function() {
        return $( this ).form().length === 0;
      } );
    }

    return group.not( this.element );
  },

  _toggleClasses: function() {
    var checked = this.element[ 0 ].checked;
    this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );

    if ( this.options.icon && this.type === "checkbox" ) {
      this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )
        ._toggleClass( this.icon, null, "ui-icon-blank", !checked );
    }

    if ( this.type === "radio" ) {
      this._getRadioGroup()
        .each( function() {
          var instance = $( this ).checkboxradio( "instance" );

          if ( instance ) {
            instance._removeClass( instance.label,
              "ui-checkboxradio-checked", "ui-state-active" );
          }
        } );
    }
  },

  _destroy: function() {
    this._unbindFormResetHandler();

    if ( this.icon ) {
      this.icon.remove();
      this.iconSpace.remove();
    }
  },

  _setOption: function( key, value ) {

    // We don't allow the value to be set to nothing
    if ( key === "label" && !value ) {
      return;
    }

    this._super( key, value );

    if ( key === "disabled" ) {
      this._toggleClass( this.label, null, "ui-state-disabled", value );
      this.element[ 0 ].disabled = value;

      // Don't refresh when setting disabled
      return;
    }
    this.refresh();
  },

  _updateIcon: function( checked ) {
    var toAdd = "ui-icon ui-icon-background ";

    if ( this.options.icon ) {
      if ( !this.icon ) {
        this.icon = $( "<span>" );
        this.iconSpace = $( "<span> </span>" );
        this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );
      }

      if ( this.type === "checkbox" ) {
        toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
        this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );
      } else {
        toAdd += "ui-icon-blank";
      }
      this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );
      if ( !checked ) {
        this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );
      }
      this.icon.prependTo( this.label ).after( this.iconSpace );
    } else if ( this.icon !== undefined ) {
      this.icon.remove();
      this.iconSpace.remove();
      delete this.icon;
    }
  },

  _updateLabel: function() {

    // Remove the contents of the label ( minus the icon, icon space, and input )
    var contents = this.label.contents().not( this.element[ 0 ] );
    if ( this.icon ) {
      contents = contents.not( this.icon[ 0 ] );
    }
    if ( this.iconSpace ) {
      contents = contents.not( this.iconSpace[ 0 ] );
    }
    contents.remove();

    this.label.append( this.options.label );
  },

  refresh: function() {
    var checked = this.element[ 0 ].checked,
      isDisabled = this.element[ 0 ].disabled;

    this._updateIcon( checked );
    this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
    if ( this.options.label !== null ) {
      this._updateLabel();
    }

    if ( isDisabled !== this.options.disabled ) {
      this._setOptions( { "disabled": isDisabled } );
    }
  }

} ] );

var widgetsCheckboxradio = $.ui.checkboxradio;


/*!
 * jQuery UI Button 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Button
//>>group: Widgets
//>>description: Enhances a form with themeable buttons.
//>>docs: http://api.jqueryui.com/button/
//>>demos: http://jqueryui.com/button/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.button", {
  version: "1.12.1",
  defaultElement: "<button>",
  options: {
    classes: {
      "ui-button": "ui-corner-all"
    },
    disabled: null,
    icon: null,
    iconPosition: "beginning",
    label: null,
    showLabel: true
  },

  _getCreateOptions: function() {
    var disabled,

      // This is to support cases like in jQuery Mobile where the base widget does have
      // an implementation of _getCreateOptions
      options = this._super() || {};

    this.isInput = this.element.is( "input" );

    disabled = this.element[ 0 ].disabled;
    if ( disabled != null ) {
      options.disabled = disabled;
    }

    this.originalLabel = this.isInput ? this.element.val() : this.element.html();
    if ( this.originalLabel ) {
      options.label = this.originalLabel;
    }

    return options;
  },

  _create: function() {
    if ( !this.option.showLabel & !this.options.icon ) {
      this.options.showLabel = true;
    }

    // We have to check the option again here even though we did in _getCreateOptions,
    // because null may have been passed on init which would override what was set in
    // _getCreateOptions
    if ( this.options.disabled == null ) {
      this.options.disabled = this.element[ 0 ].disabled || false;
    }

    this.hasTitle = !!this.element.attr( "title" );

    // Check to see if the label needs to be set or if its already correct
    if ( this.options.label && this.options.label !== this.originalLabel ) {
      if ( this.isInput ) {
        this.element.val( this.options.label );
      } else {
        this.element.html( this.options.label );
      }
    }
    this._addClass( "ui-button", "ui-widget" );
    this._setOption( "disabled", this.options.disabled );
    this._enhance();

    if ( this.element.is( "a" ) ) {
      this._on( {
        "keyup": function( event ) {
          if ( event.keyCode === $.ui.keyCode.SPACE ) {
            event.preventDefault();

            // Support: PhantomJS <= 1.9, IE 8 Only
            // If a native click is available use it so we actually cause navigation
            // otherwise just trigger a click event
            if ( this.element[ 0 ].click ) {
              this.element[ 0 ].click();
            } else {
              this.element.trigger( "click" );
            }
          }
        }
      } );
    }
  },

  _enhance: function() {
    if ( !this.element.is( "button" ) ) {
      this.element.attr( "role", "button" );
    }

    if ( this.options.icon ) {
      this._updateIcon( "icon", this.options.icon );
      this._updateTooltip();
    }
  },

  _updateTooltip: function() {
    this.title = this.element.attr( "title" );

    if ( !this.options.showLabel && !this.title ) {
      this.element.attr( "title", this.options.label );
    }
  },

  _updateIcon: function( option, value ) {
    var icon = option !== "iconPosition",
      position = icon ? this.options.iconPosition : value,
      displayBlock = position === "top" || position === "bottom";

    // Create icon
    if ( !this.icon ) {
      this.icon = $( "<span>" );

      this._addClass( this.icon, "ui-button-icon", "ui-icon" );

      if ( !this.options.showLabel ) {
        this._addClass( "ui-button-icon-only" );
      }
    } else if ( icon ) {

      // If we are updating the icon remove the old icon class
      this._removeClass( this.icon, null, this.options.icon );
    }

    // If we are updating the icon add the new icon class
    if ( icon ) {
      this._addClass( this.icon, null, value );
    }

    this._attachIcon( position );

    // If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
    // the iconSpace if there is one.
    if ( displayBlock ) {
      this._addClass( this.icon, null, "ui-widget-icon-block" );
      if ( this.iconSpace ) {
        this.iconSpace.remove();
      }
    } else {

      // Position is beginning or end so remove the ui-widget-icon-block class and add the
      // space if it does not exist
      if ( !this.iconSpace ) {
        this.iconSpace = $( "<span> </span>" );
        this._addClass( this.iconSpace, "ui-button-icon-space" );
      }
      this._removeClass( this.icon, null, "ui-wiget-icon-block" );
      this._attachIconSpace( position );
    }
  },

  _destroy: function() {
    this.element.removeAttr( "role" );

    if ( this.icon ) {
      this.icon.remove();
    }
    if ( this.iconSpace ) {
      this.iconSpace.remove();
    }
    if ( !this.hasTitle ) {
      this.element.removeAttr( "title" );
    }
  },

  _attachIconSpace: function( iconPosition ) {
    this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );
  },

  _attachIcon: function( iconPosition ) {
    this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );
  },

  _setOptions: function( options ) {
    var newShowLabel = options.showLabel === undefined ?
        this.options.showLabel :
        options.showLabel,
      newIcon = options.icon === undefined ? this.options.icon : options.icon;

    if ( !newShowLabel && !newIcon ) {
      options.showLabel = true;
    }
    this._super( options );
  },

  _setOption: function( key, value ) {
    if ( key === "icon" ) {
      if ( value ) {
        this._updateIcon( key, value );
      } else if ( this.icon ) {
        this.icon.remove();
        if ( this.iconSpace ) {
          this.iconSpace.remove();
        }
      }
    }

    if ( key === "iconPosition" ) {
      this._updateIcon( key, value );
    }

    // Make sure we can't end up with a button that has neither text nor icon
    if ( key === "showLabel" ) {
        this._toggleClass( "ui-button-icon-only", null, !value );
        this._updateTooltip();
    }

    if ( key === "label" ) {
      if ( this.isInput ) {
        this.element.val( value );
      } else {

        // If there is an icon, append it, else nothing then append the value
        // this avoids removal of the icon when setting label text
        this.element.html( value );
        if ( this.icon ) {
          this._attachIcon( this.options.iconPosition );
          this._attachIconSpace( this.options.iconPosition );
        }
      }
    }

    this._super( key, value );

    if ( key === "disabled" ) {
      this._toggleClass( null, "ui-state-disabled", value );
      this.element[ 0 ].disabled = value;
      if ( value ) {
        this.element.blur();
      }
    }
  },

  refresh: function() {

    // Make sure to only check disabled if its an element that supports this otherwise
    // check for the disabled class to determine state
    var isDisabled = this.element.is( "input, button" ) ?
      this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );

    if ( isDisabled !== this.options.disabled ) {
      this._setOptions( { disabled: isDisabled } );
    }

    this._updateTooltip();
  }
} );

// DEPRECATED
if ( $.uiBackCompat !== false ) {

  // Text and Icons options
  $.widget( "ui.button", $.ui.button, {
    options: {
      text: true,
      icons: {
        primary: null,
        secondary: null
      }
    },

    _create: function() {
      if ( this.options.showLabel && !this.options.text ) {
        this.options.showLabel = this.options.text;
      }
      if ( !this.options.showLabel && this.options.text ) {
        this.options.text = this.options.showLabel;
      }
      if ( !this.options.icon && ( this.options.icons.primary ||
          this.options.icons.secondary ) ) {
        if ( this.options.icons.primary ) {
          this.options.icon = this.options.icons.primary;
        } else {
          this.options.icon = this.options.icons.secondary;
          this.options.iconPosition = "end";
        }
      } else if ( this.options.icon ) {
        this.options.icons.primary = this.options.icon;
      }
      this._super();
    },

    _setOption: function( key, value ) {
      if ( key === "text" ) {
        this._super( "showLabel", value );
        return;
      }
      if ( key === "showLabel" ) {
        this.options.text = value;
      }
      if ( key === "icon" ) {
        this.options.icons.primary = value;
      }
      if ( key === "icons" ) {
        if ( value.primary ) {
          this._super( "icon", value.primary );
          this._super( "iconPosition", "beginning" );
        } else if ( value.secondary ) {
          this._super( "icon", value.secondary );
          this._super( "iconPosition", "end" );
        }
      }
      this._superApply( arguments );
    }
  } );

  $.fn.button = ( function( orig ) {
    return function() {
      if ( !this.length || ( this.length && this[ 0 ].tagName !== "INPUT" ) ||
          ( this.length && this[ 0 ].tagName === "INPUT" && (
            this.attr( "type" ) !== "checkbox" && this.attr( "type" ) !== "radio"
          ) ) ) {
        return orig.apply( this, arguments );
      }
      if ( !$.ui.checkboxradio ) {
        $.error( "Checkboxradio widget missing" );
      }
      if ( arguments.length === 0 ) {
        return this.checkboxradio( {
          "icon": false
        } );
      }
      return this.checkboxradio.apply( this, arguments );
    };
  } )( $.fn.button );

  $.fn.buttonset = function() {
    if ( !$.ui.controlgroup ) {
      $.error( "Controlgroup widget missing" );
    }
    if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {
      return this.controlgroup.apply( this,
        [ arguments[ 0 ], "items.button", arguments[ 2 ] ] );
    }
    if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {
      return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );
    }
    if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {
      arguments[ 0 ].items = {
        button: arguments[ 0 ].items
      };
    }
    return this.controlgroup.apply( this, arguments );
  };
}

var widgetsButton = $.ui.button;


// jscs:disable maximumLineLength
/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
/*!
 * jQuery UI Datepicker 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: http://api.jqueryui.com/datepicker/
//>>demos: http://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css



$.extend( $.ui, { datepicker: { version: "1.12.1" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
  var position, value;
  while ( elem.length && elem[ 0 ] !== document ) {

    // Ignore z-index if position is set to a value where z-index is ignored by the browser
    // This makes behavior of this function consistent across browsers
    // WebKit always returns auto if the element is positioned
    position = elem.css( "position" );
    if ( position === "absolute" || position === "relative" || position === "fixed" ) {

      // IE returns 0 when zIndex is not specified
      // other browsers return a string
      // we ignore the case of nested elements with an explicit value of 0
      // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
      value = parseInt( elem.css( "zIndex" ), 10 );
      if ( !isNaN( value ) && value !== 0 ) {
        return value;
      }
    }
    elem = elem.parent();
  }

  return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
  this._curInst = null; // The current instance in use
  this._keyEvent = false; // If the last event was a key event
  this._disabledInputs = []; // List of date picker inputs that have been disabled
  this._datepickerShowing = false; // True if the popup picker is showing , false if not
  this._inDialog = false; // True if showing within a "dialog", false if not
  this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
  this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
  this._appendClass = "ui-datepicker-append"; // The name of the append marker class
  this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
  this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
  this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
  this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
  this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
  this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
  this.regional = []; // Available regional settings, indexed by language code
  this.regional[ "" ] = { // Default regional settings
    closeText: "Done", // Display text for close link
    prevText: "Prev", // Display text for previous month link
    nextText: "Next", // Display text for next month link
    currentText: "Today", // Display text for current month link
    monthNames: [ "January","February","March","April","May","June",
      "July","August","September","October","November","December" ], // Names of months for drop-down and formatting
    monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
    dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
    dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
    dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
    weekHeader: "Wk", // Column header for week of the year
    dateFormat: "mm/dd/yy", // See format options on parseDate
    firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
    isRTL: false, // True if right-to-left language, false if left-to-right
    showMonthAfterYear: false, // True if the year select precedes month, false for month then year
    yearSuffix: "" // Additional text to append to the year in the month headers
  };
  this._defaults = { // Global defaults for all the date picker instances
    showOn: "focus", // "focus" for popup on focus,
      // "button" for trigger button, or "both" for either
    showAnim: "fadeIn", // Name of jQuery animation for popup
    showOptions: {}, // Options for enhanced animations
    defaultDate: null, // Used when field is blank: actual date,
      // +/-number for offset from today, null for today
    appendText: "", // Display text following the input box, e.g. showing the format
    buttonText: "...", // Text for trigger button
    buttonImage: "", // URL for trigger button image
    buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
    hideIfNoPrevNext: false, // True to hide next/previous month links
      // if not applicable, false to just disable them
    navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
    gotoCurrent: false, // True if today link goes back to current selection instead
    changeMonth: false, // True if month can be selected directly, false if only prev/next
    changeYear: false, // True if year can be selected directly, false if only prev/next
    yearRange: "c-10:c+10", // Range of years to display in drop-down,
      // either relative to today's year (-nn:+nn), relative to currently displayed year
      // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
    showOtherMonths: false, // True to show dates in other months, false to leave blank
    selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
    showWeek: false, // True to show week of the year, false to not show it
    calculateWeek: this.iso8601Week, // How to calculate the week of the year,
      // takes a Date and returns the number of the week for it
    shortYearCutoff: "+10", // Short year values < this are in the current century,
      // > this are in the previous century,
      // string value starting with "+" for current year + value
    minDate: null, // The earliest selectable date, or null for no limit
    maxDate: null, // The latest selectable date, or null for no limit
    duration: "fast", // Duration of display/closure
    beforeShowDay: null, // Function that takes a date and returns an array with
      // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
      // [2] = cell title (optional), e.g. $.datepicker.noWeekends
    beforeShow: null, // Function that takes an input field and
      // returns a set of custom settings for the date picker
    onSelect: null, // Define a callback function when a date is selected
    onChangeMonthYear: null, // Define a callback function when the month or year is changed
    onClose: null, // Define a callback function when the datepicker is closed
    numberOfMonths: 1, // Number of months to show at a time
    showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
    stepMonths: 1, // Number of months to step back/forward
    stepBigMonths: 12, // Number of months to step back/forward for the big links
    altField: "", // Selector for an alternate field to store selected dates into
    altFormat: "", // The date format to use for the alternate field
    constrainInput: true, // The input is constrained by the current date format
    showButtonPanel: false, // True to show button panel, false to not show it
    autoSize: false, // True to size the input for the date format, false to leave as is
    disabled: false // The initial disabled state
  };
  $.extend( this._defaults, this.regional[ "" ] );
  this.regional.en = $.extend( true, {}, this.regional[ "" ] );
  this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
  this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {
  /* Class name added to elements to indicate already configured with a date picker. */
  markerClassName: "hasDatepicker",

  //Keep track of the maximum number of rows displayed (see #7043)
  maxRows: 4,

  // TODO rename to "widget" when switching to widget factory
  _widgetDatepicker: function() {
    return this.dpDiv;
  },

  /* Override the default settings for all instances of the date picker.
   * @param  settings  object - the new settings to use as defaults (anonymous object)
   * @return the manager object
   */
  setDefaults: function( settings ) {
    datepicker_extendRemove( this._defaults, settings || {} );
    return this;
  },

  /* Attach the date picker to a jQuery selection.
   * @param  target element - the target input field or division or span
   * @param  settings  object - the new settings to use for this date picker instance (anonymous)
   */
  _attachDatepicker: function( target, settings ) {
    var nodeName, inline, inst;
    nodeName = target.nodeName.toLowerCase();
    inline = ( nodeName === "div" || nodeName === "span" );
    if ( !target.id ) {
      this.uuid += 1;
      target.id = "dp" + this.uuid;
    }
    inst = this._newInst( $( target ), inline );
    inst.settings = $.extend( {}, settings || {} );
    if ( nodeName === "input" ) {
      this._connectDatepicker( target, inst );
    } else if ( inline ) {
      this._inlineDatepicker( target, inst );
    }
  },

  /* Create a new instance object. */
  _newInst: function( target, inline ) {
    var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
    return { id: id, input: target, // associated target
      selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
      drawMonth: 0, drawYear: 0, // month being drawn
      inline: inline, // is datepicker inline or not
      dpDiv: ( !inline ? this.dpDiv : // presentation div
      datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
  },

  /* Attach the date picker to an input field. */
  _connectDatepicker: function( target, inst ) {
    var input = $( target );
    inst.append = $( [] );
    inst.trigger = $( [] );
    if ( input.hasClass( this.markerClassName ) ) {
      return;
    }
    this._attachments( input, inst );
    input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
      on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
    this._autoSize( inst );
    $.data( target, "datepicker", inst );

    //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
    if ( inst.settings.disabled ) {
      this._disableDatepicker( target );
    }
  },

  /* Make attachments based on settings. */
  _attachments: function( input, inst ) {
    var showOn, buttonText, buttonImage,
      appendText = this._get( inst, "appendText" ),
      isRTL = this._get( inst, "isRTL" );

    if ( inst.append ) {
      inst.append.remove();
    }
    if ( appendText ) {
      inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
      input[ isRTL ? "before" : "after" ]( inst.append );
    }

    input.off( "focus", this._showDatepicker );

    if ( inst.trigger ) {
      inst.trigger.remove();
    }

    showOn = this._get( inst, "showOn" );
    if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
      input.on( "focus", this._showDatepicker );
    }
    if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
      buttonText = this._get( inst, "buttonText" );
      buttonImage = this._get( inst, "buttonImage" );
      inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
        $( "<img/>" ).addClass( this._triggerClass ).
          attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
        $( "<button type='button'></button>" ).addClass( this._triggerClass ).
          html( !buttonImage ? buttonText : $( "<img/>" ).attr(
          { src:buttonImage, alt:buttonText, title:buttonText } ) ) );
      input[ isRTL ? "before" : "after" ]( inst.trigger );
      inst.trigger.on( "click", function() {
        if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
          $.datepicker._hideDatepicker();
        } else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
          $.datepicker._hideDatepicker();
          $.datepicker._showDatepicker( input[ 0 ] );
        } else {
          $.datepicker._showDatepicker( input[ 0 ] );
        }
        return false;
      } );
    }
  },

  /* Apply the maximum length for the date format. */
  _autoSize: function( inst ) {
    if ( this._get( inst, "autoSize" ) && !inst.inline ) {
      var findMax, max, maxI, i,
        date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
        dateFormat = this._get( inst, "dateFormat" );

      if ( dateFormat.match( /[DM]/ ) ) {
        findMax = function( names ) {
          max = 0;
          maxI = 0;
          for ( i = 0; i < names.length; i++ ) {
            if ( names[ i ].length > max ) {
              max = names[ i ].length;
              maxI = i;
            }
          }
          return maxI;
        };
        date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
          "monthNames" : "monthNamesShort" ) ) ) );
        date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
          "dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
      }
      inst.input.attr( "size", this._formatDate( inst, date ).length );
    }
  },

  /* Attach an inline date picker to a div. */
  _inlineDatepicker: function( target, inst ) {
    var divSpan = $( target );
    if ( divSpan.hasClass( this.markerClassName ) ) {
      return;
    }
    divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
    $.data( target, "datepicker", inst );
    this._setDate( inst, this._getDefaultDate( inst ), true );
    this._updateDatepicker( inst );
    this._updateAlternate( inst );

    //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
    if ( inst.settings.disabled ) {
      this._disableDatepicker( target );
    }

    // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
    // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
    inst.dpDiv.css( "display", "block" );
  },

  /* Pop-up the date picker in a "dialog" box.
   * @param  input element - ignored
   * @param  date string or Date - the initial date to display
   * @param  onSelect  function - the function to call when a date is selected
   * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
   * @param  pos int[2] - coordinates for the dialog's position within the screen or
   *          event - with x/y coordinates or
   *          leave empty for default (screen centre)
   * @return the manager object
   */
  _dialogDatepicker: function( input, date, onSelect, settings, pos ) {
    var id, browserWidth, browserHeight, scrollX, scrollY,
      inst = this._dialogInst; // internal instance

    if ( !inst ) {
      this.uuid += 1;
      id = "dp" + this.uuid;
      this._dialogInput = $( "<input type='text' id='" + id +
        "' style='position: absolute; top: -100px; width: 0px;'/>" );
      this._dialogInput.on( "keydown", this._doKeyDown );
      $( "body" ).append( this._dialogInput );
      inst = this._dialogInst = this._newInst( this._dialogInput, false );
      inst.settings = {};
      $.data( this._dialogInput[ 0 ], "datepicker", inst );
    }
    datepicker_extendRemove( inst.settings, settings || {} );
    date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
    this._dialogInput.val( date );

    this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
    if ( !this._pos ) {
      browserWidth = document.documentElement.clientWidth;
      browserHeight = document.documentElement.clientHeight;
      scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
      scrollY = document.documentElement.scrollTop || document.body.scrollTop;
      this._pos = // should use actual width/height below
        [ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
    }

    // Move input on screen for focus, but hidden behind dialog
    this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
    inst.settings.onSelect = onSelect;
    this._inDialog = true;
    this.dpDiv.addClass( this._dialogClass );
    this._showDatepicker( this._dialogInput[ 0 ] );
    if ( $.blockUI ) {
      $.blockUI( this.dpDiv );
    }
    $.data( this._dialogInput[ 0 ], "datepicker", inst );
    return this;
  },

  /* Detach a datepicker from its control.
   * @param  target element - the target input field or division or span
   */
  _destroyDatepicker: function( target ) {
    var nodeName,
      $target = $( target ),
      inst = $.data( target, "datepicker" );

    if ( !$target.hasClass( this.markerClassName ) ) {
      return;
    }

    nodeName = target.nodeName.toLowerCase();
    $.removeData( target, "datepicker" );
    if ( nodeName === "input" ) {
      inst.append.remove();
      inst.trigger.remove();
      $target.removeClass( this.markerClassName ).
        off( "focus", this._showDatepicker ).
        off( "keydown", this._doKeyDown ).
        off( "keypress", this._doKeyPress ).
        off( "keyup", this._doKeyUp );
    } else if ( nodeName === "div" || nodeName === "span" ) {
      $target.removeClass( this.markerClassName ).empty();
    }

    if ( datepicker_instActive === inst ) {
      datepicker_instActive = null;
    }
  },

  /* Enable the date picker to a jQuery selection.
   * @param  target element - the target input field or division or span
   */
  _enableDatepicker: function( target ) {
    var nodeName, inline,
      $target = $( target ),
      inst = $.data( target, "datepicker" );

    if ( !$target.hasClass( this.markerClassName ) ) {
      return;
    }

    nodeName = target.nodeName.toLowerCase();
    if ( nodeName === "input" ) {
      target.disabled = false;
      inst.trigger.filter( "button" ).
        each( function() { this.disabled = false; } ).end().
        filter( "img" ).css( { opacity: "1.0", cursor: "" } );
    } else if ( nodeName === "div" || nodeName === "span" ) {
      inline = $target.children( "." + this._inlineClass );
      inline.children().removeClass( "ui-state-disabled" );
      inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
        prop( "disabled", false );
    }
    this._disabledInputs = $.map( this._disabledInputs,
      function( value ) { return ( value === target ? null : value ); } ); // delete entry
  },

  /* Disable the date picker to a jQuery selection.
   * @param  target element - the target input field or division or span
   */
  _disableDatepicker: function( target ) {
    var nodeName, inline,
      $target = $( target ),
      inst = $.data( target, "datepicker" );

    if ( !$target.hasClass( this.markerClassName ) ) {
      return;
    }

    nodeName = target.nodeName.toLowerCase();
    if ( nodeName === "input" ) {
      target.disabled = true;
      inst.trigger.filter( "button" ).
        each( function() { this.disabled = true; } ).end().
        filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
    } else if ( nodeName === "div" || nodeName === "span" ) {
      inline = $target.children( "." + this._inlineClass );
      inline.children().addClass( "ui-state-disabled" );
      inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
        prop( "disabled", true );
    }
    this._disabledInputs = $.map( this._disabledInputs,
      function( value ) { return ( value === target ? null : value ); } ); // delete entry
    this._disabledInputs[ this._disabledInputs.length ] = target;
  },

  /* Is the first field in a jQuery collection disabled as a datepicker?
   * @param  target element - the target input field or division or span
   * @return boolean - true if disabled, false if enabled
   */
  _isDisabledDatepicker: function( target ) {
    if ( !target ) {
      return false;
    }
    for ( var i = 0; i < this._disabledInputs.length; i++ ) {
      if ( this._disabledInputs[ i ] === target ) {
        return true;
      }
    }
    return false;
  },

  /* Retrieve the instance data for the target control.
   * @param  target  element - the target input field or division or span
   * @return  object - the associated instance data
   * @throws  error if a jQuery problem getting data
   */
  _getInst: function( target ) {
    try {
      return $.data( target, "datepicker" );
    }
    catch ( err ) {
      throw "Missing instance data for this datepicker";
    }
  },

  /* Update or retrieve the settings for a date picker attached to an input field or division.
   * @param  target  element - the target input field or division or span
   * @param  name object - the new settings to update or
   *        string - the name of the setting to change or retrieve,
   *        when retrieving also "all" for all instance settings or
   *        "defaults" for all global defaults
   * @param  value   any - the new value for the setting
   *        (omit if above is an object or to retrieve a value)
   */
  _optionDatepicker: function( target, name, value ) {
    var settings, date, minDate, maxDate,
      inst = this._getInst( target );

    if ( arguments.length === 2 && typeof name === "string" ) {
      return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
        ( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
        this._get( inst, name ) ) : null ) );
    }

    settings = name || {};
    if ( typeof name === "string" ) {
      settings = {};
      settings[ name ] = value;
    }

    if ( inst ) {
      if ( this._curInst === inst ) {
        this._hideDatepicker();
      }

      date = this._getDateDatepicker( target, true );
      minDate = this._getMinMaxDate( inst, "min" );
      maxDate = this._getMinMaxDate( inst, "max" );
      datepicker_extendRemove( inst.settings, settings );

      // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
      if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
        inst.settings.minDate = this._formatDate( inst, minDate );
      }
      if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
        inst.settings.maxDate = this._formatDate( inst, maxDate );
      }
      if ( "disabled" in settings ) {
        if ( settings.disabled ) {
          this._disableDatepicker( target );
        } else {
          this._enableDatepicker( target );
        }
      }
      this._attachments( $( target ), inst );
      this._autoSize( inst );
      this._setDate( inst, date );
      this._updateAlternate( inst );
      this._updateDatepicker( inst );
    }
  },

  // Change method deprecated
  _changeDatepicker: function( target, name, value ) {
    this._optionDatepicker( target, name, value );
  },

  /* Redraw the date picker attached to an input field or division.
   * @param  target  element - the target input field or division or span
   */
  _refreshDatepicker: function( target ) {
    var inst = this._getInst( target );
    if ( inst ) {
      this._updateDatepicker( inst );
    }
  },

  /* Set the dates for a jQuery selection.
   * @param  target element - the target input field or division or span
   * @param  date Date - the new date
   */
  _setDateDatepicker: function( target, date ) {
    var inst = this._getInst( target );
    if ( inst ) {
      this._setDate( inst, date );
      this._updateDatepicker( inst );
      this._updateAlternate( inst );
    }
  },

  /* Get the date(s) for the first entry in a jQuery selection.
   * @param  target element - the target input field or division or span
   * @param  noDefault boolean - true if no default date is to be used
   * @return Date - the current date
   */
  _getDateDatepicker: function( target, noDefault ) {
    var inst = this._getInst( target );
    if ( inst && !inst.inline ) {
      this._setDateFromField( inst, noDefault );
    }
    return ( inst ? this._getDate( inst ) : null );
  },

  /* Handle keystrokes. */
  _doKeyDown: function( event ) {
    var onSelect, dateStr, sel,
      inst = $.datepicker._getInst( event.target ),
      handled = true,
      isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

    inst._keyEvent = true;
    if ( $.datepicker._datepickerShowing ) {
      switch ( event.keyCode ) {
        case 9: $.datepicker._hideDatepicker();
            handled = false;
            break; // hide on tab out
        case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
                  $.datepicker._currentClass + ")", inst.dpDiv );
            if ( sel[ 0 ] ) {
              $.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
            }

            onSelect = $.datepicker._get( inst, "onSelect" );
            if ( onSelect ) {
              dateStr = $.datepicker._formatDate( inst );

              // Trigger custom callback
              onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
            } else {
              $.datepicker._hideDatepicker();
            }

            return false; // don't submit the form
        case 27: $.datepicker._hideDatepicker();
            break; // hide on escape
        case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
              -$.datepicker._get( inst, "stepBigMonths" ) :
              -$.datepicker._get( inst, "stepMonths" ) ), "M" );
            break; // previous month/year on page up/+ ctrl
        case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
              +$.datepicker._get( inst, "stepBigMonths" ) :
              +$.datepicker._get( inst, "stepMonths" ) ), "M" );
            break; // next month/year on page down/+ ctrl
        case 35: if ( event.ctrlKey || event.metaKey ) {
              $.datepicker._clearDate( event.target );
            }
            handled = event.ctrlKey || event.metaKey;
            break; // clear on ctrl or command +end
        case 36: if ( event.ctrlKey || event.metaKey ) {
              $.datepicker._gotoToday( event.target );
            }
            handled = event.ctrlKey || event.metaKey;
            break; // current on ctrl or command +home
        case 37: if ( event.ctrlKey || event.metaKey ) {
              $.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
            }
            handled = event.ctrlKey || event.metaKey;

            // -1 day on ctrl or command +left
            if ( event.originalEvent.altKey ) {
              $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                -$.datepicker._get( inst, "stepBigMonths" ) :
                -$.datepicker._get( inst, "stepMonths" ) ), "M" );
            }

            // next month/year on alt +left on Mac
            break;
        case 38: if ( event.ctrlKey || event.metaKey ) {
              $.datepicker._adjustDate( event.target, -7, "D" );
            }
            handled = event.ctrlKey || event.metaKey;
            break; // -1 week on ctrl or command +up
        case 39: if ( event.ctrlKey || event.metaKey ) {
              $.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
            }
            handled = event.ctrlKey || event.metaKey;

            // +1 day on ctrl or command +right
            if ( event.originalEvent.altKey ) {
              $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
                +$.datepicker._get( inst, "stepBigMonths" ) :
                +$.datepicker._get( inst, "stepMonths" ) ), "M" );
            }

            // next month/year on alt +right
            break;
        case 40: if ( event.ctrlKey || event.metaKey ) {
              $.datepicker._adjustDate( event.target, +7, "D" );
            }
            handled = event.ctrlKey || event.metaKey;
            break; // +1 week on ctrl or command +down
        default: handled = false;
      }
    } else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
      $.datepicker._showDatepicker( this );
    } else {
      handled = false;
    }

    if ( handled ) {
      event.preventDefault();
      event.stopPropagation();
    }
  },

  /* Filter entered characters - based on date format. */
  _doKeyPress: function( event ) {
    var chars, chr,
      inst = $.datepicker._getInst( event.target );

    if ( $.datepicker._get( inst, "constrainInput" ) ) {
      chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
      chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
      return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
    }
  },

  /* Synchronise manual entry and field/alternate field. */
  _doKeyUp: function( event ) {
    var date,
      inst = $.datepicker._getInst( event.target );

    if ( inst.input.val() !== inst.lastVal ) {
      try {
        date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
          ( inst.input ? inst.input.val() : null ),
          $.datepicker._getFormatConfig( inst ) );

        if ( date ) { // only if valid
          $.datepicker._setDateFromField( inst );
          $.datepicker._updateAlternate( inst );
          $.datepicker._updateDatepicker( inst );
        }
      }
      catch ( err ) {
      }
    }
    return true;
  },

  /* Pop-up the date picker for a given input field.
   * If false returned from beforeShow event handler do not show.
   * @param  input  element - the input field attached to the date picker or
   *          event - if triggered by focus
   */
  _showDatepicker: function( input ) {
    input = input.target || input;
    if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
      input = $( "input", input.parentNode )[ 0 ];
    }

    if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
      return;
    }

    var inst, beforeShow, beforeShowSettings, isFixed,
      offset, showAnim, duration;

    inst = $.datepicker._getInst( input );
    if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
      $.datepicker._curInst.dpDiv.stop( true, true );
      if ( inst && $.datepicker._datepickerShowing ) {
        $.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
      }
    }

    beforeShow = $.datepicker._get( inst, "beforeShow" );
    beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
    if ( beforeShowSettings === false ) {
      return;
    }
    datepicker_extendRemove( inst.settings, beforeShowSettings );

    inst.lastVal = null;
    $.datepicker._lastInput = input;
    $.datepicker._setDateFromField( inst );

    if ( $.datepicker._inDialog ) { // hide cursor
      input.value = "";
    }
    if ( !$.datepicker._pos ) { // position below input
      $.datepicker._pos = $.datepicker._findPos( input );
      $.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
    }

    isFixed = false;
    $( input ).parents().each( function() {
      isFixed |= $( this ).css( "position" ) === "fixed";
      return !isFixed;
    } );

    offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
    $.datepicker._pos = null;

    //to avoid flashes on Firefox
    inst.dpDiv.empty();

    // determine sizing offscreen
    inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
    $.datepicker._updateDatepicker( inst );

    // fix width for dynamic number of date pickers
    // and adjust position before showing
    offset = $.datepicker._checkOffset( inst, offset, isFixed );
    inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
      "static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
      left: offset.left + "px", top: offset.top + "px" } );

    if ( !inst.inline ) {
      showAnim = $.datepicker._get( inst, "showAnim" );
      duration = $.datepicker._get( inst, "duration" );
      inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
      $.datepicker._datepickerShowing = true;

      if ( $.effects && $.effects.effect[ showAnim ] ) {
        inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
      } else {
        inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
      }

      if ( $.datepicker._shouldFocusInput( inst ) ) {
        inst.input.trigger( "focus" );
      }

      $.datepicker._curInst = inst;
    }
  },

  /* Generate the date picker content. */
  _updateDatepicker: function( inst ) {
    this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
    datepicker_instActive = inst; // for delegate hover events
    inst.dpDiv.empty().append( this._generateHTML( inst ) );
    this._attachHandlers( inst );

    var origyearshtml,
      numMonths = this._getNumberOfMonths( inst ),
      cols = numMonths[ 1 ],
      width = 17,
      activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

    if ( activeCell.length > 0 ) {
      datepicker_handleMouseover.apply( activeCell.get( 0 ) );
    }

    inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
    if ( cols > 1 ) {
      inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
    }
    inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
      "Class" ]( "ui-datepicker-multi" );
    inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
      "Class" ]( "ui-datepicker-rtl" );

    if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
      inst.input.trigger( "focus" );
    }

    // Deffered render of the years select (to avoid flashes on Firefox)
    if ( inst.yearshtml ) {
      origyearshtml = inst.yearshtml;
      setTimeout( function() {

        //assure that inst.yearshtml didn't change.
        if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
          inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
        }
        origyearshtml = inst.yearshtml = null;
      }, 0 );
    }
  },

  // #6694 - don't focus the input if it's already focused
  // this breaks the change event in IE
  // Support: IE and jQuery <1.9
  _shouldFocusInput: function( inst ) {
    return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
  },

  /* Check positioning to remain on screen. */
  _checkOffset: function( inst, offset, isFixed ) {
    var dpWidth = inst.dpDiv.outerWidth(),
      dpHeight = inst.dpDiv.outerHeight(),
      inputWidth = inst.input ? inst.input.outerWidth() : 0,
      inputHeight = inst.input ? inst.input.outerHeight() : 0,
      viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
      viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

    offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
    offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
    offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

    // Now check if datepicker is showing outside window viewport - move to a better place if so.
    offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
      Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
    offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
      Math.abs( dpHeight + inputHeight ) : 0 );

    return offset;
  },

  /* Find an object's position on the screen. */
  _findPos: function( obj ) {
    var position,
      inst = this._getInst( obj ),
      isRTL = this._get( inst, "isRTL" );

    while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
      obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
    }

    position = $( obj ).offset();
    return [ position.left, position.top ];
  },

  /* Hide the date picker from view.
   * @param  input  element - the input field attached to the date picker
   */
  _hideDatepicker: function( input ) {
    var showAnim, duration, postProcess, onClose,
      inst = this._curInst;

    if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
      return;
    }

    if ( this._datepickerShowing ) {
      showAnim = this._get( inst, "showAnim" );
      duration = this._get( inst, "duration" );
      postProcess = function() {
        $.datepicker._tidyDialog( inst );
      };

      // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
      if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
        inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
      } else {
        inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
          ( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
      }

      if ( !showAnim ) {
        postProcess();
      }
      this._datepickerShowing = false;

      onClose = this._get( inst, "onClose" );
      if ( onClose ) {
        onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
      }

      this._lastInput = null;
      if ( this._inDialog ) {
        this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
        if ( $.blockUI ) {
          $.unblockUI();
          $( "body" ).append( this.dpDiv );
        }
      }
      this._inDialog = false;
    }
  },

  /* Tidy up after a dialog display. */
  _tidyDialog: function( inst ) {
    inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
  },

  /* Close date picker if clicked elsewhere. */
  _checkExternalClick: function( event ) {
    if ( !$.datepicker._curInst ) {
      return;
    }

    var $target = $( event.target ),
      inst = $.datepicker._getInst( $target[ 0 ] );

    if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
        $target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
        !$target.hasClass( $.datepicker.markerClassName ) &&
        !$target.closest( "." + $.datepicker._triggerClass ).length &&
        $.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
      ( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
        $.datepicker._hideDatepicker();
    }
  },

  /* Adjust one of the date sub-fields. */
  _adjustDate: function( id, offset, period ) {
    var target = $( id ),
      inst = this._getInst( target[ 0 ] );

    if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
      return;
    }
    this._adjustInstDate( inst, offset +
      ( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
      period );
    this._updateDatepicker( inst );
  },

  /* Action for current link. */
  _gotoToday: function( id ) {
    var date,
      target = $( id ),
      inst = this._getInst( target[ 0 ] );

    if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
      inst.selectedDay = inst.currentDay;
      inst.drawMonth = inst.selectedMonth = inst.currentMonth;
      inst.drawYear = inst.selectedYear = inst.currentYear;
    } else {
      date = new Date();
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
    }
    this._notifyChange( inst );
    this._adjustDate( target );
  },

  /* Action for selecting a new month/year. */
  _selectMonthYear: function( id, select, period ) {
    var target = $( id ),
      inst = this._getInst( target[ 0 ] );

    inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
    inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
      parseInt( select.options[ select.selectedIndex ].value, 10 );

    this._notifyChange( inst );
    this._adjustDate( target );
  },

  /* Action for selecting a day. */
  _selectDay: function( id, month, year, td ) {
    var inst,
      target = $( id );

    if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
      return;
    }

    inst = this._getInst( target[ 0 ] );
    inst.selectedDay = inst.currentDay = $( "a", td ).html();
    inst.selectedMonth = inst.currentMonth = month;
    inst.selectedYear = inst.currentYear = year;
    this._selectDate( id, this._formatDate( inst,
      inst.currentDay, inst.currentMonth, inst.currentYear ) );
  },

  /* Erase the input field and hide the date picker. */
  _clearDate: function( id ) {
    var target = $( id );
    this._selectDate( target, "" );
  },

  /* Update the input field with the selected date. */
  _selectDate: function( id, dateStr ) {
    var onSelect,
      target = $( id ),
      inst = this._getInst( target[ 0 ] );

    dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
    if ( inst.input ) {
      inst.input.val( dateStr );
    }
    this._updateAlternate( inst );

    onSelect = this._get( inst, "onSelect" );
    if ( onSelect ) {
      onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
    } else if ( inst.input ) {
      inst.input.trigger( "change" ); // fire the change event
    }

    if ( inst.inline ) {
      this._updateDatepicker( inst );
    } else {
      this._hideDatepicker();
      this._lastInput = inst.input[ 0 ];
      if ( typeof( inst.input[ 0 ] ) !== "object" ) {
        inst.input.trigger( "focus" ); // restore focus
      }
      this._lastInput = null;
    }
  },

  /* Update any alternate field to synchronise with the main field. */
  _updateAlternate: function( inst ) {
    var altFormat, date, dateStr,
      altField = this._get( inst, "altField" );

    if ( altField ) { // update alternate field too
      altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
      date = this._getDate( inst );
      dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
      $( altField ).val( dateStr );
    }
  },

  /* Set as beforeShowDay function to prevent selection of weekends.
   * @param  date  Date - the date to customise
   * @return [boolean, string] - is this date selectable?, what is its CSS class?
   */
  noWeekends: function( date ) {
    var day = date.getDay();
    return [ ( day > 0 && day < 6 ), "" ];
  },

  /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
   * @param  date  Date - the date to get the week for
   * @return  number - the number of the week within the year that contains this date
   */
  iso8601Week: function( date ) {
    var time,
      checkDate = new Date( date.getTime() );

    // Find Thursday of this week starting on Monday
    checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

    time = checkDate.getTime();
    checkDate.setMonth( 0 ); // Compare with Jan 1
    checkDate.setDate( 1 );
    return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
  },

  /* Parse a string value into a date object.
   * See formatDate below for the possible formats.
   *
   * @param  format string - the expected format of the date
   * @param  value string - the date in the above format
   * @param  settings Object - attributes include:
   *          shortYearCutoff  number - the cutoff year for determining the century (optional)
   *          dayNamesShort string[7] - abbreviated names of the days from Sunday (optional)
   *          dayNames    string[7] - names of the days from Sunday (optional)
   *          monthNamesShort string[12] - abbreviated names of the months (optional)
   *          monthNames    string[12] - names of the months (optional)
   * @return  Date - the extracted date value or null if value is blank
   */
  parseDate: function( format, value, settings ) {
    if ( format == null || value == null ) {
      throw "Invalid arguments";
    }

    value = ( typeof value === "object" ? value.toString() : value + "" );
    if ( value === "" ) {
      return null;
    }

    var iFormat, dim, extra,
      iValue = 0,
      shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
      shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
        new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
      dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
      dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
      monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
      monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
      year = -1,
      month = -1,
      day = -1,
      doy = -1,
      literal = false,
      date,

      // Check whether a format character is doubled
      lookAhead = function( match ) {
        var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
        if ( matches ) {
          iFormat++;
        }
        return matches;
      },

      // Extract a number from the string value
      getNumber = function( match ) {
        var isDoubled = lookAhead( match ),
          size = ( match === "@" ? 14 : ( match === "!" ? 20 :
          ( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
          minSize = ( match === "y" ? size : 1 ),
          digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
          num = value.substring( iValue ).match( digits );
        if ( !num ) {
          throw "Missing number at position " + iValue;
        }
        iValue += num[ 0 ].length;
        return parseInt( num[ 0 ], 10 );
      },

      // Extract a name from the string value and convert to an index
      getName = function( match, shortNames, longNames ) {
        var index = -1,
          names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
            return [ [ k, v ] ];
          } ).sort( function( a, b ) {
            return -( a[ 1 ].length - b[ 1 ].length );
          } );

        $.each( names, function( i, pair ) {
          var name = pair[ 1 ];
          if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
            index = pair[ 0 ];
            iValue += name.length;
            return false;
          }
        } );
        if ( index !== -1 ) {
          return index + 1;
        } else {
          throw "Unknown name at position " + iValue;
        }
      },

      // Confirm that a literal character matches the string value
      checkLiteral = function() {
        if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
          throw "Unexpected literal at position " + iValue;
        }
        iValue++;
      };

    for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
      if ( literal ) {
        if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
          literal = false;
        } else {
          checkLiteral();
        }
      } else {
        switch ( format.charAt( iFormat ) ) {
          case "d":
            day = getNumber( "d" );
            break;
          case "D":
            getName( "D", dayNamesShort, dayNames );
            break;
          case "o":
            doy = getNumber( "o" );
            break;
          case "m":
            month = getNumber( "m" );
            break;
          case "M":
            month = getName( "M", monthNamesShort, monthNames );
            break;
          case "y":
            year = getNumber( "y" );
            break;
          case "@":
            date = new Date( getNumber( "@" ) );
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case "!":
            date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case "'":
            if ( lookAhead( "'" ) ) {
              checkLiteral();
            } else {
              literal = true;
            }
            break;
          default:
            checkLiteral();
        }
      }
    }

    if ( iValue < value.length ) {
      extra = value.substr( iValue );
      if ( !/^\s+/.test( extra ) ) {
        throw "Extra/unparsed characters found in date: " + extra;
      }
    }

    if ( year === -1 ) {
      year = new Date().getFullYear();
    } else if ( year < 100 ) {
      year += new Date().getFullYear() - new Date().getFullYear() % 100 +
        ( year <= shortYearCutoff ? 0 : -100 );
    }

    if ( doy > -1 ) {
      month = 1;
      day = doy;
      do {
        dim = this._getDaysInMonth( year, month - 1 );
        if ( day <= dim ) {
          break;
        }
        month++;
        day -= dim;
      } while ( true );
    }

    date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
    if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
      throw "Invalid date"; // E.g. 31/02/00
    }
    return date;
  },

  /* Standard date formats. */
  ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
  COOKIE: "D, dd M yy",
  ISO_8601: "yy-mm-dd",
  RFC_822: "D, d M y",
  RFC_850: "DD, dd-M-y",
  RFC_1036: "D, d M y",
  RFC_1123: "D, d M yy",
  RFC_2822: "D, d M yy",
  RSS: "D, d M y", // RFC 822
  TICKS: "!",
  TIMESTAMP: "@",
  W3C: "yy-mm-dd", // ISO 8601

  _ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
    Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

  /* Format a date object into a string value.
   * The format can be combinations of the following:
   * d  - day of month (no leading zero)
   * dd - day of month (two digit)
   * o  - day of year (no leading zeros)
   * oo - day of year (three digit)
   * D  - day name short
   * DD - day name long
   * m  - month of year (no leading zero)
   * mm - month of year (two digit)
   * M  - month name short
   * MM - month name long
   * y  - year (two digit)
   * yy - year (four digit)
   * @ - Unix timestamp (ms since 01/01/1970)
   * ! - Windows ticks (100ns since 01/01/0001)
   * "..." - literal text
   * '' - single quote
   *
   * @param  format string - the desired format of the date
   * @param  date Date - the date value to format
   * @param  settings Object - attributes include:
   *          dayNamesShort string[7] - abbreviated names of the days from Sunday (optional)
   *          dayNames    string[7] - names of the days from Sunday (optional)
   *          monthNamesShort string[12] - abbreviated names of the months (optional)
   *          monthNames    string[12] - names of the months (optional)
   * @return  string - the date in the above format
   */
  formatDate: function( format, date, settings ) {
    if ( !date ) {
      return "";
    }

    var iFormat,
      dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
      dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
      monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
      monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

      // Check whether a format character is doubled
      lookAhead = function( match ) {
        var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
        if ( matches ) {
          iFormat++;
        }
        return matches;
      },

      // Format a number, with leading zero if necessary
      formatNumber = function( match, value, len ) {
        var num = "" + value;
        if ( lookAhead( match ) ) {
          while ( num.length < len ) {
            num = "0" + num;
          }
        }
        return num;
      },

      // Format a name, short or long as requested
      formatName = function( match, value, shortNames, longNames ) {
        return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
      },
      output = "",
      literal = false;

    if ( date ) {
      for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
        if ( literal ) {
          if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
            literal = false;
          } else {
            output += format.charAt( iFormat );
          }
        } else {
          switch ( format.charAt( iFormat ) ) {
            case "d":
              output += formatNumber( "d", date.getDate(), 2 );
              break;
            case "D":
              output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
              break;
            case "o":
              output += formatNumber( "o",
                Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
              break;
            case "m":
              output += formatNumber( "m", date.getMonth() + 1, 2 );
              break;
            case "M":
              output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
              break;
            case "y":
              output += ( lookAhead( "y" ) ? date.getFullYear() :
                ( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
              break;
            case "@":
              output += date.getTime();
              break;
            case "!":
              output += date.getTime() * 10000 + this._ticksTo1970;
              break;
            case "'":
              if ( lookAhead( "'" ) ) {
                output += "'";
              } else {
                literal = true;
              }
              break;
            default:
              output += format.charAt( iFormat );
          }
        }
      }
    }
    return output;
  },

  /* Extract all possible characters from the date format. */
  _possibleChars: function( format ) {
    var iFormat,
      chars = "",
      literal = false,

      // Check whether a format character is doubled
      lookAhead = function( match ) {
        var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
        if ( matches ) {
          iFormat++;
        }
        return matches;
      };

    for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
      if ( literal ) {
        if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
          literal = false;
        } else {
          chars += format.charAt( iFormat );
        }
      } else {
        switch ( format.charAt( iFormat ) ) {
          case "d": case "m": case "y": case "@":
            chars += "0123456789";
            break;
          case "D": case "M":
            return null; // Accept anything
          case "'":
            if ( lookAhead( "'" ) ) {
              chars += "'";
            } else {
              literal = true;
            }
            break;
          default:
            chars += format.charAt( iFormat );
        }
      }
    }
    return chars;
  },

  /* Get a setting value, defaulting if necessary. */
  _get: function( inst, name ) {
    return inst.settings[ name ] !== undefined ?
      inst.settings[ name ] : this._defaults[ name ];
  },

  /* Parse existing date and initialise date picker. */
  _setDateFromField: function( inst, noDefault ) {
    if ( inst.input.val() === inst.lastVal ) {
      return;
    }

    var dateFormat = this._get( inst, "dateFormat" ),
      dates = inst.lastVal = inst.input ? inst.input.val() : null,
      defaultDate = this._getDefaultDate( inst ),
      date = defaultDate,
      settings = this._getFormatConfig( inst );

    try {
      date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
    } catch ( event ) {
      dates = ( noDefault ? "" : dates );
    }
    inst.selectedDay = date.getDate();
    inst.drawMonth = inst.selectedMonth = date.getMonth();
    inst.drawYear = inst.selectedYear = date.getFullYear();
    inst.currentDay = ( dates ? date.getDate() : 0 );
    inst.currentMonth = ( dates ? date.getMonth() : 0 );
    inst.currentYear = ( dates ? date.getFullYear() : 0 );
    this._adjustInstDate( inst );
  },

  /* Retrieve the default date shown on opening. */
  _getDefaultDate: function( inst ) {
    return this._restrictMinMax( inst,
      this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
  },

  /* A date may be specified as an exact value or a relative one. */
  _determineDate: function( inst, date, defaultDate ) {
    var offsetNumeric = function( offset ) {
        var date = new Date();
        date.setDate( date.getDate() + offset );
        return date;
      },
      offsetString = function( offset ) {
        try {
          return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
            offset, $.datepicker._getFormatConfig( inst ) );
        }
        catch ( e ) {

          // Ignore
        }

        var date = ( offset.toLowerCase().match( /^c/ ) ?
          $.datepicker._getDate( inst ) : null ) || new Date(),
          year = date.getFullYear(),
          month = date.getMonth(),
          day = date.getDate(),
          pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
          matches = pattern.exec( offset );

        while ( matches ) {
          switch ( matches[ 2 ] || "d" ) {
            case "d" : case "D" :
              day += parseInt( matches[ 1 ], 10 ); break;
            case "w" : case "W" :
              day += parseInt( matches[ 1 ], 10 ) * 7; break;
            case "m" : case "M" :
              month += parseInt( matches[ 1 ], 10 );
              day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
              break;
            case "y": case "Y" :
              year += parseInt( matches[ 1 ], 10 );
              day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
              break;
          }
          matches = pattern.exec( offset );
        }
        return new Date( year, month, day );
      },
      newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
        ( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

    newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
    if ( newDate ) {
      newDate.setHours( 0 );
      newDate.setMinutes( 0 );
      newDate.setSeconds( 0 );
      newDate.setMilliseconds( 0 );
    }
    return this._daylightSavingAdjust( newDate );
  },

  /* Handle switch to/from daylight saving.
   * Hours may be non-zero on daylight saving cut-over:
   * > 12 when midnight changeover, but then cannot generate
   * midnight datetime, so jump to 1AM, otherwise reset.
   * @param  date  (Date) the date to check
   * @return  (Date) the corrected date
   */
  _daylightSavingAdjust: function( date ) {
    if ( !date ) {
      return null;
    }
    date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
    return date;
  },

  /* Set the date(s) directly. */
  _setDate: function( inst, date, noChange ) {
    var clear = !date,
      origMonth = inst.selectedMonth,
      origYear = inst.selectedYear,
      newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

    inst.selectedDay = inst.currentDay = newDate.getDate();
    inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
    inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
    if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
      this._notifyChange( inst );
    }
    this._adjustInstDate( inst );
    if ( inst.input ) {
      inst.input.val( clear ? "" : this._formatDate( inst ) );
    }
  },

  /* Retrieve the date(s) directly. */
  _getDate: function( inst ) {
    var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
      this._daylightSavingAdjust( new Date(
      inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
      return startDate;
  },

  /* Attach the onxxx handlers.  These are declared statically so
   * they work with static code transformers like Caja.
   */
  _attachHandlers: function( inst ) {
    var stepMonths = this._get( inst, "stepMonths" ),
      id = "#" + inst.id.replace( /\\\\/g, "\\" );
    inst.dpDiv.find( "[data-handler]" ).map( function() {
      var handler = {
        prev: function() {
          $.datepicker._adjustDate( id, -stepMonths, "M" );
        },
        next: function() {
          $.datepicker._adjustDate( id, +stepMonths, "M" );
        },
        hide: function() {
          $.datepicker._hideDatepicker();
        },
        today: function() {
          $.datepicker._gotoToday( id );
        },
        selectDay: function() {
          $.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
          return false;
        },
        selectMonth: function() {
          $.datepicker._selectMonthYear( id, this, "M" );
          return false;
        },
        selectYear: function() {
          $.datepicker._selectMonthYear( id, this, "Y" );
          return false;
        }
      };
      $( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
    } );
  },

  /* Generate the HTML for the current state of the date picker. */
  _generateHTML: function( inst ) {
    var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
      controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
      monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
      selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
      cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
      printDate, dRow, tbody, daySettings, otherMonth, unselectable,
      tempDate = new Date(),
      today = this._daylightSavingAdjust(
        new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
      isRTL = this._get( inst, "isRTL" ),
      showButtonPanel = this._get( inst, "showButtonPanel" ),
      hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
      navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
      numMonths = this._getNumberOfMonths( inst ),
      showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
      stepMonths = this._get( inst, "stepMonths" ),
      isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
      currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
        new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
      minDate = this._getMinMaxDate( inst, "min" ),
      maxDate = this._getMinMaxDate( inst, "max" ),
      drawMonth = inst.drawMonth - showCurrentAtPos,
      drawYear = inst.drawYear;

    if ( drawMonth < 0 ) {
      drawMonth += 12;
      drawYear--;
    }
    if ( maxDate ) {
      maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
        maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
      maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
      while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
        drawMonth--;
        if ( drawMonth < 0 ) {
          drawMonth = 11;
          drawYear--;
        }
      }
    }
    inst.drawMonth = drawMonth;
    inst.drawYear = drawYear;

    prevText = this._get( inst, "prevText" );
    prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
      this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
      this._getFormatConfig( inst ) ) );

    prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
      "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
      " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
      ( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );

    nextText = this._get( inst, "nextText" );
    nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
      this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
      this._getFormatConfig( inst ) ) );

    next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
      "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
      " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
      ( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );

    currentText = this._get( inst, "currentText" );
    gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
    currentText = ( !navigationAsDateFormat ? currentText :
      this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

    controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
      this._get( inst, "closeText" ) + "</button>" : "" );

    buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
      ( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
      ">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";

    firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
    firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

    showWeek = this._get( inst, "showWeek" );
    dayNames = this._get( inst, "dayNames" );
    dayNamesMin = this._get( inst, "dayNamesMin" );
    monthNames = this._get( inst, "monthNames" );
    monthNamesShort = this._get( inst, "monthNamesShort" );
    beforeShowDay = this._get( inst, "beforeShowDay" );
    showOtherMonths = this._get( inst, "showOtherMonths" );
    selectOtherMonths = this._get( inst, "selectOtherMonths" );
    defaultDate = this._getDefaultDate( inst );
    html = "";

    for ( row = 0; row < numMonths[ 0 ]; row++ ) {
      group = "";
      this.maxRows = 4;
      for ( col = 0; col < numMonths[ 1 ]; col++ ) {
        selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
        cornerClass = " ui-corner-all";
        calender = "";
        if ( isMultiMonth ) {
          calender += "<div class='ui-datepicker-group";
          if ( numMonths[ 1 ] > 1 ) {
            switch ( col ) {
              case 0: calender += " ui-datepicker-group-first";
                cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
              case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
                cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
              default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
            }
          }
          calender += "'>";
        }
        calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
          ( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
          ( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
          this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
          row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
          "</div><table class='ui-datepicker-calendar'><thead>" +
          "<tr>";
        thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
        for ( dow = 0; dow < 7; dow++ ) { // days of the week
          day = ( dow + firstDay ) % 7;
          thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
            "<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
        }
        calender += thead + "</tr></thead><tbody>";
        daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
        if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
          inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
        }
        leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
        curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
        numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
        this.maxRows = numRows;
        printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
        for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
          calender += "<tr>";
          tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
            this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
          for ( dow = 0; dow < 7; dow++ ) { // create date picker days
            daySettings = ( beforeShowDay ?
              beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
            otherMonth = ( printDate.getMonth() !== drawMonth );
            unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
              ( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
            tbody += "<td class='" +
              ( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
              ( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
              ( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
              ( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

              // or defaultDate is current printedDate and defaultDate is selectedDate
              " " + this._dayOverClass : "" ) + // highlight selected day
              ( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
              ( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
              ( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
              ( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
              ( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
              ( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
              ( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
              ( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
              ( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
              ( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
              ( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
              "' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
            printDate.setDate( printDate.getDate() + 1 );
            printDate = this._daylightSavingAdjust( printDate );
          }
          calender += tbody + "</tr>";
        }
        drawMonth++;
        if ( drawMonth > 11 ) {
          drawMonth = 0;
          drawYear++;
        }
        calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
              ( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
        group += calender;
      }
      html += group;
    }
    html += buttonPanel;
    inst._keyEvent = false;
    return html;
  },

  /* Generate the month and year header. */
  _generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
      secondary, monthNames, monthNamesShort ) {

    var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
      changeMonth = this._get( inst, "changeMonth" ),
      changeYear = this._get( inst, "changeYear" ),
      showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
      html = "<div class='ui-datepicker-title'>",
      monthHtml = "";

    // Month selection
    if ( secondary || !changeMonth ) {
      monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
    } else {
      inMinYear = ( minDate && minDate.getFullYear() === drawYear );
      inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
      monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
      for ( month = 0; month < 12; month++ ) {
        if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
          monthHtml += "<option value='" + month + "'" +
            ( month === drawMonth ? " selected='selected'" : "" ) +
            ">" + monthNamesShort[ month ] + "</option>";
        }
      }
      monthHtml += "</select>";
    }

    if ( !showMonthAfterYear ) {
      html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
    }

    // Year selection
    if ( !inst.yearshtml ) {
      inst.yearshtml = "";
      if ( secondary || !changeYear ) {
        html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
      } else {

        // determine range of years to display
        years = this._get( inst, "yearRange" ).split( ":" );
        thisYear = new Date().getFullYear();
        determineYear = function( value ) {
          var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
            ( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
            parseInt( value, 10 ) ) );
          return ( isNaN( year ) ? thisYear : year );
        };
        year = determineYear( years[ 0 ] );
        endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
        year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
        endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
        inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
        for ( ; year <= endYear; year++ ) {
          inst.yearshtml += "<option value='" + year + "'" +
            ( year === drawYear ? " selected='selected'" : "" ) +
            ">" + year + "</option>";
        }
        inst.yearshtml += "</select>";

        html += inst.yearshtml;
        inst.yearshtml = null;
      }
    }

    html += this._get( inst, "yearSuffix" );
    if ( showMonthAfterYear ) {
      html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
    }
    html += "</div>"; // Close datepicker_header
    return html;
  },

  /* Adjust one of the date sub-fields. */
  _adjustInstDate: function( inst, offset, period ) {
    var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
      month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
      day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
      date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

    inst.selectedDay = date.getDate();
    inst.drawMonth = inst.selectedMonth = date.getMonth();
    inst.drawYear = inst.selectedYear = date.getFullYear();
    if ( period === "M" || period === "Y" ) {
      this._notifyChange( inst );
    }
  },

  /* Ensure a date is within any min/max bounds. */
  _restrictMinMax: function( inst, date ) {
    var minDate = this._getMinMaxDate( inst, "min" ),
      maxDate = this._getMinMaxDate( inst, "max" ),
      newDate = ( minDate && date < minDate ? minDate : date );
    return ( maxDate && newDate > maxDate ? maxDate : newDate );
  },

  /* Notify change of month/year. */
  _notifyChange: function( inst ) {
    var onChange = this._get( inst, "onChangeMonthYear" );
    if ( onChange ) {
      onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
        [ inst.selectedYear, inst.selectedMonth + 1, inst ] );
    }
  },

  /* Determine the number of months to show. */
  _getNumberOfMonths: function( inst ) {
    var numMonths = this._get( inst, "numberOfMonths" );
    return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
  },

  /* Determine the current maximum date - ensure no time components are set. */
  _getMinMaxDate: function( inst, minMax ) {
    return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
  },

  /* Find the number of days in a given month. */
  _getDaysInMonth: function( year, month ) {
    return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
  },

  /* Find the day of the week of the first of a month. */
  _getFirstDayOfMonth: function( year, month ) {
    return new Date( year, month, 1 ).getDay();
  },

  /* Determines if we should allow a "next/prev" month display change. */
  _canAdjustMonth: function( inst, offset, curYear, curMonth ) {
    var numMonths = this._getNumberOfMonths( inst ),
      date = this._daylightSavingAdjust( new Date( curYear,
      curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

    if ( offset < 0 ) {
      date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
    }
    return this._isInRange( inst, date );
  },

  /* Is the given date in the accepted range? */
  _isInRange: function( inst, date ) {
    var yearSplit, currentYear,
      minDate = this._getMinMaxDate( inst, "min" ),
      maxDate = this._getMinMaxDate( inst, "max" ),
      minYear = null,
      maxYear = null,
      years = this._get( inst, "yearRange" );
      if ( years ) {
        yearSplit = years.split( ":" );
        currentYear = new Date().getFullYear();
        minYear = parseInt( yearSplit[ 0 ], 10 );
        maxYear = parseInt( yearSplit[ 1 ], 10 );
        if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
          minYear += currentYear;
        }
        if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
          maxYear += currentYear;
        }
      }

    return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
      ( !maxDate || date.getTime() <= maxDate.getTime() ) &&
      ( !minYear || date.getFullYear() >= minYear ) &&
      ( !maxYear || date.getFullYear() <= maxYear ) );
  },

  /* Provide the configuration settings for formatting/parsing. */
  _getFormatConfig: function( inst ) {
    var shortYearCutoff = this._get( inst, "shortYearCutoff" );
    shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
      new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
    return { shortYearCutoff: shortYearCutoff,
      dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
      monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
  },

  /* Format the given date for display. */
  _formatDate: function( inst, day, month, year ) {
    if ( !day ) {
      inst.currentDay = inst.selectedDay;
      inst.currentMonth = inst.selectedMonth;
      inst.currentYear = inst.selectedYear;
    }
    var date = ( day ? ( typeof day === "object" ? day :
      this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
      this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
    return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
  }
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
  var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
  return dpDiv.on( "mouseout", selector, function() {
      $( this ).removeClass( "ui-state-hover" );
      if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
        $( this ).removeClass( "ui-datepicker-prev-hover" );
      }
      if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
        $( this ).removeClass( "ui-datepicker-next-hover" );
      }
    } )
    .on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
  if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
    $( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
    $( this ).addClass( "ui-state-hover" );
    if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
      $( this ).addClass( "ui-datepicker-prev-hover" );
    }
    if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
      $( this ).addClass( "ui-datepicker-next-hover" );
    }
  }
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
  $.extend( target, props );
  for ( var name in props ) {
    if ( props[ name ] == null ) {
      target[ name ] = props[ name ];
    }
  }
  return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
          Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

  /* Verify an empty collection wasn't passed - Fixes #6976 */
  if ( !this.length ) {
    return this;
  }

  /* Initialise the date picker. */
  if ( !$.datepicker.initialized ) {
    $( document ).on( "mousedown", $.datepicker._checkExternalClick );
    $.datepicker.initialized = true;
  }

  /* Append datepicker main container to body if not exist. */
  if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
    $( "body" ).append( $.datepicker.dpDiv );
  }

  var otherArgs = Array.prototype.slice.call( arguments, 1 );
  if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
    return $.datepicker[ "_" + options + "Datepicker" ].
      apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
  }
  if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
    return $.datepicker[ "_" + options + "Datepicker" ].
      apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
  }
  return this.each( function() {
    typeof options === "string" ?
      $.datepicker[ "_" + options + "Datepicker" ].
        apply( $.datepicker, [ this ].concat( otherArgs ) ) :
      $.datepicker._attachDatepicker( this, options );
  } );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.12.1";

var widgetsDatepicker = $.datepicker;




// This file is deprecated
var ie = $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/



var mouseHandled = false;
$( document ).on( "mouseup", function() {
  mouseHandled = false;
} );

var widgetsMouse = $.widget( "ui.mouse", {
  version: "1.12.1",
  options: {
    cancel: "input, textarea, button, select, option",
    distance: 1,
    delay: 0
  },
  _mouseInit: function() {
    var that = this;

    this.element
      .on( "mousedown." + this.widgetName, function( event ) {
        return that._mouseDown( event );
      } )
      .on( "click." + this.widgetName, function( event ) {
        if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
          $.removeData( event.target, that.widgetName + ".preventClickEvent" );
          event.stopImmediatePropagation();
          return false;
        }
      } );

    this.started = false;
  },

  // TODO: make sure destroying one instance of mouse doesn't mess with
  // other instances of mouse
  _mouseDestroy: function() {
    this.element.off( "." + this.widgetName );
    if ( this._mouseMoveDelegate ) {
      this.document
        .off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
        .off( "mouseup." + this.widgetName, this._mouseUpDelegate );
    }
  },

  _mouseDown: function( event ) {

    // don't let more than one widget handle mouseStart
    if ( mouseHandled ) {
      return;
    }

    this._mouseMoved = false;

    // We may have missed mouseup (out of window)
    ( this._mouseStarted && this._mouseUp( event ) );

    this._mouseDownEvent = event;

    var that = this,
      btnIsLeft = ( event.which === 1 ),

      // event.target.nodeName works around a bug in IE 8 with
      // disabled inputs (#7620)
      elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
        $( event.target ).closest( this.options.cancel ).length : false );
    if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
      return true;
    }

    this.mouseDelayMet = !this.options.delay;
    if ( !this.mouseDelayMet ) {
      this._mouseDelayTimer = setTimeout( function() {
        that.mouseDelayMet = true;
      }, this.options.delay );
    }

    if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
      this._mouseStarted = ( this._mouseStart( event ) !== false );
      if ( !this._mouseStarted ) {
        event.preventDefault();
        return true;
      }
    }

    // Click event may never have fired (Gecko & Opera)
    if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
      $.removeData( event.target, this.widgetName + ".preventClickEvent" );
    }

    // These delegates are required to keep context
    this._mouseMoveDelegate = function( event ) {
      return that._mouseMove( event );
    };
    this._mouseUpDelegate = function( event ) {
      return that._mouseUp( event );
    };

    this.document
      .on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
      .on( "mouseup." + this.widgetName, this._mouseUpDelegate );

    event.preventDefault();

    mouseHandled = true;
    return true;
  },

  _mouseMove: function( event ) {

    // Only check for mouseups outside the document if you've moved inside the document
    // at least once. This prevents the firing of mouseup in the case of IE<9, which will
    // fire a mousemove event if content is placed under the cursor. See #7778
    // Support: IE <9
    if ( this._mouseMoved ) {

      // IE mouseup check - mouseup happened when mouse was out of window
      if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
          !event.button ) {
        return this._mouseUp( event );

      // Iframe mouseup check - mouseup occurred in another document
      } else if ( !event.which ) {

        // Support: Safari <=8 - 9
        // Safari sets which to 0 if you press any of the following keys
        // during a drag (#14461)
        if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
            event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
          this.ignoreMissingWhich = true;
        } else if ( !this.ignoreMissingWhich ) {
          return this._mouseUp( event );
        }
      }
    }

    if ( event.which || event.button ) {
      this._mouseMoved = true;
    }

    if ( this._mouseStarted ) {
      this._mouseDrag( event );
      return event.preventDefault();
    }

    if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
      this._mouseStarted =
        ( this._mouseStart( this._mouseDownEvent, event ) !== false );
      ( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
    }

    return !this._mouseStarted;
  },

  _mouseUp: function( event ) {
    this.document
      .off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
      .off( "mouseup." + this.widgetName, this._mouseUpDelegate );

    if ( this._mouseStarted ) {
      this._mouseStarted = false;

      if ( event.target === this._mouseDownEvent.target ) {
        $.data( event.target, this.widgetName + ".preventClickEvent", true );
      }

      this._mouseStop( event );
    }

    if ( this._mouseDelayTimer ) {
      clearTimeout( this._mouseDelayTimer );
      delete this._mouseDelayTimer;
    }

    this.ignoreMissingWhich = false;
    mouseHandled = false;
    event.preventDefault();
  },

  _mouseDistanceMet: function( event ) {
    return ( Math.max(
        Math.abs( this._mouseDownEvent.pageX - event.pageX ),
        Math.abs( this._mouseDownEvent.pageY - event.pageY )
      ) >= this.options.distance
    );
  },

  _mouseDelayMet: function( /* event */ ) {
    return this.mouseDelayMet;
  },

  // These are placeholder methods, to be overriden by extending plugin
  _mouseStart: function( /* event */ ) {},
  _mouseDrag: function( /* event */ ) {},
  _mouseStop: function( /* event */ ) {},
  _mouseCapture: function( /* event */ ) { return true; }
} );




// $.ui.plugin is deprecated. Use $.widget() extensions instead.
var plugin = $.ui.plugin = {
  add: function( module, option, set ) {
    var i,
      proto = $.ui[ module ].prototype;
    for ( i in set ) {
      proto.plugins[ i ] = proto.plugins[ i ] || [];
      proto.plugins[ i ].push( [ option, set[ i ] ] );
    }
  },
  call: function( instance, name, args, allowDisconnected ) {
    var i,
      set = instance.plugins[ name ];

    if ( !set ) {
      return;
    }

    if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
        instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
      return;
    }

    for ( i = 0; i < set.length; i++ ) {
      if ( instance.options[ set[ i ][ 0 ] ] ) {
        set[ i ][ 1 ].apply( instance.element, args );
      }
    }
  }
};



var safeBlur = $.ui.safeBlur = function( element ) {

  // Support: IE9 - 10 only
  // If the <body> is blurred, IE will switch windows, see #9420
  if ( element && element.nodeName.toLowerCase() !== "body" ) {
    $( element ).trigger( "blur" );
  }
};


/*!
 * jQuery UI Draggable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Draggable
//>>group: Interactions
//>>description: Enables dragging functionality for any element.
//>>docs: http://api.jqueryui.com/draggable/
//>>demos: http://jqueryui.com/draggable/
//>>css.structure: ../../themes/base/draggable.css



$.widget( "ui.draggable", $.ui.mouse, {
  version: "1.12.1",
  widgetEventPrefix: "drag",
  options: {
    addClasses: true,
    appendTo: "parent",
    axis: false,
    connectToSortable: false,
    containment: false,
    cursor: "auto",
    cursorAt: false,
    grid: false,
    handle: false,
    helper: "original",
    iframeFix: false,
    opacity: false,
    refreshPositions: false,
    revert: false,
    revertDuration: 500,
    scope: "default",
    scroll: true,
    scrollSensitivity: 20,
    scrollSpeed: 20,
    snap: false,
    snapMode: "both",
    snapTolerance: 20,
    stack: false,
    zIndex: false,

    // Callbacks
    drag: null,
    start: null,
    stop: null
  },
  _create: function() {

    if ( this.options.helper === "original" ) {
      this._setPositionRelative();
    }
    if ( this.options.addClasses ) {
      this._addClass( "ui-draggable" );
    }
    this._setHandleClassName();

    this._mouseInit();
  },

  _setOption: function( key, value ) {
    this._super( key, value );
    if ( key === "handle" ) {
      this._removeHandleClassName();
      this._setHandleClassName();
    }
  },

  _destroy: function() {
    if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
      this.destroyOnClear = true;
      return;
    }
    this._removeHandleClassName();
    this._mouseDestroy();
  },

  _mouseCapture: function( event ) {
    var o = this.options;

    // Among others, prevent a drag on a resizable-handle
    if ( this.helper || o.disabled ||
        $( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
      return false;
    }

    //Quit if we're not on a valid handle
    this.handle = this._getHandle( event );
    if ( !this.handle ) {
      return false;
    }

    this._blurActiveElement( event );

    this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

    return true;

  },

  _blockFrames: function( selector ) {
    this.iframeBlocks = this.document.find( selector ).map( function() {
      var iframe = $( this );

      return $( "<div>" )
        .css( "position", "absolute" )
        .appendTo( iframe.parent() )
        .outerWidth( iframe.outerWidth() )
        .outerHeight( iframe.outerHeight() )
        .offset( iframe.offset() )[ 0 ];
    } );
  },

  _unblockFrames: function() {
    if ( this.iframeBlocks ) {
      this.iframeBlocks.remove();
      delete this.iframeBlocks;
    }
  },

  _blurActiveElement: function( event ) {
    var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
      target = $( event.target );

    // Don't blur if the event occurred on an element that is within
    // the currently focused element
    // See #10527, #12472
    if ( target.closest( activeElement ).length ) {
      return;
    }

    // Blur any element that currently has focus, see #4261
    $.ui.safeBlur( activeElement );
  },

  _mouseStart: function( event ) {

    var o = this.options;

    //Create and append the visible helper
    this.helper = this._createHelper( event );

    this._addClass( this.helper, "ui-draggable-dragging" );

    //Cache the helper size
    this._cacheHelperProportions();

    //If ddmanager is used for droppables, set the global draggable
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.current = this;
    }

    /*
     * - Position generation -
     * This block generates everything position related - it's the core of draggables.
     */

    //Cache the margins of the original element
    this._cacheMargins();

    //Store the helper's css position
    this.cssPosition = this.helper.css( "position" );
    this.scrollParent = this.helper.scrollParent( true );
    this.offsetParent = this.helper.offsetParent();
    this.hasFixedAncestor = this.helper.parents().filter( function() {
        return $( this ).css( "position" ) === "fixed";
      } ).length > 0;

    //The element's absolute position on the page minus margins
    this.positionAbs = this.element.offset();
    this._refreshOffsets( event );

    //Generate the original position
    this.originalPosition = this.position = this._generatePosition( event, false );
    this.originalPageX = event.pageX;
    this.originalPageY = event.pageY;

    //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
    ( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

    //Set a containment if given in the options
    this._setContainment();

    //Trigger event + callbacks
    if ( this._trigger( "start", event ) === false ) {
      this._clear();
      return false;
    }

    //Recache the helper size
    this._cacheHelperProportions();

    //Prepare the droppable offsets
    if ( $.ui.ddmanager && !o.dropBehaviour ) {
      $.ui.ddmanager.prepareOffsets( this, event );
    }

    // Execute the drag once - this causes the helper not to be visible before getting its
    // correct position
    this._mouseDrag( event, true );

    // If the ddmanager is used for droppables, inform the manager that dragging has started
    // (see #5003)
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.dragStart( this, event );
    }

    return true;
  },

  _refreshOffsets: function( event ) {
    this.offset = {
      top: this.positionAbs.top - this.margins.top,
      left: this.positionAbs.left - this.margins.left,
      scroll: false,
      parent: this._getParentOffset(),
      relative: this._getRelativeOffset()
    };

    this.offset.click = {
      left: event.pageX - this.offset.left,
      top: event.pageY - this.offset.top
    };
  },

  _mouseDrag: function( event, noPropagation ) {

    // reset any necessary cached properties (see #5009)
    if ( this.hasFixedAncestor ) {
      this.offset.parent = this._getParentOffset();
    }

    //Compute the helpers position
    this.position = this._generatePosition( event, true );
    this.positionAbs = this._convertPositionTo( "absolute" );

    //Call plugins and callbacks and use the resulting position if something is returned
    if ( !noPropagation ) {
      var ui = this._uiHash();
      if ( this._trigger( "drag", event, ui ) === false ) {
        this._mouseUp( new $.Event( "mouseup", event ) );
        return false;
      }
      this.position = ui.position;
    }

    this.helper[ 0 ].style.left = this.position.left + "px";
    this.helper[ 0 ].style.top = this.position.top + "px";

    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.drag( this, event );
    }

    return false;
  },

  _mouseStop: function( event ) {

    //If we are using droppables, inform the manager about the drop
    var that = this,
      dropped = false;
    if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
      dropped = $.ui.ddmanager.drop( this, event );
    }

    //if a drop comes from outside (a sortable)
    if ( this.dropped ) {
      dropped = this.dropped;
      this.dropped = false;
    }

    if ( ( this.options.revert === "invalid" && !dropped ) ||
        ( this.options.revert === "valid" && dropped ) ||
        this.options.revert === true || ( $.isFunction( this.options.revert ) &&
        this.options.revert.call( this.element, dropped ) )
    ) {
      $( this.helper ).animate(
        this.originalPosition,
        parseInt( this.options.revertDuration, 10 ),
        function() {
          if ( that._trigger( "stop", event ) !== false ) {
            that._clear();
          }
        }
      );
    } else {
      if ( this._trigger( "stop", event ) !== false ) {
        this._clear();
      }
    }

    return false;
  },

  _mouseUp: function( event ) {
    this._unblockFrames();

    // If the ddmanager is used for droppables, inform the manager that dragging has stopped
    // (see #5003)
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.dragStop( this, event );
    }

    // Only need to focus if the event occurred on the draggable itself, see #10527
    if ( this.handleElement.is( event.target ) ) {

      // The interaction is over; whether or not the click resulted in a drag,
      // focus the element
      this.element.trigger( "focus" );
    }

    return $.ui.mouse.prototype._mouseUp.call( this, event );
  },

  cancel: function() {

    if ( this.helper.is( ".ui-draggable-dragging" ) ) {
      this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
    } else {
      this._clear();
    }

    return this;

  },

  _getHandle: function( event ) {
    return this.options.handle ?
      !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
      true;
  },

  _setHandleClassName: function() {
    this.handleElement = this.options.handle ?
      this.element.find( this.options.handle ) : this.element;
    this._addClass( this.handleElement, "ui-draggable-handle" );
  },

  _removeHandleClassName: function() {
    this._removeClass( this.handleElement, "ui-draggable-handle" );
  },

  _createHelper: function( event ) {

    var o = this.options,
      helperIsFunction = $.isFunction( o.helper ),
      helper = helperIsFunction ?
        $( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
        ( o.helper === "clone" ?
          this.element.clone().removeAttr( "id" ) :
          this.element );

    if ( !helper.parents( "body" ).length ) {
      helper.appendTo( ( o.appendTo === "parent" ?
        this.element[ 0 ].parentNode :
        o.appendTo ) );
    }

    // Http://bugs.jqueryui.com/ticket/9446
    // a helper function can return the original element
    // which wouldn't have been set to relative in _create
    if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
      this._setPositionRelative();
    }

    if ( helper[ 0 ] !== this.element[ 0 ] &&
        !( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
      helper.css( "position", "absolute" );
    }

    return helper;

  },

  _setPositionRelative: function() {
    if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
      this.element[ 0 ].style.position = "relative";
    }
  },

  _adjustOffsetFromHelper: function( obj ) {
    if ( typeof obj === "string" ) {
      obj = obj.split( " " );
    }
    if ( $.isArray( obj ) ) {
      obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
    }
    if ( "left" in obj ) {
      this.offset.click.left = obj.left + this.margins.left;
    }
    if ( "right" in obj ) {
      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
    }
    if ( "top" in obj ) {
      this.offset.click.top = obj.top + this.margins.top;
    }
    if ( "bottom" in obj ) {
      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
    }
  },

  _isRootNode: function( element ) {
    return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
  },

  _getParentOffset: function() {

    //Get the offsetParent and cache its position
    var po = this.offsetParent.offset(),
      document = this.document[ 0 ];

    // This is a special case where we need to modify a offset calculated on start, since the
    // following happened:
    // 1. The position of the helper is absolute, so it's position is calculated based on the
    // next positioned parent
    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
    // the document, which means that the scroll is included in the initial calculation of the
    // offset of the parent, and never recalculated upon drag
    if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
        $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
      po.left += this.scrollParent.scrollLeft();
      po.top += this.scrollParent.scrollTop();
    }

    if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
      po = { top: 0, left: 0 };
    }

    return {
      top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
      left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
    };

  },

  _getRelativeOffset: function() {
    if ( this.cssPosition !== "relative" ) {
      return { top: 0, left: 0 };
    }

    var p = this.element.position(),
      scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

    return {
      top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
        ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
      left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
        ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
    };

  },

  _cacheMargins: function() {
    this.margins = {
      left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
      top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
      right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
      bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
    };
  },

  _cacheHelperProportions: function() {
    this.helperProportions = {
      width: this.helper.outerWidth(),
      height: this.helper.outerHeight()
    };
  },

  _setContainment: function() {

    var isUserScrollable, c, ce,
      o = this.options,
      document = this.document[ 0 ];

    this.relativeContainer = null;

    if ( !o.containment ) {
      this.containment = null;
      return;
    }

    if ( o.containment === "window" ) {
      this.containment = [
        $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
        $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
        $( window ).scrollLeft() + $( window ).width() -
          this.helperProportions.width - this.margins.left,
        $( window ).scrollTop() +
          ( $( window ).height() || document.body.parentNode.scrollHeight ) -
          this.helperProportions.height - this.margins.top
      ];
      return;
    }

    if ( o.containment === "document" ) {
      this.containment = [
        0,
        0,
        $( document ).width() - this.helperProportions.width - this.margins.left,
        ( $( document ).height() || document.body.parentNode.scrollHeight ) -
          this.helperProportions.height - this.margins.top
      ];
      return;
    }

    if ( o.containment.constructor === Array ) {
      this.containment = o.containment;
      return;
    }

    if ( o.containment === "parent" ) {
      o.containment = this.helper[ 0 ].parentNode;
    }

    c = $( o.containment );
    ce = c[ 0 ];

    if ( !ce ) {
      return;
    }

    isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

    this.containment = [
      ( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
        ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
      ( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
        ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
      ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
        ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
        ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
        this.helperProportions.width -
        this.margins.left -
        this.margins.right,
      ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
        ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
        ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
        this.helperProportions.height -
        this.margins.top -
        this.margins.bottom
    ];
    this.relativeContainer = c;
  },

  _convertPositionTo: function( d, pos ) {

    if ( !pos ) {
      pos = this.position;
    }

    var mod = d === "absolute" ? 1 : -1,
      scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

    return {
      top: (

        // The absolute mouse position
        pos.top +

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.top * mod +

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.top * mod -
        ( ( this.cssPosition === "fixed" ?
          -this.offset.scroll.top :
          ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
      ),
      left: (

        // The absolute mouse position
        pos.left +

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.left * mod +

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.left * mod -
        ( ( this.cssPosition === "fixed" ?
          -this.offset.scroll.left :
          ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
      )
    };

  },

  _generatePosition: function( event, constrainPosition ) {

    var containment, co, top, left,
      o = this.options,
      scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
      pageX = event.pageX,
      pageY = event.pageY;

    // Cache the scroll
    if ( !scrollIsRootNode || !this.offset.scroll ) {
      this.offset.scroll = {
        top: this.scrollParent.scrollTop(),
        left: this.scrollParent.scrollLeft()
      };
    }

    /*
     * - Position constraining -
     * Constrain the position to a mix of grid, containment.
     */

    // If we are not dragging yet, we won't check for options
    if ( constrainPosition ) {
      if ( this.containment ) {
        if ( this.relativeContainer ) {
          co = this.relativeContainer.offset();
          containment = [
            this.containment[ 0 ] + co.left,
            this.containment[ 1 ] + co.top,
            this.containment[ 2 ] + co.left,
            this.containment[ 3 ] + co.top
          ];
        } else {
          containment = this.containment;
        }

        if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
          pageX = containment[ 0 ] + this.offset.click.left;
        }
        if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
          pageY = containment[ 1 ] + this.offset.click.top;
        }
        if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
          pageX = containment[ 2 ] + this.offset.click.left;
        }
        if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
          pageY = containment[ 3 ] + this.offset.click.top;
        }
      }

      if ( o.grid ) {

        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid
        // argument errors in IE (see ticket #6950)
        top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
          this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
        pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
          top - this.offset.click.top > containment[ 3 ] ) ?
            top :
            ( ( top - this.offset.click.top >= containment[ 1 ] ) ?
              top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;

        left = o.grid[ 0 ] ? this.originalPageX +
          Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
          this.originalPageX;
        pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
          left - this.offset.click.left > containment[ 2 ] ) ?
            left :
            ( ( left - this.offset.click.left >= containment[ 0 ] ) ?
              left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
      }

      if ( o.axis === "y" ) {
        pageX = this.originalPageX;
      }

      if ( o.axis === "x" ) {
        pageY = this.originalPageY;
      }
    }

    return {
      top: (

        // The absolute mouse position
        pageY -

        // Click offset (relative to the element)
        this.offset.click.top -

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.top -

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.top +
        ( this.cssPosition === "fixed" ?
          -this.offset.scroll.top :
          ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
      ),
      left: (

        // The absolute mouse position
        pageX -

        // Click offset (relative to the element)
        this.offset.click.left -

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.left -

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.left +
        ( this.cssPosition === "fixed" ?
          -this.offset.scroll.left :
          ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
      )
    };

  },

  _clear: function() {
    this._removeClass( this.helper, "ui-draggable-dragging" );
    if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
      this.helper.remove();
    }
    this.helper = null;
    this.cancelHelperRemoval = false;
    if ( this.destroyOnClear ) {
      this.destroy();
    }
  },

  // From now on bulk stuff - mainly helpers

  _trigger: function( type, event, ui ) {
    ui = ui || this._uiHash();
    $.ui.plugin.call( this, type, [ event, ui, this ], true );

    // Absolute position and offset (see #6884 ) have to be recalculated after plugins
    if ( /^(drag|start|stop)/.test( type ) ) {
      this.positionAbs = this._convertPositionTo( "absolute" );
      ui.offset = this.positionAbs;
    }
    return $.Widget.prototype._trigger.call( this, type, event, ui );
  },

  plugins: {},

  _uiHash: function() {
    return {
      helper: this.helper,
      position: this.position,
      originalPosition: this.originalPosition,
      offset: this.positionAbs
    };
  }

} );

$.ui.plugin.add( "draggable", "connectToSortable", {
  start: function( event, ui, draggable ) {
    var uiSortable = $.extend( {}, ui, {
      item: draggable.element
    } );

    draggable.sortables = [];
    $( draggable.options.connectToSortable ).each( function() {
      var sortable = $( this ).sortable( "instance" );

      if ( sortable && !sortable.options.disabled ) {
        draggable.sortables.push( sortable );

        // RefreshPositions is called at drag start to refresh the containerCache
        // which is used in drag. This ensures it's initialized and synchronized
        // with any changes that might have happened on the page since initialization.
        sortable.refreshPositions();
        sortable._trigger( "activate", event, uiSortable );
      }
    } );
  },
  stop: function( event, ui, draggable ) {
    var uiSortable = $.extend( {}, ui, {
      item: draggable.element
    } );

    draggable.cancelHelperRemoval = false;

    $.each( draggable.sortables, function() {
      var sortable = this;

      if ( sortable.isOver ) {
        sortable.isOver = 0;

        // Allow this sortable to handle removing the helper
        draggable.cancelHelperRemoval = true;
        sortable.cancelHelperRemoval = false;

        // Use _storedCSS To restore properties in the sortable,
        // as this also handles revert (#9675) since the draggable
        // may have modified them in unexpected ways (#8809)
        sortable._storedCSS = {
          position: sortable.placeholder.css( "position" ),
          top: sortable.placeholder.css( "top" ),
          left: sortable.placeholder.css( "left" )
        };

        sortable._mouseStop( event );

        // Once drag has ended, the sortable should return to using
        // its original helper, not the shared helper from draggable
        sortable.options.helper = sortable.options._helper;
      } else {

        // Prevent this Sortable from removing the helper.
        // However, don't set the draggable to remove the helper
        // either as another connected Sortable may yet handle the removal.
        sortable.cancelHelperRemoval = true;

        sortable._trigger( "deactivate", event, uiSortable );
      }
    } );
  },
  drag: function( event, ui, draggable ) {
    $.each( draggable.sortables, function() {
      var innermostIntersecting = false,
        sortable = this;

      // Copy over variables that sortable's _intersectsWith uses
      sortable.positionAbs = draggable.positionAbs;
      sortable.helperProportions = draggable.helperProportions;
      sortable.offset.click = draggable.offset.click;

      if ( sortable._intersectsWith( sortable.containerCache ) ) {
        innermostIntersecting = true;

        $.each( draggable.sortables, function() {

          // Copy over variables that sortable's _intersectsWith uses
          this.positionAbs = draggable.positionAbs;
          this.helperProportions = draggable.helperProportions;
          this.offset.click = draggable.offset.click;

          if ( this !== sortable &&
              this._intersectsWith( this.containerCache ) &&
              $.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
            innermostIntersecting = false;
          }

          return innermostIntersecting;
        } );
      }

      if ( innermostIntersecting ) {

        // If it intersects, we use a little isOver variable and set it once,
        // so that the move-in stuff gets fired only once.
        if ( !sortable.isOver ) {
          sortable.isOver = 1;

          // Store draggable's parent in case we need to reappend to it later.
          draggable._parent = ui.helper.parent();

          sortable.currentItem = ui.helper
            .appendTo( sortable.element )
            .data( "ui-sortable-item", true );

          // Store helper option to later restore it
          sortable.options._helper = sortable.options.helper;

          sortable.options.helper = function() {
            return ui.helper[ 0 ];
          };

          // Fire the start events of the sortable with our passed browser event,
          // and our own helper (so it doesn't create a new one)
          event.target = sortable.currentItem[ 0 ];
          sortable._mouseCapture( event, true );
          sortable._mouseStart( event, true, true );

          // Because the browser event is way off the new appended portlet,
          // modify necessary variables to reflect the changes
          sortable.offset.click.top = draggable.offset.click.top;
          sortable.offset.click.left = draggable.offset.click.left;
          sortable.offset.parent.left -= draggable.offset.parent.left -
            sortable.offset.parent.left;
          sortable.offset.parent.top -= draggable.offset.parent.top -
            sortable.offset.parent.top;

          draggable._trigger( "toSortable", event );

          // Inform draggable that the helper is in a valid drop zone,
          // used solely in the revert option to handle "valid/invalid".
          draggable.dropped = sortable.element;

          // Need to refreshPositions of all sortables in the case that
          // adding to one sortable changes the location of the other sortables (#9675)
          $.each( draggable.sortables, function() {
            this.refreshPositions();
          } );

          // Hack so receive/update callbacks work (mostly)
          draggable.currentItem = draggable.element;
          sortable.fromOutside = draggable;
        }

        if ( sortable.currentItem ) {
          sortable._mouseDrag( event );

          // Copy the sortable's position because the draggable's can potentially reflect
          // a relative position, while sortable is always absolute, which the dragged
          // element has now become. (#8809)
          ui.position = sortable.position;
        }
      } else {

        // If it doesn't intersect with the sortable, and it intersected before,
        // we fake the drag stop of the sortable, but make sure it doesn't remove
        // the helper by using cancelHelperRemoval.
        if ( sortable.isOver ) {

          sortable.isOver = 0;
          sortable.cancelHelperRemoval = true;

          // Calling sortable's mouseStop would trigger a revert,
          // so revert must be temporarily false until after mouseStop is called.
          sortable.options._revert = sortable.options.revert;
          sortable.options.revert = false;

          sortable._trigger( "out", event, sortable._uiHash( sortable ) );
          sortable._mouseStop( event, true );

          // Restore sortable behaviors that were modfied
          // when the draggable entered the sortable area (#9481)
          sortable.options.revert = sortable.options._revert;
          sortable.options.helper = sortable.options._helper;

          if ( sortable.placeholder ) {
            sortable.placeholder.remove();
          }

          // Restore and recalculate the draggable's offset considering the sortable
          // may have modified them in unexpected ways. (#8809, #10669)
          ui.helper.appendTo( draggable._parent );
          draggable._refreshOffsets( event );
          ui.position = draggable._generatePosition( event, true );

          draggable._trigger( "fromSortable", event );

          // Inform draggable that the helper is no longer in a valid drop zone
          draggable.dropped = false;

          // Need to refreshPositions of all sortables just in case removing
          // from one sortable changes the location of other sortables (#9675)
          $.each( draggable.sortables, function() {
            this.refreshPositions();
          } );
        }
      }
    } );
  }
} );

$.ui.plugin.add( "draggable", "cursor", {
  start: function( event, ui, instance ) {
    var t = $( "body" ),
      o = instance.options;

    if ( t.css( "cursor" ) ) {
      o._cursor = t.css( "cursor" );
    }
    t.css( "cursor", o.cursor );
  },
  stop: function( event, ui, instance ) {
    var o = instance.options;
    if ( o._cursor ) {
      $( "body" ).css( "cursor", o._cursor );
    }
  }
} );

$.ui.plugin.add( "draggable", "opacity", {
  start: function( event, ui, instance ) {
    var t = $( ui.helper ),
      o = instance.options;
    if ( t.css( "opacity" ) ) {
      o._opacity = t.css( "opacity" );
    }
    t.css( "opacity", o.opacity );
  },
  stop: function( event, ui, instance ) {
    var o = instance.options;
    if ( o._opacity ) {
      $( ui.helper ).css( "opacity", o._opacity );
    }
  }
} );

$.ui.plugin.add( "draggable", "scroll", {
  start: function( event, ui, i ) {
    if ( !i.scrollParentNotHidden ) {
      i.scrollParentNotHidden = i.helper.scrollParent( false );
    }

    if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
        i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
      i.overflowOffset = i.scrollParentNotHidden.offset();
    }
  },
  drag: function( event, ui, i  ) {

    var o = i.options,
      scrolled = false,
      scrollParent = i.scrollParentNotHidden[ 0 ],
      document = i.document[ 0 ];

    if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
      if ( !o.axis || o.axis !== "x" ) {
        if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
            o.scrollSensitivity ) {
          scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
        } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
          scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
        }
      }

      if ( !o.axis || o.axis !== "y" ) {
        if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
            o.scrollSensitivity ) {
          scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
        } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
          scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
        }
      }

    } else {

      if ( !o.axis || o.axis !== "x" ) {
        if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
          scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
        } else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
            o.scrollSensitivity ) {
          scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
        }
      }

      if ( !o.axis || o.axis !== "y" ) {
        if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
          scrolled = $( document ).scrollLeft(
            $( document ).scrollLeft() - o.scrollSpeed
          );
        } else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
            o.scrollSensitivity ) {
          scrolled = $( document ).scrollLeft(
            $( document ).scrollLeft() + o.scrollSpeed
          );
        }
      }

    }

    if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
      $.ui.ddmanager.prepareOffsets( i, event );
    }

  }
} );

$.ui.plugin.add( "draggable", "snap", {
  start: function( event, ui, i ) {

    var o = i.options;

    i.snapElements = [];

    $( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
      .each( function() {
        var $t = $( this ),
          $o = $t.offset();
        if ( this !== i.element[ 0 ] ) {
          i.snapElements.push( {
            item: this,
            width: $t.outerWidth(), height: $t.outerHeight(),
            top: $o.top, left: $o.left
          } );
        }
      } );

  },
  drag: function( event, ui, inst ) {

    var ts, bs, ls, rs, l, r, t, b, i, first,
      o = inst.options,
      d = o.snapTolerance,
      x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
      y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

    for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {

      l = inst.snapElements[ i ].left - inst.margins.left;
      r = l + inst.snapElements[ i ].width;
      t = inst.snapElements[ i ].top - inst.margins.top;
      b = t + inst.snapElements[ i ].height;

      if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
          !$.contains( inst.snapElements[ i ].item.ownerDocument,
          inst.snapElements[ i ].item ) ) {
        if ( inst.snapElements[ i ].snapping ) {
          ( inst.options.snap.release &&
            inst.options.snap.release.call(
              inst.element,
              event,
              $.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
            ) );
        }
        inst.snapElements[ i ].snapping = false;
        continue;
      }

      if ( o.snapMode !== "inner" ) {
        ts = Math.abs( t - y2 ) <= d;
        bs = Math.abs( b - y1 ) <= d;
        ls = Math.abs( l - x2 ) <= d;
        rs = Math.abs( r - x1 ) <= d;
        if ( ts ) {
          ui.position.top = inst._convertPositionTo( "relative", {
            top: t - inst.helperProportions.height,
            left: 0
          } ).top;
        }
        if ( bs ) {
          ui.position.top = inst._convertPositionTo( "relative", {
            top: b,
            left: 0
          } ).top;
        }
        if ( ls ) {
          ui.position.left = inst._convertPositionTo( "relative", {
            top: 0,
            left: l - inst.helperProportions.width
          } ).left;
        }
        if ( rs ) {
          ui.position.left = inst._convertPositionTo( "relative", {
            top: 0,
            left: r
          } ).left;
        }
      }

      first = ( ts || bs || ls || rs );

      if ( o.snapMode !== "outer" ) {
        ts = Math.abs( t - y1 ) <= d;
        bs = Math.abs( b - y2 ) <= d;
        ls = Math.abs( l - x1 ) <= d;
        rs = Math.abs( r - x2 ) <= d;
        if ( ts ) {
          ui.position.top = inst._convertPositionTo( "relative", {
            top: t,
            left: 0
          } ).top;
        }
        if ( bs ) {
          ui.position.top = inst._convertPositionTo( "relative", {
            top: b - inst.helperProportions.height,
            left: 0
          } ).top;
        }
        if ( ls ) {
          ui.position.left = inst._convertPositionTo( "relative", {
            top: 0,
            left: l
          } ).left;
        }
        if ( rs ) {
          ui.position.left = inst._convertPositionTo( "relative", {
            top: 0,
            left: r - inst.helperProportions.width
          } ).left;
        }
      }

      if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
        ( inst.options.snap.snap &&
          inst.options.snap.snap.call(
            inst.element,
            event,
            $.extend( inst._uiHash(), {
              snapItem: inst.snapElements[ i ].item
            } ) ) );
      }
      inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );

    }

  }
} );

$.ui.plugin.add( "draggable", "stack", {
  start: function( event, ui, instance ) {
    var min,
      o = instance.options,
      group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
        return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
          ( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
      } );

    if ( !group.length ) { return; }

    min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
    $( group ).each( function( i ) {
      $( this ).css( "zIndex", min + i );
    } );
    this.css( "zIndex", ( min + group.length ) );
  }
} );

$.ui.plugin.add( "draggable", "zIndex", {
  start: function( event, ui, instance ) {
    var t = $( ui.helper ),
      o = instance.options;

    if ( t.css( "zIndex" ) ) {
      o._zIndex = t.css( "zIndex" );
    }
    t.css( "zIndex", o.zIndex );
  },
  stop: function( event, ui, instance ) {
    var o = instance.options;

    if ( o._zIndex ) {
      $( ui.helper ).css( "zIndex", o._zIndex );
    }
  }
} );

var widgetsDraggable = $.ui.draggable;


/*!
 * jQuery UI Resizable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Resizable
//>>group: Interactions
//>>description: Enables resize functionality for any element.
//>>docs: http://api.jqueryui.com/resizable/
//>>demos: http://jqueryui.com/resizable/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/resizable.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.resizable", $.ui.mouse, {
  version: "1.12.1",
  widgetEventPrefix: "resize",
  options: {
    alsoResize: false,
    animate: false,
    animateDuration: "slow",
    animateEasing: "swing",
    aspectRatio: false,
    autoHide: false,
    classes: {
      "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
    },
    containment: false,
    ghost: false,
    grid: false,
    handles: "e,s,se",
    helper: false,
    maxHeight: null,
    maxWidth: null,
    minHeight: 10,
    minWidth: 10,

    // See #7960
    zIndex: 90,

    // Callbacks
    resize: null,
    start: null,
    stop: null
  },

  _num: function( value ) {
    return parseFloat( value ) || 0;
  },

  _isNumber: function( value ) {
    return !isNaN( parseFloat( value ) );
  },

  _hasScroll: function( el, a ) {

    if ( $( el ).css( "overflow" ) === "hidden" ) {
      return false;
    }

    var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
      has = false;

    if ( el[ scroll ] > 0 ) {
      return true;
    }

    // TODO: determine which cases actually cause this to happen
    // if the element doesn't have the scroll set, see if it's possible to
    // set the scroll
    el[ scroll ] = 1;
    has = ( el[ scroll ] > 0 );
    el[ scroll ] = 0;
    return has;
  },

  _create: function() {

    var margins,
      o = this.options,
      that = this;
    this._addClass( "ui-resizable" );

    $.extend( this, {
      _aspectRatio: !!( o.aspectRatio ),
      aspectRatio: o.aspectRatio,
      originalElement: this.element,
      _proportionallyResizeElements: [],
      _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
    } );

    // Wrap the element if it cannot hold child nodes
    if ( this.element[ 0 ].nodeName.match( /^(canvas|textarea|input|select|button|img)$/i ) ) {

      this.element.wrap(
        $( "<div class='ui-wrapper' style='overflow: hidden;'></div>" ).css( {
          position: this.element.css( "position" ),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css( "top" ),
          left: this.element.css( "left" )
        } )
      );

      this.element = this.element.parent().data(
        "ui-resizable", this.element.resizable( "instance" )
      );

      this.elementIsWrapper = true;

      margins = {
        marginTop: this.originalElement.css( "marginTop" ),
        marginRight: this.originalElement.css( "marginRight" ),
        marginBottom: this.originalElement.css( "marginBottom" ),
        marginLeft: this.originalElement.css( "marginLeft" )
      };

      this.element.css( margins );
      this.originalElement.css( "margin", 0 );

      // support: Safari
      // Prevent Safari textarea resize
      this.originalResizeStyle = this.originalElement.css( "resize" );
      this.originalElement.css( "resize", "none" );

      this._proportionallyResizeElements.push( this.originalElement.css( {
        position: "static",
        zoom: 1,
        display: "block"
      } ) );

      // Support: IE9
      // avoid IE jump (hard set the margin)
      this.originalElement.css( margins );

      this._proportionallyResize();
    }

    this._setupHandles();

    if ( o.autoHide ) {
      $( this.element )
        .on( "mouseenter", function() {
          if ( o.disabled ) {
            return;
          }
          that._removeClass( "ui-resizable-autohide" );
          that._handles.show();
        } )
        .on( "mouseleave", function() {
          if ( o.disabled ) {
            return;
          }
          if ( !that.resizing ) {
            that._addClass( "ui-resizable-autohide" );
            that._handles.hide();
          }
        } );
    }

    this._mouseInit();
  },

  _destroy: function() {

    this._mouseDestroy();

    var wrapper,
      _destroy = function( exp ) {
        $( exp )
          .removeData( "resizable" )
          .removeData( "ui-resizable" )
          .off( ".resizable" )
          .find( ".ui-resizable-handle" )
            .remove();
      };

    // TODO: Unwrap at same DOM position
    if ( this.elementIsWrapper ) {
      _destroy( this.element );
      wrapper = this.element;
      this.originalElement.css( {
        position: wrapper.css( "position" ),
        width: wrapper.outerWidth(),
        height: wrapper.outerHeight(),
        top: wrapper.css( "top" ),
        left: wrapper.css( "left" )
      } ).insertAfter( wrapper );
      wrapper.remove();
    }

    this.originalElement.css( "resize", this.originalResizeStyle );
    _destroy( this.originalElement );

    return this;
  },

  _setOption: function( key, value ) {
    this._super( key, value );

    switch ( key ) {
    case "handles":
      this._removeHandles();
      this._setupHandles();
      break;
    default:
      break;
    }
  },

  _setupHandles: function() {
    var o = this.options, handle, i, n, hname, axis, that = this;
    this.handles = o.handles ||
      ( !$( ".ui-resizable-handle", this.element ).length ?
        "e,s,se" : {
          n: ".ui-resizable-n",
          e: ".ui-resizable-e",
          s: ".ui-resizable-s",
          w: ".ui-resizable-w",
          se: ".ui-resizable-se",
          sw: ".ui-resizable-sw",
          ne: ".ui-resizable-ne",
          nw: ".ui-resizable-nw"
        } );

    this._handles = $();
    if ( this.handles.constructor === String ) {

      if ( this.handles === "all" ) {
        this.handles = "n,e,s,w,se,sw,ne,nw";
      }

      n = this.handles.split( "," );
      this.handles = {};

      for ( i = 0; i < n.length; i++ ) {

        handle = $.trim( n[ i ] );
        hname = "ui-resizable-" + handle;
        axis = $( "<div>" );
        this._addClass( axis, "ui-resizable-handle " + hname );

        axis.css( { zIndex: o.zIndex } );

        this.handles[ handle ] = ".ui-resizable-" + handle;
        this.element.append( axis );
      }

    }

    this._renderAxis = function( target ) {

      var i, axis, padPos, padWrapper;

      target = target || this.element;

      for ( i in this.handles ) {

        if ( this.handles[ i ].constructor === String ) {
          this.handles[ i ] = this.element.children( this.handles[ i ] ).first().show();
        } else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
          this.handles[ i ] = $( this.handles[ i ] );
          this._on( this.handles[ i ], { "mousedown": that._mouseDown } );
        }

        if ( this.elementIsWrapper &&
            this.originalElement[ 0 ]
              .nodeName
              .match( /^(textarea|input|select|button)$/i ) ) {
          axis = $( this.handles[ i ], this.element );

          padWrapper = /sw|ne|nw|se|n|s/.test( i ) ?
            axis.outerHeight() :
            axis.outerWidth();

          padPos = [ "padding",
            /ne|nw|n/.test( i ) ? "Top" :
            /se|sw|s/.test( i ) ? "Bottom" :
            /^e$/.test( i ) ? "Right" : "Left" ].join( "" );

          target.css( padPos, padWrapper );

          this._proportionallyResize();
        }

        this._handles = this._handles.add( this.handles[ i ] );
      }
    };

    // TODO: make renderAxis a prototype function
    this._renderAxis( this.element );

    this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
    this._handles.disableSelection();

    this._handles.on( "mouseover", function() {
      if ( !that.resizing ) {
        if ( this.className ) {
          axis = this.className.match( /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i );
        }
        that.axis = axis && axis[ 1 ] ? axis[ 1 ] : "se";
      }
    } );

    if ( o.autoHide ) {
      this._handles.hide();
      this._addClass( "ui-resizable-autohide" );
    }
  },

  _removeHandles: function() {
    this._handles.remove();
  },

  _mouseCapture: function( event ) {
    var i, handle,
      capture = false;

    for ( i in this.handles ) {
      handle = $( this.handles[ i ] )[ 0 ];
      if ( handle === event.target || $.contains( handle, event.target ) ) {
        capture = true;
      }
    }

    return !this.options.disabled && capture;
  },

  _mouseStart: function( event ) {

    var curleft, curtop, cursor,
      o = this.options,
      el = this.element;

    this.resizing = true;

    this._renderProxy();

    curleft = this._num( this.helper.css( "left" ) );
    curtop = this._num( this.helper.css( "top" ) );

    if ( o.containment ) {
      curleft += $( o.containment ).scrollLeft() || 0;
      curtop += $( o.containment ).scrollTop() || 0;
    }

    this.offset = this.helper.offset();
    this.position = { left: curleft, top: curtop };

    this.size = this._helper ? {
        width: this.helper.width(),
        height: this.helper.height()
      } : {
        width: el.width(),
        height: el.height()
      };

    this.originalSize = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };

    this.sizeDiff = {
      width: el.outerWidth() - el.width(),
      height: el.outerHeight() - el.height()
    };

    this.originalPosition = { left: curleft, top: curtop };
    this.originalMousePosition = { left: event.pageX, top: event.pageY };

    this.aspectRatio = ( typeof o.aspectRatio === "number" ) ?
      o.aspectRatio :
      ( ( this.originalSize.width / this.originalSize.height ) || 1 );

    cursor = $( ".ui-resizable-" + this.axis ).css( "cursor" );
    $( "body" ).css( "cursor", cursor === "auto" ? this.axis + "-resize" : cursor );

    this._addClass( "ui-resizable-resizing" );
    this._propagate( "start", event );
    return true;
  },

  _mouseDrag: function( event ) {

    var data, props,
      smp = this.originalMousePosition,
      a = this.axis,
      dx = ( event.pageX - smp.left ) || 0,
      dy = ( event.pageY - smp.top ) || 0,
      trigger = this._change[ a ];

    this._updatePrevProperties();

    if ( !trigger ) {
      return false;
    }

    data = trigger.apply( this, [ event, dx, dy ] );

    this._updateVirtualBoundaries( event.shiftKey );
    if ( this._aspectRatio || event.shiftKey ) {
      data = this._updateRatio( data, event );
    }

    data = this._respectSize( data, event );

    this._updateCache( data );

    this._propagate( "resize", event );

    props = this._applyChanges();

    if ( !this._helper && this._proportionallyResizeElements.length ) {
      this._proportionallyResize();
    }

    if ( !$.isEmptyObject( props ) ) {
      this._updatePrevProperties();
      this._trigger( "resize", event, this.ui() );
      this._applyChanges();
    }

    return false;
  },

  _mouseStop: function( event ) {

    this.resizing = false;
    var pr, ista, soffseth, soffsetw, s, left, top,
      o = this.options, that = this;

    if ( this._helper ) {

      pr = this._proportionallyResizeElements;
      ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName );
      soffseth = ista && this._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height;
      soffsetw = ista ? 0 : that.sizeDiff.width;

      s = {
        width: ( that.helper.width()  - soffsetw ),
        height: ( that.helper.height() - soffseth )
      };
      left = ( parseFloat( that.element.css( "left" ) ) +
        ( that.position.left - that.originalPosition.left ) ) || null;
      top = ( parseFloat( that.element.css( "top" ) ) +
        ( that.position.top - that.originalPosition.top ) ) || null;

      if ( !o.animate ) {
        this.element.css( $.extend( s, { top: top, left: left } ) );
      }

      that.helper.height( that.size.height );
      that.helper.width( that.size.width );

      if ( this._helper && !o.animate ) {
        this._proportionallyResize();
      }
    }

    $( "body" ).css( "cursor", "auto" );

    this._removeClass( "ui-resizable-resizing" );

    this._propagate( "stop", event );

    if ( this._helper ) {
      this.helper.remove();
    }

    return false;

  },

  _updatePrevProperties: function() {
    this.prevPosition = {
      top: this.position.top,
      left: this.position.left
    };
    this.prevSize = {
      width: this.size.width,
      height: this.size.height
    };
  },

  _applyChanges: function() {
    var props = {};

    if ( this.position.top !== this.prevPosition.top ) {
      props.top = this.position.top + "px";
    }
    if ( this.position.left !== this.prevPosition.left ) {
      props.left = this.position.left + "px";
    }
    if ( this.size.width !== this.prevSize.width ) {
      props.width = this.size.width + "px";
    }
    if ( this.size.height !== this.prevSize.height ) {
      props.height = this.size.height + "px";
    }

    this.helper.css( props );

    return props;
  },

  _updateVirtualBoundaries: function( forceAspectRatio ) {
    var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
      o = this.options;

    b = {
      minWidth: this._isNumber( o.minWidth ) ? o.minWidth : 0,
      maxWidth: this._isNumber( o.maxWidth ) ? o.maxWidth : Infinity,
      minHeight: this._isNumber( o.minHeight ) ? o.minHeight : 0,
      maxHeight: this._isNumber( o.maxHeight ) ? o.maxHeight : Infinity
    };

    if ( this._aspectRatio || forceAspectRatio ) {
      pMinWidth = b.minHeight * this.aspectRatio;
      pMinHeight = b.minWidth / this.aspectRatio;
      pMaxWidth = b.maxHeight * this.aspectRatio;
      pMaxHeight = b.maxWidth / this.aspectRatio;

      if ( pMinWidth > b.minWidth ) {
        b.minWidth = pMinWidth;
      }
      if ( pMinHeight > b.minHeight ) {
        b.minHeight = pMinHeight;
      }
      if ( pMaxWidth < b.maxWidth ) {
        b.maxWidth = pMaxWidth;
      }
      if ( pMaxHeight < b.maxHeight ) {
        b.maxHeight = pMaxHeight;
      }
    }
    this._vBoundaries = b;
  },

  _updateCache: function( data ) {
    this.offset = this.helper.offset();
    if ( this._isNumber( data.left ) ) {
      this.position.left = data.left;
    }
    if ( this._isNumber( data.top ) ) {
      this.position.top = data.top;
    }
    if ( this._isNumber( data.height ) ) {
      this.size.height = data.height;
    }
    if ( this._isNumber( data.width ) ) {
      this.size.width = data.width;
    }
  },

  _updateRatio: function( data ) {

    var cpos = this.position,
      csize = this.size,
      a = this.axis;

    if ( this._isNumber( data.height ) ) {
      data.width = ( data.height * this.aspectRatio );
    } else if ( this._isNumber( data.width ) ) {
      data.height = ( data.width / this.aspectRatio );
    }

    if ( a === "sw" ) {
      data.left = cpos.left + ( csize.width - data.width );
      data.top = null;
    }
    if ( a === "nw" ) {
      data.top = cpos.top + ( csize.height - data.height );
      data.left = cpos.left + ( csize.width - data.width );
    }

    return data;
  },

  _respectSize: function( data ) {

    var o = this._vBoundaries,
      a = this.axis,
      ismaxw = this._isNumber( data.width ) && o.maxWidth && ( o.maxWidth < data.width ),
      ismaxh = this._isNumber( data.height ) && o.maxHeight && ( o.maxHeight < data.height ),
      isminw = this._isNumber( data.width ) && o.minWidth && ( o.minWidth > data.width ),
      isminh = this._isNumber( data.height ) && o.minHeight && ( o.minHeight > data.height ),
      dw = this.originalPosition.left + this.originalSize.width,
      dh = this.originalPosition.top + this.originalSize.height,
      cw = /sw|nw|w/.test( a ), ch = /nw|ne|n/.test( a );
    if ( isminw ) {
      data.width = o.minWidth;
    }
    if ( isminh ) {
      data.height = o.minHeight;
    }
    if ( ismaxw ) {
      data.width = o.maxWidth;
    }
    if ( ismaxh ) {
      data.height = o.maxHeight;
    }

    if ( isminw && cw ) {
      data.left = dw - o.minWidth;
    }
    if ( ismaxw && cw ) {
      data.left = dw - o.maxWidth;
    }
    if ( isminh && ch ) {
      data.top = dh - o.minHeight;
    }
    if ( ismaxh && ch ) {
      data.top = dh - o.maxHeight;
    }

    // Fixing jump error on top/left - bug #2330
    if ( !data.width && !data.height && !data.left && data.top ) {
      data.top = null;
    } else if ( !data.width && !data.height && !data.top && data.left ) {
      data.left = null;
    }

    return data;
  },

  _getPaddingPlusBorderDimensions: function( element ) {
    var i = 0,
      widths = [],
      borders = [
        element.css( "borderTopWidth" ),
        element.css( "borderRightWidth" ),
        element.css( "borderBottomWidth" ),
        element.css( "borderLeftWidth" )
      ],
      paddings = [
        element.css( "paddingTop" ),
        element.css( "paddingRight" ),
        element.css( "paddingBottom" ),
        element.css( "paddingLeft" )
      ];

    for ( ; i < 4; i++ ) {
      widths[ i ] = ( parseFloat( borders[ i ] ) || 0 );
      widths[ i ] += ( parseFloat( paddings[ i ] ) || 0 );
    }

    return {
      height: widths[ 0 ] + widths[ 2 ],
      width: widths[ 1 ] + widths[ 3 ]
    };
  },

  _proportionallyResize: function() {

    if ( !this._proportionallyResizeElements.length ) {
      return;
    }

    var prel,
      i = 0,
      element = this.helper || this.element;

    for ( ; i < this._proportionallyResizeElements.length; i++ ) {

      prel = this._proportionallyResizeElements[ i ];

      // TODO: Seems like a bug to cache this.outerDimensions
      // considering that we are in a loop.
      if ( !this.outerDimensions ) {
        this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
      }

      prel.css( {
        height: ( element.height() - this.outerDimensions.height ) || 0,
        width: ( element.width() - this.outerDimensions.width ) || 0
      } );

    }

  },

  _renderProxy: function() {

    var el = this.element, o = this.options;
    this.elementOffset = el.offset();

    if ( this._helper ) {

      this.helper = this.helper || $( "<div style='overflow:hidden;'></div>" );

      this._addClass( this.helper, this._helper );
      this.helper.css( {
        width: this.element.outerWidth(),
        height: this.element.outerHeight(),
        position: "absolute",
        left: this.elementOffset.left + "px",
        top: this.elementOffset.top + "px",
        zIndex: ++o.zIndex //TODO: Don't modify option
      } );

      this.helper
        .appendTo( "body" )
        .disableSelection();

    } else {
      this.helper = this.element;
    }

  },

  _change: {
    e: function( event, dx ) {
      return { width: this.originalSize.width + dx };
    },
    w: function( event, dx ) {
      var cs = this.originalSize, sp = this.originalPosition;
      return { left: sp.left + dx, width: cs.width - dx };
    },
    n: function( event, dx, dy ) {
      var cs = this.originalSize, sp = this.originalPosition;
      return { top: sp.top + dy, height: cs.height - dy };
    },
    s: function( event, dx, dy ) {
      return { height: this.originalSize.height + dy };
    },
    se: function( event, dx, dy ) {
      return $.extend( this._change.s.apply( this, arguments ),
        this._change.e.apply( this, [ event, dx, dy ] ) );
    },
    sw: function( event, dx, dy ) {
      return $.extend( this._change.s.apply( this, arguments ),
        this._change.w.apply( this, [ event, dx, dy ] ) );
    },
    ne: function( event, dx, dy ) {
      return $.extend( this._change.n.apply( this, arguments ),
        this._change.e.apply( this, [ event, dx, dy ] ) );
    },
    nw: function( event, dx, dy ) {
      return $.extend( this._change.n.apply( this, arguments ),
        this._change.w.apply( this, [ event, dx, dy ] ) );
    }
  },

  _propagate: function( n, event ) {
    $.ui.plugin.call( this, n, [ event, this.ui() ] );
    ( n !== "resize" && this._trigger( n, event, this.ui() ) );
  },

  plugins: {},

  ui: function() {
    return {
      originalElement: this.originalElement,
      element: this.element,
      helper: this.helper,
      position: this.position,
      size: this.size,
      originalSize: this.originalSize,
      originalPosition: this.originalPosition
    };
  }

} );

/*
 * Resizable Extensions
 */

$.ui.plugin.add( "resizable", "animate", {

  stop: function( event ) {
    var that = $( this ).resizable( "instance" ),
      o = that.options,
      pr = that._proportionallyResizeElements,
      ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName ),
      soffseth = ista && that._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height,
      soffsetw = ista ? 0 : that.sizeDiff.width,
      style = {
        width: ( that.size.width - soffsetw ),
        height: ( that.size.height - soffseth )
      },
      left = ( parseFloat( that.element.css( "left" ) ) +
        ( that.position.left - that.originalPosition.left ) ) || null,
      top = ( parseFloat( that.element.css( "top" ) ) +
        ( that.position.top - that.originalPosition.top ) ) || null;

    that.element.animate(
      $.extend( style, top && left ? { top: top, left: left } : {} ), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function() {

          var data = {
            width: parseFloat( that.element.css( "width" ) ),
            height: parseFloat( that.element.css( "height" ) ),
            top: parseFloat( that.element.css( "top" ) ),
            left: parseFloat( that.element.css( "left" ) )
          };

          if ( pr && pr.length ) {
            $( pr[ 0 ] ).css( { width: data.width, height: data.height } );
          }

          // Propagating resize, and updating values for each animation step
          that._updateCache( data );
          that._propagate( "resize", event );

        }
      }
    );
  }

} );

$.ui.plugin.add( "resizable", "containment", {

  start: function() {
    var element, p, co, ch, cw, width, height,
      that = $( this ).resizable( "instance" ),
      o = that.options,
      el = that.element,
      oc = o.containment,
      ce = ( oc instanceof $ ) ?
        oc.get( 0 ) :
        ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

    if ( !ce ) {
      return;
    }

    that.containerElement = $( ce );

    if ( /document/.test( oc ) || oc === document ) {
      that.containerOffset = {
        left: 0,
        top: 0
      };
      that.containerPosition = {
        left: 0,
        top: 0
      };

      that.parentData = {
        element: $( document ),
        left: 0,
        top: 0,
        width: $( document ).width(),
        height: $( document ).height() || document.body.parentNode.scrollHeight
      };
    } else {
      element = $( ce );
      p = [];
      $( [ "Top", "Right", "Left", "Bottom" ] ).each( function( i, name ) {
        p[ i ] = that._num( element.css( "padding" + name ) );
      } );

      that.containerOffset = element.offset();
      that.containerPosition = element.position();
      that.containerSize = {
        height: ( element.innerHeight() - p[ 3 ] ),
        width: ( element.innerWidth() - p[ 1 ] )
      };

      co = that.containerOffset;
      ch = that.containerSize.height;
      cw = that.containerSize.width;
      width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
      height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

      that.parentData = {
        element: ce,
        left: co.left,
        top: co.top,
        width: width,
        height: height
      };
    }
  },

  resize: function( event ) {
    var woset, hoset, isParent, isOffsetRelative,
      that = $( this ).resizable( "instance" ),
      o = that.options,
      co = that.containerOffset,
      cp = that.position,
      pRatio = that._aspectRatio || event.shiftKey,
      cop = {
        top: 0,
        left: 0
      },
      ce = that.containerElement,
      continueResize = true;

    if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
      cop = co;
    }

    if ( cp.left < ( that._helper ? co.left : 0 ) ) {
      that.size.width = that.size.width +
        ( that._helper ?
          ( that.position.left - co.left ) :
          ( that.position.left - cop.left ) );

      if ( pRatio ) {
        that.size.height = that.size.width / that.aspectRatio;
        continueResize = false;
      }
      that.position.left = o.helper ? co.left : 0;
    }

    if ( cp.top < ( that._helper ? co.top : 0 ) ) {
      that.size.height = that.size.height +
        ( that._helper ?
          ( that.position.top - co.top ) :
          that.position.top );

      if ( pRatio ) {
        that.size.width = that.size.height * that.aspectRatio;
        continueResize = false;
      }
      that.position.top = that._helper ? co.top : 0;
    }

    isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
    isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

    if ( isParent && isOffsetRelative ) {
      that.offset.left = that.parentData.left + that.position.left;
      that.offset.top = that.parentData.top + that.position.top;
    } else {
      that.offset.left = that.element.offset().left;
      that.offset.top = that.element.offset().top;
    }

    woset = Math.abs( that.sizeDiff.width +
      ( that._helper ?
        that.offset.left - cop.left :
        ( that.offset.left - co.left ) ) );

    hoset = Math.abs( that.sizeDiff.height +
      ( that._helper ?
        that.offset.top - cop.top :
        ( that.offset.top - co.top ) ) );

    if ( woset + that.size.width >= that.parentData.width ) {
      that.size.width = that.parentData.width - woset;
      if ( pRatio ) {
        that.size.height = that.size.width / that.aspectRatio;
        continueResize = false;
      }
    }

    if ( hoset + that.size.height >= that.parentData.height ) {
      that.size.height = that.parentData.height - hoset;
      if ( pRatio ) {
        that.size.width = that.size.height * that.aspectRatio;
        continueResize = false;
      }
    }

    if ( !continueResize ) {
      that.position.left = that.prevPosition.left;
      that.position.top = that.prevPosition.top;
      that.size.width = that.prevSize.width;
      that.size.height = that.prevSize.height;
    }
  },

  stop: function() {
    var that = $( this ).resizable( "instance" ),
      o = that.options,
      co = that.containerOffset,
      cop = that.containerPosition,
      ce = that.containerElement,
      helper = $( that.helper ),
      ho = helper.offset(),
      w = helper.outerWidth() - that.sizeDiff.width,
      h = helper.outerHeight() - that.sizeDiff.height;

    if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
      $( this ).css( {
        left: ho.left - cop.left - co.left,
        width: w,
        height: h
      } );
    }

    if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
      $( this ).css( {
        left: ho.left - cop.left - co.left,
        width: w,
        height: h
      } );
    }
  }
} );

$.ui.plugin.add( "resizable", "alsoResize", {

  start: function() {
    var that = $( this ).resizable( "instance" ),
      o = that.options;

    $( o.alsoResize ).each( function() {
      var el = $( this );
      el.data( "ui-resizable-alsoresize", {
        width: parseFloat( el.width() ), height: parseFloat( el.height() ),
        left: parseFloat( el.css( "left" ) ), top: parseFloat( el.css( "top" ) )
      } );
    } );
  },

  resize: function( event, ui ) {
    var that = $( this ).resizable( "instance" ),
      o = that.options,
      os = that.originalSize,
      op = that.originalPosition,
      delta = {
        height: ( that.size.height - os.height ) || 0,
        width: ( that.size.width - os.width ) || 0,
        top: ( that.position.top - op.top ) || 0,
        left: ( that.position.left - op.left ) || 0
      };

      $( o.alsoResize ).each( function() {
        var el = $( this ), start = $( this ).data( "ui-resizable-alsoresize" ), style = {},
          css = el.parents( ui.originalElement[ 0 ] ).length ?
              [ "width", "height" ] :
              [ "width", "height", "top", "left" ];

        $.each( css, function( i, prop ) {
          var sum = ( start[ prop ] || 0 ) + ( delta[ prop ] || 0 );
          if ( sum && sum >= 0 ) {
            style[ prop ] = sum || null;
          }
        } );

        el.css( style );
      } );
  },

  stop: function() {
    $( this ).removeData( "ui-resizable-alsoresize" );
  }
} );

$.ui.plugin.add( "resizable", "ghost", {

  start: function() {

    var that = $( this ).resizable( "instance" ), cs = that.size;

    that.ghost = that.originalElement.clone();
    that.ghost.css( {
      opacity: 0.25,
      display: "block",
      position: "relative",
      height: cs.height,
      width: cs.width,
      margin: 0,
      left: 0,
      top: 0
    } );

    that._addClass( that.ghost, "ui-resizable-ghost" );

    // DEPRECATED
    // TODO: remove after 1.12
    if ( $.uiBackCompat !== false && typeof that.options.ghost === "string" ) {

      // Ghost option
      that.ghost.addClass( this.options.ghost );
    }

    that.ghost.appendTo( that.helper );

  },

  resize: function() {
    var that = $( this ).resizable( "instance" );
    if ( that.ghost ) {
      that.ghost.css( {
        position: "relative",
        height: that.size.height,
        width: that.size.width
      } );
    }
  },

  stop: function() {
    var that = $( this ).resizable( "instance" );
    if ( that.ghost && that.helper ) {
      that.helper.get( 0 ).removeChild( that.ghost.get( 0 ) );
    }
  }

} );

$.ui.plugin.add( "resizable", "grid", {

  resize: function() {
    var outerDimensions,
      that = $( this ).resizable( "instance" ),
      o = that.options,
      cs = that.size,
      os = that.originalSize,
      op = that.originalPosition,
      a = that.axis,
      grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
      gridX = ( grid[ 0 ] || 1 ),
      gridY = ( grid[ 1 ] || 1 ),
      ox = Math.round( ( cs.width - os.width ) / gridX ) * gridX,
      oy = Math.round( ( cs.height - os.height ) / gridY ) * gridY,
      newWidth = os.width + ox,
      newHeight = os.height + oy,
      isMaxWidth = o.maxWidth && ( o.maxWidth < newWidth ),
      isMaxHeight = o.maxHeight && ( o.maxHeight < newHeight ),
      isMinWidth = o.minWidth && ( o.minWidth > newWidth ),
      isMinHeight = o.minHeight && ( o.minHeight > newHeight );

    o.grid = grid;

    if ( isMinWidth ) {
      newWidth += gridX;
    }
    if ( isMinHeight ) {
      newHeight += gridY;
    }
    if ( isMaxWidth ) {
      newWidth -= gridX;
    }
    if ( isMaxHeight ) {
      newHeight -= gridY;
    }

    if ( /^(se|s|e)$/.test( a ) ) {
      that.size.width = newWidth;
      that.size.height = newHeight;
    } else if ( /^(ne)$/.test( a ) ) {
      that.size.width = newWidth;
      that.size.height = newHeight;
      that.position.top = op.top - oy;
    } else if ( /^(sw)$/.test( a ) ) {
      that.size.width = newWidth;
      that.size.height = newHeight;
      that.position.left = op.left - ox;
    } else {
      if ( newHeight - gridY <= 0 || newWidth - gridX <= 0 ) {
        outerDimensions = that._getPaddingPlusBorderDimensions( this );
      }

      if ( newHeight - gridY > 0 ) {
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else {
        newHeight = gridY - outerDimensions.height;
        that.size.height = newHeight;
        that.position.top = op.top + os.height - newHeight;
      }
      if ( newWidth - gridX > 0 ) {
        that.size.width = newWidth;
        that.position.left = op.left - ox;
      } else {
        newWidth = gridX - outerDimensions.width;
        that.size.width = newWidth;
        that.position.left = op.left + os.width - newWidth;
      }
    }
  }

} );

var widgetsResizable = $.ui.resizable;


/*!
 * jQuery UI Dialog 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Dialog
//>>group: Widgets
//>>description: Displays customizable dialog windows.
//>>docs: http://api.jqueryui.com/dialog/
//>>demos: http://jqueryui.com/dialog/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/dialog.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.dialog", {
  version: "1.12.1",
  options: {
    appendTo: "body",
    autoOpen: true,
    buttons: [],
    classes: {
      "ui-dialog": "ui-corner-all",
      "ui-dialog-titlebar": "ui-corner-all"
    },
    closeOnEscape: true,
    closeText: "Close",
    draggable: true,
    hide: null,
    height: "auto",
    maxHeight: null,
    maxWidth: null,
    minHeight: 150,
    minWidth: 150,
    modal: false,
    position: {
      my: "center",
      at: "center",
      of: window,
      collision: "fit",

      // Ensure the titlebar is always visible
      using: function( pos ) {
        var topOffset = $( this ).css( pos ).offset().top;
        if ( topOffset < 0 ) {
          $( this ).css( "top", pos.top - topOffset );
        }
      }
    },
    resizable: true,
    show: null,
    title: null,
    width: 300,

    // Callbacks
    beforeClose: null,
    close: null,
    drag: null,
    dragStart: null,
    dragStop: null,
    focus: null,
    open: null,
    resize: null,
    resizeStart: null,
    resizeStop: null
  },

  sizeRelatedOptions: {
    buttons: true,
    height: true,
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true,
    width: true
  },

  resizableRelatedOptions: {
    maxHeight: true,
    maxWidth: true,
    minHeight: true,
    minWidth: true
  },

  _create: function() {
    this.originalCss = {
      display: this.element[ 0 ].style.display,
      width: this.element[ 0 ].style.width,
      minHeight: this.element[ 0 ].style.minHeight,
      maxHeight: this.element[ 0 ].style.maxHeight,
      height: this.element[ 0 ].style.height
    };
    this.originalPosition = {
      parent: this.element.parent(),
      index: this.element.parent().children().index( this.element )
    };
    this.originalTitle = this.element.attr( "title" );
    if ( this.options.title == null && this.originalTitle != null ) {
      this.options.title = this.originalTitle;
    }

    // Dialogs can't be disabled
    if ( this.options.disabled ) {
      this.options.disabled = false;
    }

    this._createWrapper();

    this.element
      .show()
      .removeAttr( "title" )
      .appendTo( this.uiDialog );

    this._addClass( "ui-dialog-content", "ui-widget-content" );

    this._createTitlebar();
    this._createButtonPane();

    if ( this.options.draggable && $.fn.draggable ) {
      this._makeDraggable();
    }
    if ( this.options.resizable && $.fn.resizable ) {
      this._makeResizable();
    }

    this._isOpen = false;

    this._trackFocus();
  },

  _init: function() {
    if ( this.options.autoOpen ) {
      this.open();
    }
  },

  _appendTo: function() {
    var element = this.options.appendTo;
    if ( element && ( element.jquery || element.nodeType ) ) {
      return $( element );
    }
    return this.document.find( element || "body" ).eq( 0 );
  },

  _destroy: function() {
    var next,
      originalPosition = this.originalPosition;

    this._untrackInstance();
    this._destroyOverlay();

    this.element
      .removeUniqueId()
      .css( this.originalCss )

      // Without detaching first, the following becomes really slow
      .detach();

    this.uiDialog.remove();

    if ( this.originalTitle ) {
      this.element.attr( "title", this.originalTitle );
    }

    next = originalPosition.parent.children().eq( originalPosition.index );

    // Don't try to place the dialog next to itself (#8613)
    if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
      next.before( this.element );
    } else {
      originalPosition.parent.append( this.element );
    }
  },

  widget: function() {
    return this.uiDialog;
  },

  disable: $.noop,
  enable: $.noop,

  close: function( event ) {
    var that = this;

    if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
      return;
    }

    this._isOpen = false;
    this._focusedElement = null;
    this._destroyOverlay();
    this._untrackInstance();

    if ( !this.opener.filter( ":focusable" ).trigger( "focus" ).length ) {

      // Hiding a focused element doesn't trigger blur in WebKit
      // so in case we have nothing to focus on, explicitly blur the active element
      // https://bugs.webkit.org/show_bug.cgi?id=47182
      $.ui.safeBlur( $.ui.safeActiveElement( this.document[ 0 ] ) );
    }

    this._hide( this.uiDialog, this.options.hide, function() {
      that._trigger( "close", event );
    } );
  },

  isOpen: function() {
    return this._isOpen;
  },

  moveToTop: function() {
    this._moveToTop();
  },

  _moveToTop: function( event, silent ) {
    var moved = false,
      zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map( function() {
        return +$( this ).css( "z-index" );
      } ).get(),
      zIndexMax = Math.max.apply( null, zIndices );

    if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
      this.uiDialog.css( "z-index", zIndexMax + 1 );
      moved = true;
    }

    if ( moved && !silent ) {
      this._trigger( "focus", event );
    }
    return moved;
  },

  open: function() {
    var that = this;
    if ( this._isOpen ) {
      if ( this._moveToTop() ) {
        this._focusTabbable();
      }
      return;
    }

    this._isOpen = true;
    this.opener = $( $.ui.safeActiveElement( this.document[ 0 ] ) );

    this._size();
    this._position();
    this._createOverlay();
    this._moveToTop( null, true );

    // Ensure the overlay is moved to the top with the dialog, but only when
    // opening. The overlay shouldn't move after the dialog is open so that
    // modeless dialogs opened after the modal dialog stack properly.
    if ( this.overlay ) {
      this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
    }

    this._show( this.uiDialog, this.options.show, function() {
      that._focusTabbable();
      that._trigger( "focus" );
    } );

    // Track the dialog immediately upon openening in case a focus event
    // somehow occurs outside of the dialog before an element inside the
    // dialog is focused (#10152)
    this._makeFocusTarget();

    this._trigger( "open" );
  },

  _focusTabbable: function() {

    // Set focus to the first match:
    // 1. An element that was focused previously
    // 2. First element inside the dialog matching [autofocus]
    // 3. Tabbable element inside the content element
    // 4. Tabbable element inside the buttonpane
    // 5. The close button
    // 6. The dialog itself
    var hasFocus = this._focusedElement;
    if ( !hasFocus ) {
      hasFocus = this.element.find( "[autofocus]" );
    }
    if ( !hasFocus.length ) {
      hasFocus = this.element.find( ":tabbable" );
    }
    if ( !hasFocus.length ) {
      hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
    }
    if ( !hasFocus.length ) {
      hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
    }
    if ( !hasFocus.length ) {
      hasFocus = this.uiDialog;
    }
    hasFocus.eq( 0 ).trigger( "focus" );
  },

  _keepFocus: function( event ) {
    function checkFocus() {
      var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
        isActive = this.uiDialog[ 0 ] === activeElement ||
          $.contains( this.uiDialog[ 0 ], activeElement );
      if ( !isActive ) {
        this._focusTabbable();
      }
    }
    event.preventDefault();
    checkFocus.call( this );

    // support: IE
    // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
    // so we check again later
    this._delay( checkFocus );
  },

  _createWrapper: function() {
    this.uiDialog = $( "<div>" )
      .hide()
      .attr( {

        // Setting tabIndex makes the div focusable
        tabIndex: -1,
        role: "dialog"
      } )
      .appendTo( this._appendTo() );

    this._addClass( this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front" );
    this._on( this.uiDialog, {
      keydown: function( event ) {
        if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
            event.keyCode === $.ui.keyCode.ESCAPE ) {
          event.preventDefault();
          this.close( event );
          return;
        }

        // Prevent tabbing out of dialogs
        if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
          return;
        }
        var tabbables = this.uiDialog.find( ":tabbable" ),
          first = tabbables.filter( ":first" ),
          last = tabbables.filter( ":last" );

        if ( ( event.target === last[ 0 ] || event.target === this.uiDialog[ 0 ] ) &&
            !event.shiftKey ) {
          this._delay( function() {
            first.trigger( "focus" );
          } );
          event.preventDefault();
        } else if ( ( event.target === first[ 0 ] ||
            event.target === this.uiDialog[ 0 ] ) && event.shiftKey ) {
          this._delay( function() {
            last.trigger( "focus" );
          } );
          event.preventDefault();
        }
      },
      mousedown: function( event ) {
        if ( this._moveToTop( event ) ) {
          this._focusTabbable();
        }
      }
    } );

    // We assume that any existing aria-describedby attribute means
    // that the dialog content is marked up properly
    // otherwise we brute force the content as the description
    if ( !this.element.find( "[aria-describedby]" ).length ) {
      this.uiDialog.attr( {
        "aria-describedby": this.element.uniqueId().attr( "id" )
      } );
    }
  },

  _createTitlebar: function() {
    var uiDialogTitle;

    this.uiDialogTitlebar = $( "<div>" );
    this._addClass( this.uiDialogTitlebar,
      "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix" );
    this._on( this.uiDialogTitlebar, {
      mousedown: function( event ) {

        // Don't prevent click on close button (#8838)
        // Focusing a dialog that is partially scrolled out of view
        // causes the browser to scroll it into view, preventing the click event
        if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {

          // Dialog isn't getting focus when dragging (#8063)
          this.uiDialog.trigger( "focus" );
        }
      }
    } );

    // Support: IE
    // Use type="button" to prevent enter keypresses in textboxes from closing the
    // dialog in IE (#9312)
    this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
      .button( {
        label: $( "<a>" ).text( this.options.closeText ).html(),
        icon: "ui-icon-closethick",
        showLabel: false
      } )
      .appendTo( this.uiDialogTitlebar );

    this._addClass( this.uiDialogTitlebarClose, "ui-dialog-titlebar-close" );
    this._on( this.uiDialogTitlebarClose, {
      click: function( event ) {
        event.preventDefault();
        this.close( event );
      }
    } );

    uiDialogTitle = $( "<span>" ).uniqueId().prependTo( this.uiDialogTitlebar );
    this._addClass( uiDialogTitle, "ui-dialog-title" );
    this._title( uiDialogTitle );

    this.uiDialogTitlebar.prependTo( this.uiDialog );

    this.uiDialog.attr( {
      "aria-labelledby": uiDialogTitle.attr( "id" )
    } );
  },

  _title: function( title ) {
    if ( this.options.title ) {
      title.text( this.options.title );
    } else {
      title.html( "&#160;" );
    }
  },

  _createButtonPane: function() {
    this.uiDialogButtonPane = $( "<div>" );
    this._addClass( this.uiDialogButtonPane, "ui-dialog-buttonpane",
      "ui-widget-content ui-helper-clearfix" );

    this.uiButtonSet = $( "<div>" )
      .appendTo( this.uiDialogButtonPane );
    this._addClass( this.uiButtonSet, "ui-dialog-buttonset" );

    this._createButtons();
  },

  _createButtons: function() {
    var that = this,
      buttons = this.options.buttons;

    // If we already have a button pane, remove it
    this.uiDialogButtonPane.remove();
    this.uiButtonSet.empty();

    if ( $.isEmptyObject( buttons ) || ( $.isArray( buttons ) && !buttons.length ) ) {
      this._removeClass( this.uiDialog, "ui-dialog-buttons" );
      return;
    }

    $.each( buttons, function( name, props ) {
      var click, buttonOptions;
      props = $.isFunction( props ) ?
        { click: props, text: name } :
        props;

      // Default to a non-submitting button
      props = $.extend( { type: "button" }, props );

      // Change the context for the click callback to be the main element
      click = props.click;
      buttonOptions = {
        icon: props.icon,
        iconPosition: props.iconPosition,
        showLabel: props.showLabel,

        // Deprecated options
        icons: props.icons,
        text: props.text
      };

      delete props.click;
      delete props.icon;
      delete props.iconPosition;
      delete props.showLabel;

      // Deprecated options
      delete props.icons;
      if ( typeof props.text === "boolean" ) {
        delete props.text;
      }

      $( "<button></button>", props )
        .button( buttonOptions )
        .appendTo( that.uiButtonSet )
        .on( "click", function() {
          click.apply( that.element[ 0 ], arguments );
        } );
    } );
    this._addClass( this.uiDialog, "ui-dialog-buttons" );
    this.uiDialogButtonPane.appendTo( this.uiDialog );
  },

  _makeDraggable: function() {
    var that = this,
      options = this.options;

    function filteredUi( ui ) {
      return {
        position: ui.position,
        offset: ui.offset
      };
    }

    this.uiDialog.draggable( {
      cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
      handle: ".ui-dialog-titlebar",
      containment: "document",
      start: function( event, ui ) {
        that._addClass( $( this ), "ui-dialog-dragging" );
        that._blockFrames();
        that._trigger( "dragStart", event, filteredUi( ui ) );
      },
      drag: function( event, ui ) {
        that._trigger( "drag", event, filteredUi( ui ) );
      },
      stop: function( event, ui ) {
        var left = ui.offset.left - that.document.scrollLeft(),
          top = ui.offset.top - that.document.scrollTop();

        options.position = {
          my: "left top",
          at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
            "top" + ( top >= 0 ? "+" : "" ) + top,
          of: that.window
        };
        that._removeClass( $( this ), "ui-dialog-dragging" );
        that._unblockFrames();
        that._trigger( "dragStop", event, filteredUi( ui ) );
      }
    } );
  },

  _makeResizable: function() {
    var that = this,
      options = this.options,
      handles = options.resizable,

      // .ui-resizable has position: relative defined in the stylesheet
      // but dialogs have to use absolute or fixed positioning
      position = this.uiDialog.css( "position" ),
      resizeHandles = typeof handles === "string" ?
        handles :
        "n,e,s,w,se,sw,ne,nw";

    function filteredUi( ui ) {
      return {
        originalPosition: ui.originalPosition,
        originalSize: ui.originalSize,
        position: ui.position,
        size: ui.size
      };
    }

    this.uiDialog.resizable( {
      cancel: ".ui-dialog-content",
      containment: "document",
      alsoResize: this.element,
      maxWidth: options.maxWidth,
      maxHeight: options.maxHeight,
      minWidth: options.minWidth,
      minHeight: this._minHeight(),
      handles: resizeHandles,
      start: function( event, ui ) {
        that._addClass( $( this ), "ui-dialog-resizing" );
        that._blockFrames();
        that._trigger( "resizeStart", event, filteredUi( ui ) );
      },
      resize: function( event, ui ) {
        that._trigger( "resize", event, filteredUi( ui ) );
      },
      stop: function( event, ui ) {
        var offset = that.uiDialog.offset(),
          left = offset.left - that.document.scrollLeft(),
          top = offset.top - that.document.scrollTop();

        options.height = that.uiDialog.height();
        options.width = that.uiDialog.width();
        options.position = {
          my: "left top",
          at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
            "top" + ( top >= 0 ? "+" : "" ) + top,
          of: that.window
        };
        that._removeClass( $( this ), "ui-dialog-resizing" );
        that._unblockFrames();
        that._trigger( "resizeStop", event, filteredUi( ui ) );
      }
    } )
      .css( "position", position );
  },

  _trackFocus: function() {
    this._on( this.widget(), {
      focusin: function( event ) {
        this._makeFocusTarget();
        this._focusedElement = $( event.target );
      }
    } );
  },

  _makeFocusTarget: function() {
    this._untrackInstance();
    this._trackingInstances().unshift( this );
  },

  _untrackInstance: function() {
    var instances = this._trackingInstances(),
      exists = $.inArray( this, instances );
    if ( exists !== -1 ) {
      instances.splice( exists, 1 );
    }
  },

  _trackingInstances: function() {
    var instances = this.document.data( "ui-dialog-instances" );
    if ( !instances ) {
      instances = [];
      this.document.data( "ui-dialog-instances", instances );
    }
    return instances;
  },

  _minHeight: function() {
    var options = this.options;

    return options.height === "auto" ?
      options.minHeight :
      Math.min( options.minHeight, options.height );
  },

  _position: function() {

    // Need to show the dialog to get the actual offset in the position plugin
    var isVisible = this.uiDialog.is( ":visible" );
    if ( !isVisible ) {
      this.uiDialog.show();
    }
    this.uiDialog.position( this.options.position );
    if ( !isVisible ) {
      this.uiDialog.hide();
    }
  },

  _setOptions: function( options ) {
    var that = this,
      resize = false,
      resizableOptions = {};

    $.each( options, function( key, value ) {
      that._setOption( key, value );

      if ( key in that.sizeRelatedOptions ) {
        resize = true;
      }
      if ( key in that.resizableRelatedOptions ) {
        resizableOptions[ key ] = value;
      }
    } );

    if ( resize ) {
      this._size();
      this._position();
    }
    if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
      this.uiDialog.resizable( "option", resizableOptions );
    }
  },

  _setOption: function( key, value ) {
    var isDraggable, isResizable,
      uiDialog = this.uiDialog;

    if ( key === "disabled" ) {
      return;
    }

    this._super( key, value );

    if ( key === "appendTo" ) {
      this.uiDialog.appendTo( this._appendTo() );
    }

    if ( key === "buttons" ) {
      this._createButtons();
    }

    if ( key === "closeText" ) {
      this.uiDialogTitlebarClose.button( {

        // Ensure that we always pass a string
        label: $( "<a>" ).text( "" + this.options.closeText ).html()
      } );
    }

    if ( key === "draggable" ) {
      isDraggable = uiDialog.is( ":data(ui-draggable)" );
      if ( isDraggable && !value ) {
        uiDialog.draggable( "destroy" );
      }

      if ( !isDraggable && value ) {
        this._makeDraggable();
      }
    }

    if ( key === "position" ) {
      this._position();
    }

    if ( key === "resizable" ) {

      // currently resizable, becoming non-resizable
      isResizable = uiDialog.is( ":data(ui-resizable)" );
      if ( isResizable && !value ) {
        uiDialog.resizable( "destroy" );
      }

      // Currently resizable, changing handles
      if ( isResizable && typeof value === "string" ) {
        uiDialog.resizable( "option", "handles", value );
      }

      // Currently non-resizable, becoming resizable
      if ( !isResizable && value !== false ) {
        this._makeResizable();
      }
    }

    if ( key === "title" ) {
      this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
    }
  },

  _size: function() {

    // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
    // divs will both have width and height set, so we need to reset them
    var nonContentHeight, minContentHeight, maxContentHeight,
      options = this.options;

    // Reset content sizing
    this.element.show().css( {
      width: "auto",
      minHeight: 0,
      maxHeight: "none",
      height: 0
    } );

    if ( options.minWidth > options.width ) {
      options.width = options.minWidth;
    }

    // Reset wrapper sizing
    // determine the height of all the non-content elements
    nonContentHeight = this.uiDialog.css( {
      height: "auto",
      width: options.width
    } )
      .outerHeight();
    minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
    maxContentHeight = typeof options.maxHeight === "number" ?
      Math.max( 0, options.maxHeight - nonContentHeight ) :
      "none";

    if ( options.height === "auto" ) {
      this.element.css( {
        minHeight: minContentHeight,
        maxHeight: maxContentHeight,
        height: "auto"
      } );
    } else {
      this.element.height( Math.max( 0, options.height - nonContentHeight ) );
    }

    if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
      this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
    }
  },

  _blockFrames: function() {
    this.iframeBlocks = this.document.find( "iframe" ).map( function() {
      var iframe = $( this );

      return $( "<div>" )
        .css( {
          position: "absolute",
          width: iframe.outerWidth(),
          height: iframe.outerHeight()
        } )
        .appendTo( iframe.parent() )
        .offset( iframe.offset() )[ 0 ];
    } );
  },

  _unblockFrames: function() {
    if ( this.iframeBlocks ) {
      this.iframeBlocks.remove();
      delete this.iframeBlocks;
    }
  },

  _allowInteraction: function( event ) {
    if ( $( event.target ).closest( ".ui-dialog" ).length ) {
      return true;
    }

    // TODO: Remove hack when datepicker implements
    // the .ui-front logic (#8989)
    return !!$( event.target ).closest( ".ui-datepicker" ).length;
  },

  _createOverlay: function() {
    if ( !this.options.modal ) {
      return;
    }

    // We use a delay in case the overlay is created from an
    // event that we're going to be cancelling (#2804)
    var isOpening = true;
    this._delay( function() {
      isOpening = false;
    } );

    if ( !this.document.data( "ui-dialog-overlays" ) ) {

      // Prevent use of anchors and inputs
      // Using _on() for an event handler shared across many instances is
      // safe because the dialogs stack and must be closed in reverse order
      this._on( this.document, {
        focusin: function( event ) {
          if ( isOpening ) {
            return;
          }

          if ( !this._allowInteraction( event ) ) {
            event.preventDefault();
            this._trackingInstances()[ 0 ]._focusTabbable();
          }
        }
      } );
    }

    this.overlay = $( "<div>" )
      .appendTo( this._appendTo() );

    this._addClass( this.overlay, null, "ui-widget-overlay ui-front" );
    this._on( this.overlay, {
      mousedown: "_keepFocus"
    } );
    this.document.data( "ui-dialog-overlays",
      ( this.document.data( "ui-dialog-overlays" ) || 0 ) + 1 );
  },

  _destroyOverlay: function() {
    if ( !this.options.modal ) {
      return;
    }

    if ( this.overlay ) {
      var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

      if ( !overlays ) {
        this._off( this.document, "focusin" );
        this.document.removeData( "ui-dialog-overlays" );
      } else {
        this.document.data( "ui-dialog-overlays", overlays );
      }

      this.overlay.remove();
      this.overlay = null;
    }
  }
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

  // Backcompat for dialogClass option
  $.widget( "ui.dialog", $.ui.dialog, {
    options: {
      dialogClass: ""
    },
    _createWrapper: function() {
      this._super();
      this.uiDialog.addClass( this.options.dialogClass );
    },
    _setOption: function( key, value ) {
      if ( key === "dialogClass" ) {
        this.uiDialog
          .removeClass( this.options.dialogClass )
          .addClass( value );
      }
      this._superApply( arguments );
    }
  } );
}

var widgetsDialog = $.ui.dialog;


/*!
 * jQuery UI Droppable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Droppable
//>>group: Interactions
//>>description: Enables drop targets for draggable elements.
//>>docs: http://api.jqueryui.com/droppable/
//>>demos: http://jqueryui.com/droppable/



$.widget( "ui.droppable", {
  version: "1.12.1",
  widgetEventPrefix: "drop",
  options: {
    accept: "*",
    addClasses: true,
    greedy: false,
    scope: "default",
    tolerance: "intersect",

    // Callbacks
    activate: null,
    deactivate: null,
    drop: null,
    out: null,
    over: null
  },
  _create: function() {

    var proportions,
      o = this.options,
      accept = o.accept;

    this.isover = false;
    this.isout = true;

    this.accept = $.isFunction( accept ) ? accept : function( d ) {
      return d.is( accept );
    };

    this.proportions = function( /* valueToWrite */ ) {
      if ( arguments.length ) {

        // Store the droppable's proportions
        proportions = arguments[ 0 ];
      } else {

        // Retrieve or derive the droppable's proportions
        return proportions ?
          proportions :
          proportions = {
            width: this.element[ 0 ].offsetWidth,
            height: this.element[ 0 ].offsetHeight
          };
      }
    };

    this._addToManager( o.scope );

    o.addClasses && this._addClass( "ui-droppable" );

  },

  _addToManager: function( scope ) {

    // Add the reference and positions to the manager
    $.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
    $.ui.ddmanager.droppables[ scope ].push( this );
  },

  _splice: function( drop ) {
    var i = 0;
    for ( ; i < drop.length; i++ ) {
      if ( drop[ i ] === this ) {
        drop.splice( i, 1 );
      }
    }
  },

  _destroy: function() {
    var drop = $.ui.ddmanager.droppables[ this.options.scope ];

    this._splice( drop );
  },

  _setOption: function( key, value ) {

    if ( key === "accept" ) {
      this.accept = $.isFunction( value ) ? value : function( d ) {
        return d.is( value );
      };
    } else if ( key === "scope" ) {
      var drop = $.ui.ddmanager.droppables[ this.options.scope ];

      this._splice( drop );
      this._addToManager( value );
    }

    this._super( key, value );
  },

  _activate: function( event ) {
    var draggable = $.ui.ddmanager.current;

    this._addActiveClass();
    if ( draggable ) {
      this._trigger( "activate", event, this.ui( draggable ) );
    }
  },

  _deactivate: function( event ) {
    var draggable = $.ui.ddmanager.current;

    this._removeActiveClass();
    if ( draggable ) {
      this._trigger( "deactivate", event, this.ui( draggable ) );
    }
  },

  _over: function( event ) {

    var draggable = $.ui.ddmanager.current;

    // Bail if draggable and droppable are same element
    if ( !draggable || ( draggable.currentItem ||
        draggable.element )[ 0 ] === this.element[ 0 ] ) {
      return;
    }

    if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
        draggable.element ) ) ) {
      this._addHoverClass();
      this._trigger( "over", event, this.ui( draggable ) );
    }

  },

  _out: function( event ) {

    var draggable = $.ui.ddmanager.current;

    // Bail if draggable and droppable are same element
    if ( !draggable || ( draggable.currentItem ||
        draggable.element )[ 0 ] === this.element[ 0 ] ) {
      return;
    }

    if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
        draggable.element ) ) ) {
      this._removeHoverClass();
      this._trigger( "out", event, this.ui( draggable ) );
    }

  },

  _drop: function( event, custom ) {

    var draggable = custom || $.ui.ddmanager.current,
      childrenIntersection = false;

    // Bail if draggable and droppable are same element
    if ( !draggable || ( draggable.currentItem ||
        draggable.element )[ 0 ] === this.element[ 0 ] ) {
      return false;
    }

    this.element
      .find( ":data(ui-droppable)" )
      .not( ".ui-draggable-dragging" )
      .each( function() {
        var inst = $( this ).droppable( "instance" );
        if (
          inst.options.greedy &&
          !inst.options.disabled &&
          inst.options.scope === draggable.options.scope &&
          inst.accept.call(
            inst.element[ 0 ], ( draggable.currentItem || draggable.element )
          ) &&
          intersect(
            draggable,
            $.extend( inst, { offset: inst.element.offset() } ),
            inst.options.tolerance, event
          )
        ) {
          childrenIntersection = true;
          return false; }
      } );
    if ( childrenIntersection ) {
      return false;
    }

    if ( this.accept.call( this.element[ 0 ],
        ( draggable.currentItem || draggable.element ) ) ) {
      this._removeActiveClass();
      this._removeHoverClass();

      this._trigger( "drop", event, this.ui( draggable ) );
      return this.element;
    }

    return false;

  },

  ui: function( c ) {
    return {
      draggable: ( c.currentItem || c.element ),
      helper: c.helper,
      position: c.position,
      offset: c.positionAbs
    };
  },

  // Extension points just to make backcompat sane and avoid duplicating logic
  // TODO: Remove in 1.13 along with call to it below
  _addHoverClass: function() {
    this._addClass( "ui-droppable-hover" );
  },

  _removeHoverClass: function() {
    this._removeClass( "ui-droppable-hover" );
  },

  _addActiveClass: function() {
    this._addClass( "ui-droppable-active" );
  },

  _removeActiveClass: function() {
    this._removeClass( "ui-droppable-active" );
  }
} );

var intersect = $.ui.intersect = ( function() {
  function isOverAxis( x, reference, size ) {
    return ( x >= reference ) && ( x < ( reference + size ) );
  }

  return function( draggable, droppable, toleranceMode, event ) {

    if ( !droppable.offset ) {
      return false;
    }

    var x1 = ( draggable.positionAbs ||
        draggable.position.absolute ).left + draggable.margins.left,
      y1 = ( draggable.positionAbs ||
        draggable.position.absolute ).top + draggable.margins.top,
      x2 = x1 + draggable.helperProportions.width,
      y2 = y1 + draggable.helperProportions.height,
      l = droppable.offset.left,
      t = droppable.offset.top,
      r = l + droppable.proportions().width,
      b = t + droppable.proportions().height;

    switch ( toleranceMode ) {
    case "fit":
      return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
    case "intersect":
      return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
        x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
        t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
        y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
    case "pointer":
      return isOverAxis( event.pageY, t, droppable.proportions().height ) &&
        isOverAxis( event.pageX, l, droppable.proportions().width );
    case "touch":
      return (
        ( y1 >= t && y1 <= b ) || // Top edge touching
        ( y2 >= t && y2 <= b ) || // Bottom edge touching
        ( y1 < t && y2 > b ) // Surrounded vertically
      ) && (
        ( x1 >= l && x1 <= r ) || // Left edge touching
        ( x2 >= l && x2 <= r ) || // Right edge touching
        ( x1 < l && x2 > r ) // Surrounded horizontally
      );
    default:
      return false;
    }
  };
} )();

/*
  This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
  current: null,
  droppables: { "default": [] },
  prepareOffsets: function( t, event ) {

    var i, j,
      m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
      type = event ? event.type : null, // workaround for #2317
      list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

    droppablesLoop: for ( i = 0; i < m.length; i++ ) {

      // No disabled and non-accepted
      if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ],
          ( t.currentItem || t.element ) ) ) ) {
        continue;
      }

      // Filter out elements in the current dragged item
      for ( j = 0; j < list.length; j++ ) {
        if ( list[ j ] === m[ i ].element[ 0 ] ) {
          m[ i ].proportions().height = 0;
          continue droppablesLoop;
        }
      }

      m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
      if ( !m[ i ].visible ) {
        continue;
      }

      // Activate the droppable if used directly from draggables
      if ( type === "mousedown" ) {
        m[ i ]._activate.call( m[ i ], event );
      }

      m[ i ].offset = m[ i ].element.offset();
      m[ i ].proportions( {
        width: m[ i ].element[ 0 ].offsetWidth,
        height: m[ i ].element[ 0 ].offsetHeight
      } );

    }

  },
  drop: function( draggable, event ) {

    var dropped = false;

    // Create a copy of the droppables in case the list changes during the drop (#9116)
    $.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

      if ( !this.options ) {
        return;
      }
      if ( !this.options.disabled && this.visible &&
          intersect( draggable, this, this.options.tolerance, event ) ) {
        dropped = this._drop.call( this, event ) || dropped;
      }

      if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],
          ( draggable.currentItem || draggable.element ) ) ) {
        this.isout = true;
        this.isover = false;
        this._deactivate.call( this, event );
      }

    } );
    return dropped;

  },
  dragStart: function( draggable, event ) {

    // Listen for scrolling so that if the dragging causes scrolling the position of the
    // droppables can be recalculated (see #5003)
    draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {
      if ( !draggable.options.refreshPositions ) {
        $.ui.ddmanager.prepareOffsets( draggable, event );
      }
    } );
  },
  drag: function( draggable, event ) {

    // If you have a highly dynamic page, you might try this option. It renders positions
    // every time you move the mouse.
    if ( draggable.options.refreshPositions ) {
      $.ui.ddmanager.prepareOffsets( draggable, event );
    }

    // Run through all droppables and check their positions based on specific tolerance options
    $.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

      if ( this.options.disabled || this.greedyChild || !this.visible ) {
        return;
      }

      var parentInstance, scope, parent,
        intersects = intersect( draggable, this, this.options.tolerance, event ),
        c = !intersects && this.isover ?
          "isout" :
          ( intersects && !this.isover ? "isover" : null );
      if ( !c ) {
        return;
      }

      if ( this.options.greedy ) {

        // find droppable parents with same scope
        scope = this.options.scope;
        parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {
          return $( this ).droppable( "instance" ).options.scope === scope;
        } );

        if ( parent.length ) {
          parentInstance = $( parent[ 0 ] ).droppable( "instance" );
          parentInstance.greedyChild = ( c === "isover" );
        }
      }

      // We just moved into a greedy child
      if ( parentInstance && c === "isover" ) {
        parentInstance.isover = false;
        parentInstance.isout = true;
        parentInstance._out.call( parentInstance, event );
      }

      this[ c ] = true;
      this[ c === "isout" ? "isover" : "isout" ] = false;
      this[ c === "isover" ? "_over" : "_out" ].call( this, event );

      // We just moved out of a greedy child
      if ( parentInstance && c === "isout" ) {
        parentInstance.isout = false;
        parentInstance.isover = true;
        parentInstance._over.call( parentInstance, event );
      }
    } );

  },
  dragStop: function( draggable, event ) {
    draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );

    // Call prepareOffsets one final time since IE does not fire return scroll events when
    // overflow was caused by drag (see #5003)
    if ( !draggable.options.refreshPositions ) {
      $.ui.ddmanager.prepareOffsets( draggable, event );
    }
  }
};

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

  // Backcompat for activeClass and hoverClass options
  $.widget( "ui.droppable", $.ui.droppable, {
    options: {
      hoverClass: false,
      activeClass: false
    },
    _addActiveClass: function() {
      this._super();
      if ( this.options.activeClass ) {
        this.element.addClass( this.options.activeClass );
      }
    },
    _removeActiveClass: function() {
      this._super();
      if ( this.options.activeClass ) {
        this.element.removeClass( this.options.activeClass );
      }
    },
    _addHoverClass: function() {
      this._super();
      if ( this.options.hoverClass ) {
        this.element.addClass( this.options.hoverClass );
      }
    },
    _removeHoverClass: function() {
      this._super();
      if ( this.options.hoverClass ) {
        this.element.removeClass( this.options.hoverClass );
      }
    }
  } );
}

var widgetsDroppable = $.ui.droppable;


/*!
 * jQuery UI Progressbar 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Progressbar
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/progressbar/
//>>demos: http://jqueryui.com/progressbar/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/progressbar.css
//>>css.theme: ../../themes/base/theme.css



var widgetsProgressbar = $.widget( "ui.progressbar", {
  version: "1.12.1",
  options: {
    classes: {
      "ui-progressbar": "ui-corner-all",
      "ui-progressbar-value": "ui-corner-left",
      "ui-progressbar-complete": "ui-corner-right"
    },
    max: 100,
    value: 0,

    change: null,
    complete: null
  },

  min: 0,

  _create: function() {

    // Constrain initial value
    this.oldValue = this.options.value = this._constrainedValue();

    this.element.attr( {

      // Only set static values; aria-valuenow and aria-valuemax are
      // set inside _refreshValue()
      role: "progressbar",
      "aria-valuemin": this.min
    } );
    this._addClass( "ui-progressbar", "ui-widget ui-widget-content" );

    this.valueDiv = $( "<div>" ).appendTo( this.element );
    this._addClass( this.valueDiv, "ui-progressbar-value", "ui-widget-header" );
    this._refreshValue();
  },

  _destroy: function() {
    this.element.removeAttr( "role aria-valuemin aria-valuemax aria-valuenow" );

    this.valueDiv.remove();
  },

  value: function( newValue ) {
    if ( newValue === undefined ) {
      return this.options.value;
    }

    this.options.value = this._constrainedValue( newValue );
    this._refreshValue();
  },

  _constrainedValue: function( newValue ) {
    if ( newValue === undefined ) {
      newValue = this.options.value;
    }

    this.indeterminate = newValue === false;

    // Sanitize value
    if ( typeof newValue !== "number" ) {
      newValue = 0;
    }

    return this.indeterminate ? false :
      Math.min( this.options.max, Math.max( this.min, newValue ) );
  },

  _setOptions: function( options ) {

    // Ensure "value" option is set after other values (like max)
    var value = options.value;
    delete options.value;

    this._super( options );

    this.options.value = this._constrainedValue( value );
    this._refreshValue();
  },

  _setOption: function( key, value ) {
    if ( key === "max" ) {

      // Don't allow a max less than min
      value = Math.max( this.min, value );
    }
    this._super( key, value );
  },

  _setOptionDisabled: function( value ) {
    this._super( value );

    this.element.attr( "aria-disabled", value );
    this._toggleClass( null, "ui-state-disabled", !!value );
  },

  _percentage: function() {
    return this.indeterminate ?
      100 :
      100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
  },

  _refreshValue: function() {
    var value = this.options.value,
      percentage = this._percentage();

    this.valueDiv
      .toggle( this.indeterminate || value > this.min )
      .width( percentage.toFixed( 0 ) + "%" );

    this
      ._toggleClass( this.valueDiv, "ui-progressbar-complete", null,
        value === this.options.max )
      ._toggleClass( "ui-progressbar-indeterminate", null, this.indeterminate );

    if ( this.indeterminate ) {
      this.element.removeAttr( "aria-valuenow" );
      if ( !this.overlayDiv ) {
        this.overlayDiv = $( "<div>" ).appendTo( this.valueDiv );
        this._addClass( this.overlayDiv, "ui-progressbar-overlay" );
      }
    } else {
      this.element.attr( {
        "aria-valuemax": this.options.max,
        "aria-valuenow": value
      } );
      if ( this.overlayDiv ) {
        this.overlayDiv.remove();
        this.overlayDiv = null;
      }
    }

    if ( this.oldValue !== value ) {
      this.oldValue = value;
      this._trigger( "change" );
    }
    if ( value === this.options.max ) {
      this._trigger( "complete" );
    }
  }
} );


/*!
 * jQuery UI Selectable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectable
//>>group: Interactions
//>>description: Allows groups of elements to be selected with the mouse.
//>>docs: http://api.jqueryui.com/selectable/
//>>demos: http://jqueryui.com/selectable/
//>>css.structure: ../../themes/base/selectable.css



var widgetsSelectable = $.widget( "ui.selectable", $.ui.mouse, {
  version: "1.12.1",
  options: {
    appendTo: "body",
    autoRefresh: true,
    distance: 0,
    filter: "*",
    tolerance: "touch",

    // Callbacks
    selected: null,
    selecting: null,
    start: null,
    stop: null,
    unselected: null,
    unselecting: null
  },
  _create: function() {
    var that = this;

    this._addClass( "ui-selectable" );

    this.dragged = false;

    // Cache selectee children based on filter
    this.refresh = function() {
      that.elementPos = $( that.element[ 0 ] ).offset();
      that.selectees = $( that.options.filter, that.element[ 0 ] );
      that._addClass( that.selectees, "ui-selectee" );
      that.selectees.each( function() {
        var $this = $( this ),
          selecteeOffset = $this.offset(),
          pos = {
            left: selecteeOffset.left - that.elementPos.left,
            top: selecteeOffset.top - that.elementPos.top
          };
        $.data( this, "selectable-item", {
          element: this,
          $element: $this,
          left: pos.left,
          top: pos.top,
          right: pos.left + $this.outerWidth(),
          bottom: pos.top + $this.outerHeight(),
          startselected: false,
          selected: $this.hasClass( "ui-selected" ),
          selecting: $this.hasClass( "ui-selecting" ),
          unselecting: $this.hasClass( "ui-unselecting" )
        } );
      } );
    };
    this.refresh();

    this._mouseInit();

    this.helper = $( "<div>" );
    this._addClass( this.helper, "ui-selectable-helper" );
  },

  _destroy: function() {
    this.selectees.removeData( "selectable-item" );
    this._mouseDestroy();
  },

  _mouseStart: function( event ) {
    var that = this,
      options = this.options;

    this.opos = [ event.pageX, event.pageY ];
    this.elementPos = $( this.element[ 0 ] ).offset();

    if ( this.options.disabled ) {
      return;
    }

    this.selectees = $( options.filter, this.element[ 0 ] );

    this._trigger( "start", event );

    $( options.appendTo ).append( this.helper );

    // position helper (lasso)
    this.helper.css( {
      "left": event.pageX,
      "top": event.pageY,
      "width": 0,
      "height": 0
    } );

    if ( options.autoRefresh ) {
      this.refresh();
    }

    this.selectees.filter( ".ui-selected" ).each( function() {
      var selectee = $.data( this, "selectable-item" );
      selectee.startselected = true;
      if ( !event.metaKey && !event.ctrlKey ) {
        that._removeClass( selectee.$element, "ui-selected" );
        selectee.selected = false;
        that._addClass( selectee.$element, "ui-unselecting" );
        selectee.unselecting = true;

        // selectable UNSELECTING callback
        that._trigger( "unselecting", event, {
          unselecting: selectee.element
        } );
      }
    } );

    $( event.target ).parents().addBack().each( function() {
      var doSelect,
        selectee = $.data( this, "selectable-item" );
      if ( selectee ) {
        doSelect = ( !event.metaKey && !event.ctrlKey ) ||
          !selectee.$element.hasClass( "ui-selected" );
        that._removeClass( selectee.$element, doSelect ? "ui-unselecting" : "ui-selected" )
          ._addClass( selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting" );
        selectee.unselecting = !doSelect;
        selectee.selecting = doSelect;
        selectee.selected = doSelect;

        // selectable (UN)SELECTING callback
        if ( doSelect ) {
          that._trigger( "selecting", event, {
            selecting: selectee.element
          } );
        } else {
          that._trigger( "unselecting", event, {
            unselecting: selectee.element
          } );
        }
        return false;
      }
    } );

  },

  _mouseDrag: function( event ) {

    this.dragged = true;

    if ( this.options.disabled ) {
      return;
    }

    var tmp,
      that = this,
      options = this.options,
      x1 = this.opos[ 0 ],
      y1 = this.opos[ 1 ],
      x2 = event.pageX,
      y2 = event.pageY;

    if ( x1 > x2 ) { tmp = x2; x2 = x1; x1 = tmp; }
    if ( y1 > y2 ) { tmp = y2; y2 = y1; y1 = tmp; }
    this.helper.css( { left: x1, top: y1, width: x2 - x1, height: y2 - y1 } );

    this.selectees.each( function() {
      var selectee = $.data( this, "selectable-item" ),
        hit = false,
        offset = {};

      //prevent helper from being selected if appendTo: selectable
      if ( !selectee || selectee.element === that.element[ 0 ] ) {
        return;
      }

      offset.left   = selectee.left   + that.elementPos.left;
      offset.right  = selectee.right  + that.elementPos.left;
      offset.top    = selectee.top    + that.elementPos.top;
      offset.bottom = selectee.bottom + that.elementPos.top;

      if ( options.tolerance === "touch" ) {
        hit = ( !( offset.left > x2 || offset.right < x1 || offset.top > y2 ||
                    offset.bottom < y1 ) );
      } else if ( options.tolerance === "fit" ) {
        hit = ( offset.left > x1 && offset.right < x2 && offset.top > y1 &&
                    offset.bottom < y2 );
      }

      if ( hit ) {

        // SELECT
        if ( selectee.selected ) {
          that._removeClass( selectee.$element, "ui-selected" );
          selectee.selected = false;
        }
        if ( selectee.unselecting ) {
          that._removeClass( selectee.$element, "ui-unselecting" );
          selectee.unselecting = false;
        }
        if ( !selectee.selecting ) {
          that._addClass( selectee.$element, "ui-selecting" );
          selectee.selecting = true;

          // selectable SELECTING callback
          that._trigger( "selecting", event, {
            selecting: selectee.element
          } );
        }
      } else {

        // UNSELECT
        if ( selectee.selecting ) {
          if ( ( event.metaKey || event.ctrlKey ) && selectee.startselected ) {
            that._removeClass( selectee.$element, "ui-selecting" );
            selectee.selecting = false;
            that._addClass( selectee.$element, "ui-selected" );
            selectee.selected = true;
          } else {
            that._removeClass( selectee.$element, "ui-selecting" );
            selectee.selecting = false;
            if ( selectee.startselected ) {
              that._addClass( selectee.$element, "ui-unselecting" );
              selectee.unselecting = true;
            }

            // selectable UNSELECTING callback
            that._trigger( "unselecting", event, {
              unselecting: selectee.element
            } );
          }
        }
        if ( selectee.selected ) {
          if ( !event.metaKey && !event.ctrlKey && !selectee.startselected ) {
            that._removeClass( selectee.$element, "ui-selected" );
            selectee.selected = false;

            that._addClass( selectee.$element, "ui-unselecting" );
            selectee.unselecting = true;

            // selectable UNSELECTING callback
            that._trigger( "unselecting", event, {
              unselecting: selectee.element
            } );
          }
        }
      }
    } );

    return false;
  },

  _mouseStop: function( event ) {
    var that = this;

    this.dragged = false;

    $( ".ui-unselecting", this.element[ 0 ] ).each( function() {
      var selectee = $.data( this, "selectable-item" );
      that._removeClass( selectee.$element, "ui-unselecting" );
      selectee.unselecting = false;
      selectee.startselected = false;
      that._trigger( "unselected", event, {
        unselected: selectee.element
      } );
    } );
    $( ".ui-selecting", this.element[ 0 ] ).each( function() {
      var selectee = $.data( this, "selectable-item" );
      that._removeClass( selectee.$element, "ui-selecting" )
        ._addClass( selectee.$element, "ui-selected" );
      selectee.selecting = false;
      selectee.selected = true;
      selectee.startselected = true;
      that._trigger( "selected", event, {
        selected: selectee.element
      } );
    } );
    this._trigger( "stop", event );

    this.helper.remove();

    return false;
  }

} );


/*!
 * jQuery UI Selectmenu 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectmenu
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/selectmenu/
//>>demos: http://jqueryui.com/selectmenu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSelectmenu = $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {
  version: "1.12.1",
  defaultElement: "<select>",
  options: {
    appendTo: null,
    classes: {
      "ui-selectmenu-button-open": "ui-corner-top",
      "ui-selectmenu-button-closed": "ui-corner-all"
    },
    disabled: null,
    icons: {
      button: "ui-icon-triangle-1-s"
    },
    position: {
      my: "left top",
      at: "left bottom",
      collision: "none"
    },
    width: false,

    // Callbacks
    change: null,
    close: null,
    focus: null,
    open: null,
    select: null
  },

  _create: function() {
    var selectmenuId = this.element.uniqueId().attr( "id" );
    this.ids = {
      element: selectmenuId,
      button: selectmenuId + "-button",
      menu: selectmenuId + "-menu"
    };

    this._drawButton();
    this._drawMenu();
    this._bindFormResetHandler();

    this._rendered = false;
    this.menuItems = $();
  },

  _drawButton: function() {
    var icon,
      that = this,
      item = this._parseOption(
        this.element.find( "option:selected" ),
        this.element[ 0 ].selectedIndex
      );

    // Associate existing label with the new button
    this.labels = this.element.labels().attr( "for", this.ids.button );
    this._on( this.labels, {
      click: function( event ) {
        this.button.focus();
        event.preventDefault();
      }
    } );

    // Hide original select element
    this.element.hide();

    // Create button
    this.button = $( "<span>", {
      tabindex: this.options.disabled ? -1 : 0,
      id: this.ids.button,
      role: "combobox",
      "aria-expanded": "false",
      "aria-autocomplete": "list",
      "aria-owns": this.ids.menu,
      "aria-haspopup": "true",
      title: this.element.attr( "title" )
    } )
      .insertAfter( this.element );

    this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
      "ui-button ui-widget" );

    icon = $( "<span>" ).appendTo( this.button );
    this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );
    this.buttonItem = this._renderButtonItem( item )
      .appendTo( this.button );

    if ( this.options.width !== false ) {
      this._resizeButton();
    }

    this._on( this.button, this._buttonEvents );
    this.button.one( "focusin", function() {

      // Delay rendering the menu items until the button receives focus.
      // The menu may have already been rendered via a programmatic open.
      if ( !that._rendered ) {
        that._refreshMenu();
      }
    } );
  },

  _drawMenu: function() {
    var that = this;

    // Create menu
    this.menu = $( "<ul>", {
      "aria-hidden": "true",
      "aria-labelledby": this.ids.button,
      id: this.ids.menu
    } );

    // Wrap menu
    this.menuWrap = $( "<div>" ).append( this.menu );
    this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );
    this.menuWrap.appendTo( this._appendTo() );

    // Initialize menu widget
    this.menuInstance = this.menu
      .menu( {
        classes: {
          "ui-menu": "ui-corner-bottom"
        },
        role: "listbox",
        select: function( event, ui ) {
          event.preventDefault();

          // Support: IE8
          // If the item was selected via a click, the text selection
          // will be destroyed in IE
          that._setSelection();

          that._select( ui.item.data( "ui-selectmenu-item" ), event );
        },
        focus: function( event, ui ) {
          var item = ui.item.data( "ui-selectmenu-item" );

          // Prevent inital focus from firing and check if its a newly focused item
          if ( that.focusIndex != null && item.index !== that.focusIndex ) {
            that._trigger( "focus", event, { item: item } );
            if ( !that.isOpen ) {
              that._select( item, event );
            }
          }
          that.focusIndex = item.index;

          that.button.attr( "aria-activedescendant",
            that.menuItems.eq( item.index ).attr( "id" ) );
        }
      } )
      .menu( "instance" );

    // Don't close the menu on mouseleave
    this.menuInstance._off( this.menu, "mouseleave" );

    // Cancel the menu's collapseAll on document click
    this.menuInstance._closeOnDocumentClick = function() {
      return false;
    };

    // Selects often contain empty items, but never contain dividers
    this.menuInstance._isDivider = function() {
      return false;
    };
  },

  refresh: function() {
    this._refreshMenu();
    this.buttonItem.replaceWith(
      this.buttonItem = this._renderButtonItem(

        // Fall back to an empty object in case there are no options
        this._getSelectedItem().data( "ui-selectmenu-item" ) || {}
      )
    );
    if ( this.options.width === null ) {
      this._resizeButton();
    }
  },

  _refreshMenu: function() {
    var item,
      options = this.element.find( "option" );

    this.menu.empty();

    this._parseOptions( options );
    this._renderMenu( this.menu, this.items );

    this.menuInstance.refresh();
    this.menuItems = this.menu.find( "li" )
      .not( ".ui-selectmenu-optgroup" )
        .find( ".ui-menu-item-wrapper" );

    this._rendered = true;

    if ( !options.length ) {
      return;
    }

    item = this._getSelectedItem();

    // Update the menu to have the correct item focused
    this.menuInstance.focus( null, item );
    this._setAria( item.data( "ui-selectmenu-item" ) );

    // Set disabled state
    this._setOption( "disabled", this.element.prop( "disabled" ) );
  },

  open: function( event ) {
    if ( this.options.disabled ) {
      return;
    }

    // If this is the first time the menu is being opened, render the items
    if ( !this._rendered ) {
      this._refreshMenu();
    } else {

      // Menu clears focus on close, reset focus to selected item
      this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );
      this.menuInstance.focus( null, this._getSelectedItem() );
    }

    // If there are no options, don't open the menu
    if ( !this.menuItems.length ) {
      return;
    }

    this.isOpen = true;
    this._toggleAttr();
    this._resizeMenu();
    this._position();

    this._on( this.document, this._documentClick );

    this._trigger( "open", event );
  },

  _position: function() {
    this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
  },

  close: function( event ) {
    if ( !this.isOpen ) {
      return;
    }

    this.isOpen = false;
    this._toggleAttr();

    this.range = null;
    this._off( this.document );

    this._trigger( "close", event );
  },

  widget: function() {
    return this.button;
  },

  menuWidget: function() {
    return this.menu;
  },

  _renderButtonItem: function( item ) {
    var buttonItem = $( "<span>" );

    this._setText( buttonItem, item.label );
    this._addClass( buttonItem, "ui-selectmenu-text" );

    return buttonItem;
  },

  _renderMenu: function( ul, items ) {
    var that = this,
      currentOptgroup = "";

    $.each( items, function( index, item ) {
      var li;

      if ( item.optgroup !== currentOptgroup ) {
        li = $( "<li>", {
          text: item.optgroup
        } );
        that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +
          ( item.element.parent( "optgroup" ).prop( "disabled" ) ?
            " ui-state-disabled" :
            "" ) );

        li.appendTo( ul );

        currentOptgroup = item.optgroup;
      }

      that._renderItemData( ul, item );
    } );
  },

  _renderItemData: function( ul, item ) {
    return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
  },

  _renderItem: function( ul, item ) {
    var li = $( "<li>" ),
      wrapper = $( "<div>", {
        title: item.element.attr( "title" )
      } );

    if ( item.disabled ) {
      this._addClass( li, null, "ui-state-disabled" );
    }
    this._setText( wrapper, item.label );

    return li.append( wrapper ).appendTo( ul );
  },

  _setText: function( element, value ) {
    if ( value ) {
      element.text( value );
    } else {
      element.html( "&#160;" );
    }
  },

  _move: function( direction, event ) {
    var item, next,
      filter = ".ui-menu-item";

    if ( this.isOpen ) {
      item = this.menuItems.eq( this.focusIndex ).parent( "li" );
    } else {
      item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
      filter += ":not(.ui-state-disabled)";
    }

    if ( direction === "first" || direction === "last" ) {
      next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
    } else {
      next = item[ direction + "All" ]( filter ).eq( 0 );
    }

    if ( next.length ) {
      this.menuInstance.focus( event, next );
    }
  },

  _getSelectedItem: function() {
    return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
  },

  _toggle: function( event ) {
    this[ this.isOpen ? "close" : "open" ]( event );
  },

  _setSelection: function() {
    var selection;

    if ( !this.range ) {
      return;
    }

    if ( window.getSelection ) {
      selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange( this.range );

    // Support: IE8
    } else {
      this.range.select();
    }

    // Support: IE
    // Setting the text selection kills the button focus in IE, but
    // restoring the focus doesn't kill the selection.
    this.button.focus();
  },

  _documentClick: {
    mousedown: function( event ) {
      if ( !this.isOpen ) {
        return;
      }

      if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" +
          $.ui.escapeSelector( this.ids.button ) ).length ) {
        this.close( event );
      }
    }
  },

  _buttonEvents: {

    // Prevent text selection from being reset when interacting with the selectmenu (#10144)
    mousedown: function() {
      var selection;

      if ( window.getSelection ) {
        selection = window.getSelection();
        if ( selection.rangeCount ) {
          this.range = selection.getRangeAt( 0 );
        }

      // Support: IE8
      } else {
        this.range = document.selection.createRange();
      }
    },

    click: function( event ) {
      this._setSelection();
      this._toggle( event );
    },

    keydown: function( event ) {
      var preventDefault = true;
      switch ( event.keyCode ) {
      case $.ui.keyCode.TAB:
      case $.ui.keyCode.ESCAPE:
        this.close( event );
        preventDefault = false;
        break;
      case $.ui.keyCode.ENTER:
        if ( this.isOpen ) {
          this._selectFocusedItem( event );
        }
        break;
      case $.ui.keyCode.UP:
        if ( event.altKey ) {
          this._toggle( event );
        } else {
          this._move( "prev", event );
        }
        break;
      case $.ui.keyCode.DOWN:
        if ( event.altKey ) {
          this._toggle( event );
        } else {
          this._move( "next", event );
        }
        break;
      case $.ui.keyCode.SPACE:
        if ( this.isOpen ) {
          this._selectFocusedItem( event );
        } else {
          this._toggle( event );
        }
        break;
      case $.ui.keyCode.LEFT:
        this._move( "prev", event );
        break;
      case $.ui.keyCode.RIGHT:
        this._move( "next", event );
        break;
      case $.ui.keyCode.HOME:
      case $.ui.keyCode.PAGE_UP:
        this._move( "first", event );
        break;
      case $.ui.keyCode.END:
      case $.ui.keyCode.PAGE_DOWN:
        this._move( "last", event );
        break;
      default:
        this.menu.trigger( event );
        preventDefault = false;
      }

      if ( preventDefault ) {
        event.preventDefault();
      }
    }
  },

  _selectFocusedItem: function( event ) {
    var item = this.menuItems.eq( this.focusIndex ).parent( "li" );
    if ( !item.hasClass( "ui-state-disabled" ) ) {
      this._select( item.data( "ui-selectmenu-item" ), event );
    }
  },

  _select: function( item, event ) {
    var oldIndex = this.element[ 0 ].selectedIndex;

    // Change native select element
    this.element[ 0 ].selectedIndex = item.index;
    this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );
    this._setAria( item );
    this._trigger( "select", event, { item: item } );

    if ( item.index !== oldIndex ) {
      this._trigger( "change", event, { item: item } );
    }

    this.close( event );
  },

  _setAria: function( item ) {
    var id = this.menuItems.eq( item.index ).attr( "id" );

    this.button.attr( {
      "aria-labelledby": id,
      "aria-activedescendant": id
    } );
    this.menu.attr( "aria-activedescendant", id );
  },

  _setOption: function( key, value ) {
    if ( key === "icons" ) {
      var icon = this.button.find( "span.ui-icon" );
      this._removeClass( icon, null, this.options.icons.button )
        ._addClass( icon, null, value.button );
    }

    this._super( key, value );

    if ( key === "appendTo" ) {
      this.menuWrap.appendTo( this._appendTo() );
    }

    if ( key === "width" ) {
      this._resizeButton();
    }
  },

  _setOptionDisabled: function( value ) {
    this._super( value );

    this.menuInstance.option( "disabled", value );
    this.button.attr( "aria-disabled", value );
    this._toggleClass( this.button, null, "ui-state-disabled", value );

    this.element.prop( "disabled", value );
    if ( value ) {
      this.button.attr( "tabindex", -1 );
      this.close();
    } else {
      this.button.attr( "tabindex", 0 );
    }
  },

  _appendTo: function() {
    var element = this.options.appendTo;

    if ( element ) {
      element = element.jquery || element.nodeType ?
        $( element ) :
        this.document.find( element ).eq( 0 );
    }

    if ( !element || !element[ 0 ] ) {
      element = this.element.closest( ".ui-front, dialog" );
    }

    if ( !element.length ) {
      element = this.document[ 0 ].body;
    }

    return element;
  },

  _toggleAttr: function() {
    this.button.attr( "aria-expanded", this.isOpen );

    // We can't use two _toggleClass() calls here, because we need to make sure
    // we always remove classes first and add them second, otherwise if both classes have the
    // same theme class, it will be removed after we add it.
    this._removeClass( this.button, "ui-selectmenu-button-" +
      ( this.isOpen ? "closed" : "open" ) )
      ._addClass( this.button, "ui-selectmenu-button-" +
        ( this.isOpen ? "open" : "closed" ) )
      ._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );

    this.menu.attr( "aria-hidden", !this.isOpen );
  },

  _resizeButton: function() {
    var width = this.options.width;

    // For `width: false`, just remove inline style and stop
    if ( width === false ) {
      this.button.css( "width", "" );
      return;
    }

    // For `width: null`, match the width of the original element
    if ( width === null ) {
      width = this.element.show().outerWidth();
      this.element.hide();
    }

    this.button.outerWidth( width );
  },

  _resizeMenu: function() {
    this.menu.outerWidth( Math.max(
      this.button.outerWidth(),

      // Support: IE10
      // IE10 wraps long text (possibly a rounding bug)
      // so we add 1px to avoid the wrapping
      this.menu.width( "" ).outerWidth() + 1
    ) );
  },

  _getCreateOptions: function() {
    var options = this._super();

    options.disabled = this.element.prop( "disabled" );

    return options;
  },

  _parseOptions: function( options ) {
    var that = this,
      data = [];
    options.each( function( index, item ) {
      data.push( that._parseOption( $( item ), index ) );
    } );
    this.items = data;
  },

  _parseOption: function( option, index ) {
    var optgroup = option.parent( "optgroup" );

    return {
      element: option,
      index: index,
      value: option.val(),
      label: option.text(),
      optgroup: optgroup.attr( "label" ) || "",
      disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
    };
  },

  _destroy: function() {
    this._unbindFormResetHandler();
    this.menuWrap.remove();
    this.button.remove();
    this.element.show();
    this.element.removeUniqueId();
    this.labels.attr( "for", this.ids.element );
  }
} ] );


/*!
 * jQuery UI Slider 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slider
//>>group: Widgets
//>>description: Displays a flexible slider with ranges and accessibility via keyboard.
//>>docs: http://api.jqueryui.com/slider/
//>>demos: http://jqueryui.com/slider/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/slider.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSlider = $.widget( "ui.slider", $.ui.mouse, {
  version: "1.12.1",
  widgetEventPrefix: "slide",

  options: {
    animate: false,
    classes: {
      "ui-slider": "ui-corner-all",
      "ui-slider-handle": "ui-corner-all",

      // Note: ui-widget-header isn't the most fittingly semantic framework class for this
      // element, but worked best visually with a variety of themes
      "ui-slider-range": "ui-corner-all ui-widget-header"
    },
    distance: 0,
    max: 100,
    min: 0,
    orientation: "horizontal",
    range: false,
    step: 1,
    value: 0,
    values: null,

    // Callbacks
    change: null,
    slide: null,
    start: null,
    stop: null
  },

  // Number of pages in a slider
  // (how many times can you page up/down to go through the whole range)
  numPages: 5,

  _create: function() {
    this._keySliding = false;
    this._mouseSliding = false;
    this._animateOff = true;
    this._handleIndex = null;
    this._detectOrientation();
    this._mouseInit();
    this._calculateNewMax();

    this._addClass( "ui-slider ui-slider-" + this.orientation,
      "ui-widget ui-widget-content" );

    this._refresh();

    this._animateOff = false;
  },

  _refresh: function() {
    this._createRange();
    this._createHandles();
    this._setupEvents();
    this._refreshValue();
  },

  _createHandles: function() {
    var i, handleCount,
      options = this.options,
      existingHandles = this.element.find( ".ui-slider-handle" ),
      handle = "<span tabindex='0'></span>",
      handles = [];

    handleCount = ( options.values && options.values.length ) || 1;

    if ( existingHandles.length > handleCount ) {
      existingHandles.slice( handleCount ).remove();
      existingHandles = existingHandles.slice( 0, handleCount );
    }

    for ( i = existingHandles.length; i < handleCount; i++ ) {
      handles.push( handle );
    }

    this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

    this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );

    this.handle = this.handles.eq( 0 );

    this.handles.each( function( i ) {
      $( this )
        .data( "ui-slider-handle-index", i )
        .attr( "tabIndex", 0 );
    } );
  },

  _createRange: function() {
    var options = this.options;

    if ( options.range ) {
      if ( options.range === true ) {
        if ( !options.values ) {
          options.values = [ this._valueMin(), this._valueMin() ];
        } else if ( options.values.length && options.values.length !== 2 ) {
          options.values = [ options.values[ 0 ], options.values[ 0 ] ];
        } else if ( $.isArray( options.values ) ) {
          options.values = options.values.slice( 0 );
        }
      }

      if ( !this.range || !this.range.length ) {
        this.range = $( "<div>" )
          .appendTo( this.element );

        this._addClass( this.range, "ui-slider-range" );
      } else {
        this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );

        // Handle range switching from true to min/max
        this.range.css( {
          "left": "",
          "bottom": ""
        } );
      }
      if ( options.range === "min" || options.range === "max" ) {
        this._addClass( this.range, "ui-slider-range-" + options.range );
      }
    } else {
      if ( this.range ) {
        this.range.remove();
      }
      this.range = null;
    }
  },

  _setupEvents: function() {
    this._off( this.handles );
    this._on( this.handles, this._handleEvents );
    this._hoverable( this.handles );
    this._focusable( this.handles );
  },

  _destroy: function() {
    this.handles.remove();
    if ( this.range ) {
      this.range.remove();
    }

    this._mouseDestroy();
  },

  _mouseCapture: function( event ) {
    var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
      that = this,
      o = this.options;

    if ( o.disabled ) {
      return false;
    }

    this.elementSize = {
      width: this.element.outerWidth(),
      height: this.element.outerHeight()
    };
    this.elementOffset = this.element.offset();

    position = { x: event.pageX, y: event.pageY };
    normValue = this._normValueFromMouse( position );
    distance = this._valueMax() - this._valueMin() + 1;
    this.handles.each( function( i ) {
      var thisDistance = Math.abs( normValue - that.values( i ) );
      if ( ( distance > thisDistance ) ||
        ( distance === thisDistance &&
          ( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
        distance = thisDistance;
        closestHandle = $( this );
        index = i;
      }
    } );

    allowed = this._start( event, index );
    if ( allowed === false ) {
      return false;
    }
    this._mouseSliding = true;

    this._handleIndex = index;

    this._addClass( closestHandle, null, "ui-state-active" );
    closestHandle.trigger( "focus" );

    offset = closestHandle.offset();
    mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
    this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
      left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
      top: event.pageY - offset.top -
        ( closestHandle.height() / 2 ) -
        ( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
        ( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
        ( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
    };

    if ( !this.handles.hasClass( "ui-state-hover" ) ) {
      this._slide( event, index, normValue );
    }
    this._animateOff = true;
    return true;
  },

  _mouseStart: function() {
    return true;
  },

  _mouseDrag: function( event ) {
    var position = { x: event.pageX, y: event.pageY },
      normValue = this._normValueFromMouse( position );

    this._slide( event, this._handleIndex, normValue );

    return false;
  },

  _mouseStop: function( event ) {
    this._removeClass( this.handles, null, "ui-state-active" );
    this._mouseSliding = false;

    this._stop( event, this._handleIndex );
    this._change( event, this._handleIndex );

    this._handleIndex = null;
    this._clickOffset = null;
    this._animateOff = false;

    return false;
  },

  _detectOrientation: function() {
    this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
  },

  _normValueFromMouse: function( position ) {
    var pixelTotal,
      pixelMouse,
      percentMouse,
      valueTotal,
      valueMouse;

    if ( this.orientation === "horizontal" ) {
      pixelTotal = this.elementSize.width;
      pixelMouse = position.x - this.elementOffset.left -
        ( this._clickOffset ? this._clickOffset.left : 0 );
    } else {
      pixelTotal = this.elementSize.height;
      pixelMouse = position.y - this.elementOffset.top -
        ( this._clickOffset ? this._clickOffset.top : 0 );
    }

    percentMouse = ( pixelMouse / pixelTotal );
    if ( percentMouse > 1 ) {
      percentMouse = 1;
    }
    if ( percentMouse < 0 ) {
      percentMouse = 0;
    }
    if ( this.orientation === "vertical" ) {
      percentMouse = 1 - percentMouse;
    }

    valueTotal = this._valueMax() - this._valueMin();
    valueMouse = this._valueMin() + percentMouse * valueTotal;

    return this._trimAlignValue( valueMouse );
  },

  _uiHash: function( index, value, values ) {
    var uiHash = {
      handle: this.handles[ index ],
      handleIndex: index,
      value: value !== undefined ? value : this.value()
    };

    if ( this._hasMultipleValues() ) {
      uiHash.value = value !== undefined ? value : this.values( index );
      uiHash.values = values || this.values();
    }

    return uiHash;
  },

  _hasMultipleValues: function() {
    return this.options.values && this.options.values.length;
  },

  _start: function( event, index ) {
    return this._trigger( "start", event, this._uiHash( index ) );
  },

  _slide: function( event, index, newVal ) {
    var allowed, otherVal,
      currentValue = this.value(),
      newValues = this.values();

    if ( this._hasMultipleValues() ) {
      otherVal = this.values( index ? 0 : 1 );
      currentValue = this.values( index );

      if ( this.options.values.length === 2 && this.options.range === true ) {
        newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
      }

      newValues[ index ] = newVal;
    }

    if ( newVal === currentValue ) {
      return;
    }

    allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );

    // A slide can be canceled by returning false from the slide callback
    if ( allowed === false ) {
      return;
    }

    if ( this._hasMultipleValues() ) {
      this.values( index, newVal );
    } else {
      this.value( newVal );
    }
  },

  _stop: function( event, index ) {
    this._trigger( "stop", event, this._uiHash( index ) );
  },

  _change: function( event, index ) {
    if ( !this._keySliding && !this._mouseSliding ) {

      //store the last changed value index for reference when handles overlap
      this._lastChangedValue = index;
      this._trigger( "change", event, this._uiHash( index ) );
    }
  },

  value: function( newValue ) {
    if ( arguments.length ) {
      this.options.value = this._trimAlignValue( newValue );
      this._refreshValue();
      this._change( null, 0 );
      return;
    }

    return this._value();
  },

  values: function( index, newValue ) {
    var vals,
      newValues,
      i;

    if ( arguments.length > 1 ) {
      this.options.values[ index ] = this._trimAlignValue( newValue );
      this._refreshValue();
      this._change( null, index );
      return;
    }

    if ( arguments.length ) {
      if ( $.isArray( arguments[ 0 ] ) ) {
        vals = this.options.values;
        newValues = arguments[ 0 ];
        for ( i = 0; i < vals.length; i += 1 ) {
          vals[ i ] = this._trimAlignValue( newValues[ i ] );
          this._change( null, i );
        }
        this._refreshValue();
      } else {
        if ( this._hasMultipleValues() ) {
          return this._values( index );
        } else {
          return this.value();
        }
      }
    } else {
      return this._values();
    }
  },

  _setOption: function( key, value ) {
    var i,
      valsLength = 0;

    if ( key === "range" && this.options.range === true ) {
      if ( value === "min" ) {
        this.options.value = this._values( 0 );
        this.options.values = null;
      } else if ( value === "max" ) {
        this.options.value = this._values( this.options.values.length - 1 );
        this.options.values = null;
      }
    }

    if ( $.isArray( this.options.values ) ) {
      valsLength = this.options.values.length;
    }

    this._super( key, value );

    switch ( key ) {
      case "orientation":
        this._detectOrientation();
        this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
          ._addClass( "ui-slider-" + this.orientation );
        this._refreshValue();
        if ( this.options.range ) {
          this._refreshRange( value );
        }

        // Reset positioning from previous orientation
        this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
        break;
      case "value":
        this._animateOff = true;
        this._refreshValue();
        this._change( null, 0 );
        this._animateOff = false;
        break;
      case "values":
        this._animateOff = true;
        this._refreshValue();

        // Start from the last handle to prevent unreachable handles (#9046)
        for ( i = valsLength - 1; i >= 0; i-- ) {
          this._change( null, i );
        }
        this._animateOff = false;
        break;
      case "step":
      case "min":
      case "max":
        this._animateOff = true;
        this._calculateNewMax();
        this._refreshValue();
        this._animateOff = false;
        break;
      case "range":
        this._animateOff = true;
        this._refresh();
        this._animateOff = false;
        break;
    }
  },

  _setOptionDisabled: function( value ) {
    this._super( value );

    this._toggleClass( null, "ui-state-disabled", !!value );
  },

  //internal value getter
  // _value() returns value trimmed by min and max, aligned by step
  _value: function() {
    var val = this.options.value;
    val = this._trimAlignValue( val );

    return val;
  },

  //internal values getter
  // _values() returns array of values trimmed by min and max, aligned by step
  // _values( index ) returns single value trimmed by min and max, aligned by step
  _values: function( index ) {
    var val,
      vals,
      i;

    if ( arguments.length ) {
      val = this.options.values[ index ];
      val = this._trimAlignValue( val );

      return val;
    } else if ( this._hasMultipleValues() ) {

      // .slice() creates a copy of the array
      // this copy gets trimmed by min and max and then returned
      vals = this.options.values.slice();
      for ( i = 0; i < vals.length; i += 1 ) {
        vals[ i ] = this._trimAlignValue( vals[ i ] );
      }

      return vals;
    } else {
      return [];
    }
  },

  // Returns the step-aligned value that val is closest to, between (inclusive) min and max
  _trimAlignValue: function( val ) {
    if ( val <= this._valueMin() ) {
      return this._valueMin();
    }
    if ( val >= this._valueMax() ) {
      return this._valueMax();
    }
    var step = ( this.options.step > 0 ) ? this.options.step : 1,
      valModStep = ( val - this._valueMin() ) % step,
      alignValue = val - valModStep;

    if ( Math.abs( valModStep ) * 2 >= step ) {
      alignValue += ( valModStep > 0 ) ? step : ( -step );
    }

    // Since JavaScript has problems with large floats, round
    // the final value to 5 digits after the decimal point (see #4124)
    return parseFloat( alignValue.toFixed( 5 ) );
  },

  _calculateNewMax: function() {
    var max = this.options.max,
      min = this._valueMin(),
      step = this.options.step,
      aboveMin = Math.round( ( max - min ) / step ) * step;
    max = aboveMin + min;
    if ( max > this.options.max ) {

      //If max is not divisible by step, rounding off may increase its value
      max -= step;
    }
    this.max = parseFloat( max.toFixed( this._precision() ) );
  },

  _precision: function() {
    var precision = this._precisionOf( this.options.step );
    if ( this.options.min !== null ) {
      precision = Math.max( precision, this._precisionOf( this.options.min ) );
    }
    return precision;
  },

  _precisionOf: function( num ) {
    var str = num.toString(),
      decimal = str.indexOf( "." );
    return decimal === -1 ? 0 : str.length - decimal - 1;
  },

  _valueMin: function() {
    return this.options.min;
  },

  _valueMax: function() {
    return this.max;
  },

  _refreshRange: function( orientation ) {
    if ( orientation === "vertical" ) {
      this.range.css( { "width": "", "left": "" } );
    }
    if ( orientation === "horizontal" ) {
      this.range.css( { "height": "", "bottom": "" } );
    }
  },

  _refreshValue: function() {
    var lastValPercent, valPercent, value, valueMin, valueMax,
      oRange = this.options.range,
      o = this.options,
      that = this,
      animate = ( !this._animateOff ) ? o.animate : false,
      _set = {};

    if ( this._hasMultipleValues() ) {
      this.handles.each( function( i ) {
        valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
          that._valueMin() ) * 100;
        _set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
        $( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
        if ( that.options.range === true ) {
          if ( that.orientation === "horizontal" ) {
            if ( i === 0 ) {
              that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                left: valPercent + "%"
              }, o.animate );
            }
            if ( i === 1 ) {
              that.range[ animate ? "animate" : "css" ]( {
                width: ( valPercent - lastValPercent ) + "%"
              }, {
                queue: false,
                duration: o.animate
              } );
            }
          } else {
            if ( i === 0 ) {
              that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
                bottom: ( valPercent ) + "%"
              }, o.animate );
            }
            if ( i === 1 ) {
              that.range[ animate ? "animate" : "css" ]( {
                height: ( valPercent - lastValPercent ) + "%"
              }, {
                queue: false,
                duration: o.animate
              } );
            }
          }
        }
        lastValPercent = valPercent;
      } );
    } else {
      value = this.value();
      valueMin = this._valueMin();
      valueMax = this._valueMax();
      valPercent = ( valueMax !== valueMin ) ?
          ( value - valueMin ) / ( valueMax - valueMin ) * 100 :
          0;
      _set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
      this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

      if ( oRange === "min" && this.orientation === "horizontal" ) {
        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
          width: valPercent + "%"
        }, o.animate );
      }
      if ( oRange === "max" && this.orientation === "horizontal" ) {
        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
          width: ( 100 - valPercent ) + "%"
        }, o.animate );
      }
      if ( oRange === "min" && this.orientation === "vertical" ) {
        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
          height: valPercent + "%"
        }, o.animate );
      }
      if ( oRange === "max" && this.orientation === "vertical" ) {
        this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
          height: ( 100 - valPercent ) + "%"
        }, o.animate );
      }
    }
  },

  _handleEvents: {
    keydown: function( event ) {
      var allowed, curVal, newVal, step,
        index = $( event.target ).data( "ui-slider-handle-index" );

      switch ( event.keyCode ) {
        case $.ui.keyCode.HOME:
        case $.ui.keyCode.END:
        case $.ui.keyCode.PAGE_UP:
        case $.ui.keyCode.PAGE_DOWN:
        case $.ui.keyCode.UP:
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
        case $.ui.keyCode.LEFT:
          event.preventDefault();
          if ( !this._keySliding ) {
            this._keySliding = true;
            this._addClass( $( event.target ), null, "ui-state-active" );
            allowed = this._start( event, index );
            if ( allowed === false ) {
              return;
            }
          }
          break;
      }

      step = this.options.step;
      if ( this._hasMultipleValues() ) {
        curVal = newVal = this.values( index );
      } else {
        curVal = newVal = this.value();
      }

      switch ( event.keyCode ) {
        case $.ui.keyCode.HOME:
          newVal = this._valueMin();
          break;
        case $.ui.keyCode.END:
          newVal = this._valueMax();
          break;
        case $.ui.keyCode.PAGE_UP:
          newVal = this._trimAlignValue(
            curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
          );
          break;
        case $.ui.keyCode.PAGE_DOWN:
          newVal = this._trimAlignValue(
            curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.RIGHT:
          if ( curVal === this._valueMax() ) {
            return;
          }
          newVal = this._trimAlignValue( curVal + step );
          break;
        case $.ui.keyCode.DOWN:
        case $.ui.keyCode.LEFT:
          if ( curVal === this._valueMin() ) {
            return;
          }
          newVal = this._trimAlignValue( curVal - step );
          break;
      }

      this._slide( event, index, newVal );
    },
    keyup: function( event ) {
      var index = $( event.target ).data( "ui-slider-handle-index" );

      if ( this._keySliding ) {
        this._keySliding = false;
        this._stop( event, index );
        this._change( event, index );
        this._removeClass( $( event.target ), null, "ui-state-active" );
      }
    }
  }
} );


/*!
 * jQuery UI Sortable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Sortable
//>>group: Interactions
//>>description: Enables items in a list to be sorted using the mouse.
//>>docs: http://api.jqueryui.com/sortable/
//>>demos: http://jqueryui.com/sortable/
//>>css.structure: ../../themes/base/sortable.css



var widgetsSortable = $.widget( "ui.sortable", $.ui.mouse, {
  version: "1.12.1",
  widgetEventPrefix: "sort",
  ready: false,
  options: {
    appendTo: "parent",
    axis: false,
    connectWith: false,
    containment: false,
    cursor: "auto",
    cursorAt: false,
    dropOnEmpty: true,
    forcePlaceholderSize: false,
    forceHelperSize: false,
    grid: false,
    handle: false,
    helper: "original",
    items: "> *",
    opacity: false,
    placeholder: false,
    revert: false,
    scroll: true,
    scrollSensitivity: 20,
    scrollSpeed: 20,
    scope: "default",
    tolerance: "intersect",
    zIndex: 1000,

    // Callbacks
    activate: null,
    beforeStop: null,
    change: null,
    deactivate: null,
    out: null,
    over: null,
    receive: null,
    remove: null,
    sort: null,
    start: null,
    stop: null,
    update: null
  },

  _isOverAxis: function( x, reference, size ) {
    return ( x >= reference ) && ( x < ( reference + size ) );
  },

  _isFloating: function( item ) {
    return ( /left|right/ ).test( item.css( "float" ) ) ||
      ( /inline|table-cell/ ).test( item.css( "display" ) );
  },

  _create: function() {
    this.containerCache = {};
    this._addClass( "ui-sortable" );

    //Get the items
    this.refresh();

    //Let's determine the parent's offset
    this.offset = this.element.offset();

    //Initialize mouse events for interaction
    this._mouseInit();

    this._setHandleClassName();

    //We're ready to go
    this.ready = true;

  },

  _setOption: function( key, value ) {
    this._super( key, value );

    if ( key === "handle" ) {
      this._setHandleClassName();
    }
  },

  _setHandleClassName: function() {
    var that = this;
    this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );
    $.each( this.items, function() {
      that._addClass(
        this.instance.options.handle ?
          this.item.find( this.instance.options.handle ) :
          this.item,
        "ui-sortable-handle"
      );
    } );
  },

  _destroy: function() {
    this._mouseDestroy();

    for ( var i = this.items.length - 1; i >= 0; i-- ) {
      this.items[ i ].item.removeData( this.widgetName + "-item" );
    }

    return this;
  },

  _mouseCapture: function( event, overrideHandle ) {
    var currentItem = null,
      validHandle = false,
      that = this;

    if ( this.reverting ) {
      return false;
    }

    if ( this.options.disabled || this.options.type === "static" ) {
      return false;
    }

    //We have to refresh the items data once first
    this._refreshItems( event );

    //Find out if the clicked node (or one of its parents) is a actual item in this.items
    $( event.target ).parents().each( function() {
      if ( $.data( this, that.widgetName + "-item" ) === that ) {
        currentItem = $( this );
        return false;
      }
    } );
    if ( $.data( event.target, that.widgetName + "-item" ) === that ) {
      currentItem = $( event.target );
    }

    if ( !currentItem ) {
      return false;
    }
    if ( this.options.handle && !overrideHandle ) {
      $( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {
        if ( this === event.target ) {
          validHandle = true;
        }
      } );
      if ( !validHandle ) {
        return false;
      }
    }

    this.currentItem = currentItem;
    this._removeCurrentsFromItems();
    return true;

  },

  _mouseStart: function( event, overrideHandle, noActivation ) {

    var i, body,
      o = this.options;

    this.currentContainer = this;

    //We only need to call refreshPositions, because the refreshItems call has been moved to
    // mouseCapture
    this.refreshPositions();

    //Create and append the visible helper
    this.helper = this._createHelper( event );

    //Cache the helper size
    this._cacheHelperProportions();

    /*
     * - Position generation -
     * This block generates everything position related - it's the core of draggables.
     */

    //Cache the margins of the original element
    this._cacheMargins();

    //Get the next scrolling parent
    this.scrollParent = this.helper.scrollParent();

    //The element's absolute position on the page minus margins
    this.offset = this.currentItem.offset();
    this.offset = {
      top: this.offset.top - this.margins.top,
      left: this.offset.left - this.margins.left
    };

    $.extend( this.offset, {
      click: { //Where the click happened, relative to the element
        left: event.pageX - this.offset.left,
        top: event.pageY - this.offset.top
      },
      parent: this._getParentOffset(),

      // This is a relative to absolute position minus the actual position calculation -
      // only used for relative positioned helper
      relative: this._getRelativeOffset()
    } );

    // Only after we got the offset, we can change the helper's position to absolute
    // TODO: Still need to figure out a way to make relative sorting possible
    this.helper.css( "position", "absolute" );
    this.cssPosition = this.helper.css( "position" );

    //Generate the original position
    this.originalPosition = this._generatePosition( event );
    this.originalPageX = event.pageX;
    this.originalPageY = event.pageY;

    //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
    ( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

    //Cache the former DOM position
    this.domPosition = {
      prev: this.currentItem.prev()[ 0 ],
      parent: this.currentItem.parent()[ 0 ]
    };

    // If the helper is not the original, hide the original so it's not playing any role during
    // the drag, won't cause anything bad this way
    if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
      this.currentItem.hide();
    }

    //Create the placeholder
    this._createPlaceholder();

    //Set a containment if given in the options
    if ( o.containment ) {
      this._setContainment();
    }

    if ( o.cursor && o.cursor !== "auto" ) { // cursor option
      body = this.document.find( "body" );

      // Support: IE
      this.storedCursor = body.css( "cursor" );
      body.css( "cursor", o.cursor );

      this.storedStylesheet =
        $( "<style>*{ cursor: " + o.cursor + " !important; }</style>" ).appendTo( body );
    }

    if ( o.opacity ) { // opacity option
      if ( this.helper.css( "opacity" ) ) {
        this._storedOpacity = this.helper.css( "opacity" );
      }
      this.helper.css( "opacity", o.opacity );
    }

    if ( o.zIndex ) { // zIndex option
      if ( this.helper.css( "zIndex" ) ) {
        this._storedZIndex = this.helper.css( "zIndex" );
      }
      this.helper.css( "zIndex", o.zIndex );
    }

    //Prepare scrolling
    if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
        this.scrollParent[ 0 ].tagName !== "HTML" ) {
      this.overflowOffset = this.scrollParent.offset();
    }

    //Call callbacks
    this._trigger( "start", event, this._uiHash() );

    //Recache the helper size
    if ( !this._preserveHelperProportions ) {
      this._cacheHelperProportions();
    }

    //Post "activate" events to possible containers
    if ( !noActivation ) {
      for ( i = this.containers.length - 1; i >= 0; i-- ) {
        this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
      }
    }

    //Prepare possible droppables
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.current = this;
    }

    if ( $.ui.ddmanager && !o.dropBehaviour ) {
      $.ui.ddmanager.prepareOffsets( this, event );
    }

    this.dragging = true;

    this._addClass( this.helper, "ui-sortable-helper" );

    // Execute the drag once - this causes the helper not to be visiblebefore getting its
    // correct position
    this._mouseDrag( event );
    return true;

  },

  _mouseDrag: function( event ) {
    var i, item, itemElement, intersection,
      o = this.options,
      scrolled = false;

    //Compute the helpers position
    this.position = this._generatePosition( event );
    this.positionAbs = this._convertPositionTo( "absolute" );

    if ( !this.lastPositionAbs ) {
      this.lastPositionAbs = this.positionAbs;
    }

    //Do scrolling
    if ( this.options.scroll ) {
      if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
          this.scrollParent[ 0 ].tagName !== "HTML" ) {

        if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
            event.pageY < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollTop =
            scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
        } else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollTop =
            scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
        }

        if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
            event.pageX < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollLeft = scrolled =
            this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
        } else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {
          this.scrollParent[ 0 ].scrollLeft = scrolled =
            this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
        }

      } else {

        if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {
          scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
        } else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <
            o.scrollSensitivity ) {
          scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
        }

        if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {
          scrolled = this.document.scrollLeft(
            this.document.scrollLeft() - o.scrollSpeed
          );
        } else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <
            o.scrollSensitivity ) {
          scrolled = this.document.scrollLeft(
            this.document.scrollLeft() + o.scrollSpeed
          );
        }

      }

      if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
        $.ui.ddmanager.prepareOffsets( this, event );
      }
    }

    //Regenerate the absolute position used for position checks
    this.positionAbs = this._convertPositionTo( "absolute" );

    //Set the helper position
    if ( !this.options.axis || this.options.axis !== "y" ) {
      this.helper[ 0 ].style.left = this.position.left + "px";
    }
    if ( !this.options.axis || this.options.axis !== "x" ) {
      this.helper[ 0 ].style.top = this.position.top + "px";
    }

    //Rearrange
    for ( i = this.items.length - 1; i >= 0; i-- ) {

      //Cache variables and intersection, continue if no intersection
      item = this.items[ i ];
      itemElement = item.item[ 0 ];
      intersection = this._intersectsWithPointer( item );
      if ( !intersection ) {
        continue;
      }

      // Only put the placeholder inside the current Container, skip all
      // items from other containers. This works because when moving
      // an item from one container to another the
      // currentContainer is switched before the placeholder is moved.
      //
      // Without this, moving items in "sub-sortables" can cause
      // the placeholder to jitter between the outer and inner container.
      if ( item.instance !== this.currentContainer ) {
        continue;
      }

      // Cannot intersect with itself
      // no useless actions that have been done before
      // no action if the item moved is the parent of the item checked
      if ( itemElement !== this.currentItem[ 0 ] &&
        this.placeholder[ intersection === 1 ? "next" : "prev" ]()[ 0 ] !== itemElement &&
        !$.contains( this.placeholder[ 0 ], itemElement ) &&
        ( this.options.type === "semi-dynamic" ?
          !$.contains( this.element[ 0 ], itemElement ) :
          true
        )
      ) {

        this.direction = intersection === 1 ? "down" : "up";

        if ( this.options.tolerance === "pointer" || this._intersectsWithSides( item ) ) {
          this._rearrange( event, item );
        } else {
          break;
        }

        this._trigger( "change", event, this._uiHash() );
        break;
      }
    }

    //Post events to containers
    this._contactContainers( event );

    //Interconnect with droppables
    if ( $.ui.ddmanager ) {
      $.ui.ddmanager.drag( this, event );
    }

    //Call callbacks
    this._trigger( "sort", event, this._uiHash() );

    this.lastPositionAbs = this.positionAbs;
    return false;

  },

  _mouseStop: function( event, noPropagation ) {

    if ( !event ) {
      return;
    }

    //If we are using droppables, inform the manager about the drop
    if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
      $.ui.ddmanager.drop( this, event );
    }

    if ( this.options.revert ) {
      var that = this,
        cur = this.placeholder.offset(),
        axis = this.options.axis,
        animation = {};

      if ( !axis || axis === "x" ) {
        animation.left = cur.left - this.offset.parent.left - this.margins.left +
          ( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
            0 :
            this.offsetParent[ 0 ].scrollLeft
          );
      }
      if ( !axis || axis === "y" ) {
        animation.top = cur.top - this.offset.parent.top - this.margins.top +
          ( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
            0 :
            this.offsetParent[ 0 ].scrollTop
          );
      }
      this.reverting = true;
      $( this.helper ).animate(
        animation,
        parseInt( this.options.revert, 10 ) || 500,
        function() {
          that._clear( event );
        }
      );
    } else {
      this._clear( event, noPropagation );
    }

    return false;

  },

  cancel: function() {

    if ( this.dragging ) {

      this._mouseUp( new $.Event( "mouseup", { target: null } ) );

      if ( this.options.helper === "original" ) {
        this.currentItem.css( this._storedCSS );
        this._removeClass( this.currentItem, "ui-sortable-helper" );
      } else {
        this.currentItem.show();
      }

      //Post deactivating events to containers
      for ( var i = this.containers.length - 1; i >= 0; i-- ) {
        this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );
        if ( this.containers[ i ].containerCache.over ) {
          this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );
          this.containers[ i ].containerCache.over = 0;
        }
      }

    }

    if ( this.placeholder ) {

      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
      // it unbinds ALL events from the original node!
      if ( this.placeholder[ 0 ].parentNode ) {
        this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
      }
      if ( this.options.helper !== "original" && this.helper &&
          this.helper[ 0 ].parentNode ) {
        this.helper.remove();
      }

      $.extend( this, {
        helper: null,
        dragging: false,
        reverting: false,
        _noFinalSort: null
      } );

      if ( this.domPosition.prev ) {
        $( this.domPosition.prev ).after( this.currentItem );
      } else {
        $( this.domPosition.parent ).prepend( this.currentItem );
      }
    }

    return this;

  },

  serialize: function( o ) {

    var items = this._getItemsAsjQuery( o && o.connected ),
      str = [];
    o = o || {};

    $( items ).each( function() {
      var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )
        .match( o.expression || ( /(.+)[\-=_](.+)/ ) );
      if ( res ) {
        str.push(
          ( o.key || res[ 1 ] + "[]" ) +
          "=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );
      }
    } );

    if ( !str.length && o.key ) {
      str.push( o.key + "=" );
    }

    return str.join( "&" );

  },

  toArray: function( o ) {

    var items = this._getItemsAsjQuery( o && o.connected ),
      ret = [];

    o = o || {};

    items.each( function() {
      ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );
    } );
    return ret;

  },

  /* Be careful with the following core functions */
  _intersectsWith: function( item ) {

    var x1 = this.positionAbs.left,
      x2 = x1 + this.helperProportions.width,
      y1 = this.positionAbs.top,
      y2 = y1 + this.helperProportions.height,
      l = item.left,
      r = l + item.width,
      t = item.top,
      b = t + item.height,
      dyClick = this.offset.click.top,
      dxClick = this.offset.click.left,
      isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&
        ( y1 + dyClick ) < b ),
      isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&
        ( x1 + dxClick ) < r ),
      isOverElement = isOverElementHeight && isOverElementWidth;

    if ( this.options.tolerance === "pointer" ||
      this.options.forcePointerForContainers ||
      ( this.options.tolerance !== "pointer" &&
        this.helperProportions[ this.floating ? "width" : "height" ] >
        item[ this.floating ? "width" : "height" ] )
    ) {
      return isOverElement;
    } else {

      return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half
        x2 - ( this.helperProportions.width / 2 ) < r && // Left Half
        t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half
        y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half

    }
  },

  _intersectsWithPointer: function( item ) {
    var verticalDirection, horizontalDirection,
      isOverElementHeight = ( this.options.axis === "x" ) ||
        this._isOverAxis(
          this.positionAbs.top + this.offset.click.top, item.top, item.height ),
      isOverElementWidth = ( this.options.axis === "y" ) ||
        this._isOverAxis(
          this.positionAbs.left + this.offset.click.left, item.left, item.width ),
      isOverElement = isOverElementHeight && isOverElementWidth;

    if ( !isOverElement ) {
      return false;
    }

    verticalDirection = this._getDragVerticalDirection();
    horizontalDirection = this._getDragHorizontalDirection();

    return this.floating ?
      ( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 )
      : ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );

  },

  _intersectsWithSides: function( item ) {

    var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
        this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
      isOverRightHalf = this._isOverAxis( this.positionAbs.left +
        this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
      verticalDirection = this._getDragVerticalDirection(),
      horizontalDirection = this._getDragHorizontalDirection();

    if ( this.floating && horizontalDirection ) {
      return ( ( horizontalDirection === "right" && isOverRightHalf ) ||
        ( horizontalDirection === "left" && !isOverRightHalf ) );
    } else {
      return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||
        ( verticalDirection === "up" && !isOverBottomHalf ) );
    }

  },

  _getDragVerticalDirection: function() {
    var delta = this.positionAbs.top - this.lastPositionAbs.top;
    return delta !== 0 && ( delta > 0 ? "down" : "up" );
  },

  _getDragHorizontalDirection: function() {
    var delta = this.positionAbs.left - this.lastPositionAbs.left;
    return delta !== 0 && ( delta > 0 ? "right" : "left" );
  },

  refresh: function( event ) {
    this._refreshItems( event );
    this._setHandleClassName();
    this.refreshPositions();
    return this;
  },

  _connectWith: function() {
    var options = this.options;
    return options.connectWith.constructor === String ?
      [ options.connectWith ] :
      options.connectWith;
  },

  _getItemsAsjQuery: function( connected ) {

    var i, j, cur, inst,
      items = [],
      queries = [],
      connectWith = this._connectWith();

    if ( connectWith && connected ) {
      for ( i = connectWith.length - 1; i >= 0; i-- ) {
        cur = $( connectWith[ i ], this.document[ 0 ] );
        for ( j = cur.length - 1; j >= 0; j-- ) {
          inst = $.data( cur[ j ], this.widgetFullName );
          if ( inst && inst !== this && !inst.options.disabled ) {
            queries.push( [ $.isFunction( inst.options.items ) ?
              inst.options.items.call( inst.element ) :
              $( inst.options.items, inst.element )
                .not( ".ui-sortable-helper" )
                .not( ".ui-sortable-placeholder" ), inst ] );
          }
        }
      }
    }

    queries.push( [ $.isFunction( this.options.items ) ?
      this.options.items
        .call( this.element, null, { options: this.options, item: this.currentItem } ) :
      $( this.options.items, this.element )
        .not( ".ui-sortable-helper" )
        .not( ".ui-sortable-placeholder" ), this ] );

    function addItems() {
      items.push( this );
    }
    for ( i = queries.length - 1; i >= 0; i-- ) {
      queries[ i ][ 0 ].each( addItems );
    }

    return $( items );

  },

  _removeCurrentsFromItems: function() {

    var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );

    this.items = $.grep( this.items, function( item ) {
      for ( var j = 0; j < list.length; j++ ) {
        if ( list[ j ] === item.item[ 0 ] ) {
          return false;
        }
      }
      return true;
    } );

  },

  _refreshItems: function( event ) {

    this.items = [];
    this.containers = [ this ];

    var i, j, cur, inst, targetData, _queries, item, queriesLength,
      items = this.items,
      queries = [ [ $.isFunction( this.options.items ) ?
        this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
        $( this.options.items, this.element ), this ] ],
      connectWith = this._connectWith();

    //Shouldn't be run the first time through due to massive slow-down
    if ( connectWith && this.ready ) {
      for ( i = connectWith.length - 1; i >= 0; i-- ) {
        cur = $( connectWith[ i ], this.document[ 0 ] );
        for ( j = cur.length - 1; j >= 0; j-- ) {
          inst = $.data( cur[ j ], this.widgetFullName );
          if ( inst && inst !== this && !inst.options.disabled ) {
            queries.push( [ $.isFunction( inst.options.items ) ?
              inst.options.items
                .call( inst.element[ 0 ], event, { item: this.currentItem } ) :
              $( inst.options.items, inst.element ), inst ] );
            this.containers.push( inst );
          }
        }
      }
    }

    for ( i = queries.length - 1; i >= 0; i-- ) {
      targetData = queries[ i ][ 1 ];
      _queries = queries[ i ][ 0 ];

      for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {
        item = $( _queries[ j ] );

        // Data for target checking (mouse manager)
        item.data( this.widgetName + "-item", targetData );

        items.push( {
          item: item,
          instance: targetData,
          width: 0, height: 0,
          left: 0, top: 0
        } );
      }
    }

  },

  refreshPositions: function( fast ) {

    // Determine whether items are being displayed horizontally
    this.floating = this.items.length ?
      this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
      false;

    //This has to be redone because due to the item being moved out/into the offsetParent,
    // the offsetParent's position will change
    if ( this.offsetParent && this.helper ) {
      this.offset.parent = this._getParentOffset();
    }

    var i, item, t, p;

    for ( i = this.items.length - 1; i >= 0; i-- ) {
      item = this.items[ i ];

      //We ignore calculating positions of all connected containers when we're not over them
      if ( item.instance !== this.currentContainer && this.currentContainer &&
          item.item[ 0 ] !== this.currentItem[ 0 ] ) {
        continue;
      }

      t = this.options.toleranceElement ?
        $( this.options.toleranceElement, item.item ) :
        item.item;

      if ( !fast ) {
        item.width = t.outerWidth();
        item.height = t.outerHeight();
      }

      p = t.offset();
      item.left = p.left;
      item.top = p.top;
    }

    if ( this.options.custom && this.options.custom.refreshContainers ) {
      this.options.custom.refreshContainers.call( this );
    } else {
      for ( i = this.containers.length - 1; i >= 0; i-- ) {
        p = this.containers[ i ].element.offset();
        this.containers[ i ].containerCache.left = p.left;
        this.containers[ i ].containerCache.top = p.top;
        this.containers[ i ].containerCache.width =
          this.containers[ i ].element.outerWidth();
        this.containers[ i ].containerCache.height =
          this.containers[ i ].element.outerHeight();
      }
    }

    return this;
  },

  _createPlaceholder: function( that ) {
    that = that || this;
    var className,
      o = that.options;

    if ( !o.placeholder || o.placeholder.constructor === String ) {
      className = o.placeholder;
      o.placeholder = {
        element: function() {

          var nodeName = that.currentItem[ 0 ].nodeName.toLowerCase(),
            element = $( "<" + nodeName + ">", that.document[ 0 ] );

            that._addClass( element, "ui-sortable-placeholder",
                className || that.currentItem[ 0 ].className )
              ._removeClass( element, "ui-sortable-helper" );

          if ( nodeName === "tbody" ) {
            that._createTrPlaceholder(
              that.currentItem.find( "tr" ).eq( 0 ),
              $( "<tr>", that.document[ 0 ] ).appendTo( element )
            );
          } else if ( nodeName === "tr" ) {
            that._createTrPlaceholder( that.currentItem, element );
          } else if ( nodeName === "img" ) {
            element.attr( "src", that.currentItem.attr( "src" ) );
          }

          if ( !className ) {
            element.css( "visibility", "hidden" );
          }

          return element;
        },
        update: function( container, p ) {

          // 1. If a className is set as 'placeholder option, we don't force sizes -
          // the class is responsible for that
          // 2. The option 'forcePlaceholderSize can be enabled to force it even if a
          // class name is specified
          if ( className && !o.forcePlaceholderSize ) {
            return;
          }

          //If the element doesn't have a actual height by itself (without styles coming
          // from a stylesheet), it receives the inline height from the dragged item
          if ( !p.height() ) {
            p.height(
              that.currentItem.innerHeight() -
              parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -
              parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );
          }
          if ( !p.width() ) {
            p.width(
              that.currentItem.innerWidth() -
              parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -
              parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );
          }
        }
      };
    }

    //Create the placeholder
    that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );

    //Append it after the actual current item
    that.currentItem.after( that.placeholder );

    //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
    o.placeholder.update( that, that.placeholder );

  },

  _createTrPlaceholder: function( sourceTr, targetTr ) {
    var that = this;

    sourceTr.children().each( function() {
      $( "<td>&#160;</td>", that.document[ 0 ] )
        .attr( "colspan", $( this ).attr( "colspan" ) || 1 )
        .appendTo( targetTr );
    } );
  },

  _contactContainers: function( event ) {
    var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
      floating, axis,
      innermostContainer = null,
      innermostIndex = null;

    // Get innermost container that intersects with item
    for ( i = this.containers.length - 1; i >= 0; i-- ) {

      // Never consider a container that's located within the item itself
      if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
        continue;
      }

      if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {

        // If we've already found a container and it's more "inner" than this, then continue
        if ( innermostContainer &&
            $.contains(
              this.containers[ i ].element[ 0 ],
              innermostContainer.element[ 0 ] ) ) {
          continue;
        }

        innermostContainer = this.containers[ i ];
        innermostIndex = i;

      } else {

        // container doesn't intersect. trigger "out" event if necessary
        if ( this.containers[ i ].containerCache.over ) {
          this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );
          this.containers[ i ].containerCache.over = 0;
        }
      }

    }

    // If no intersecting containers found, return
    if ( !innermostContainer ) {
      return;
    }

    // Move the item into the container if it's not there already
    if ( this.containers.length === 1 ) {
      if ( !this.containers[ innermostIndex ].containerCache.over ) {
        this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
        this.containers[ innermostIndex ].containerCache.over = 1;
      }
    } else {

      // When entering a new container, we will find the item with the least distance and
      // append our item near it
      dist = 10000;
      itemWithLeastDistance = null;
      floating = innermostContainer.floating || this._isFloating( this.currentItem );
      posProperty = floating ? "left" : "top";
      sizeProperty = floating ? "width" : "height";
      axis = floating ? "pageX" : "pageY";

      for ( j = this.items.length - 1; j >= 0; j-- ) {
        if ( !$.contains(
            this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
        ) {
          continue;
        }
        if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
          continue;
        }

        cur = this.items[ j ].item.offset()[ posProperty ];
        nearBottom = false;
        if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
          nearBottom = true;
        }

        if ( Math.abs( event[ axis ] - cur ) < dist ) {
          dist = Math.abs( event[ axis ] - cur );
          itemWithLeastDistance = this.items[ j ];
          this.direction = nearBottom ? "up" : "down";
        }
      }

      //Check if dropOnEmpty is enabled
      if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) {
        return;
      }

      if ( this.currentContainer === this.containers[ innermostIndex ] ) {
        if ( !this.currentContainer.containerCache.over ) {
          this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
          this.currentContainer.containerCache.over = 1;
        }
        return;
      }

      itemWithLeastDistance ?
        this._rearrange( event, itemWithLeastDistance, null, true ) :
        this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
      this._trigger( "change", event, this._uiHash() );
      this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );
      this.currentContainer = this.containers[ innermostIndex ];

      //Update the placeholder
      this.options.placeholder.update( this.currentContainer, this.placeholder );

      this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
      this.containers[ innermostIndex ].containerCache.over = 1;
    }

  },

  _createHelper: function( event ) {

    var o = this.options,
      helper = $.isFunction( o.helper ) ?
        $( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
        ( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );

    //Add the helper to the DOM if that didn't happen already
    if ( !helper.parents( "body" ).length ) {
      $( o.appendTo !== "parent" ?
        o.appendTo :
        this.currentItem[ 0 ].parentNode )[ 0 ].appendChild( helper[ 0 ] );
    }

    if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
      this._storedCSS = {
        width: this.currentItem[ 0 ].style.width,
        height: this.currentItem[ 0 ].style.height,
        position: this.currentItem.css( "position" ),
        top: this.currentItem.css( "top" ),
        left: this.currentItem.css( "left" )
      };
    }

    if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
      helper.width( this.currentItem.width() );
    }
    if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
      helper.height( this.currentItem.height() );
    }

    return helper;

  },

  _adjustOffsetFromHelper: function( obj ) {
    if ( typeof obj === "string" ) {
      obj = obj.split( " " );
    }
    if ( $.isArray( obj ) ) {
      obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
    }
    if ( "left" in obj ) {
      this.offset.click.left = obj.left + this.margins.left;
    }
    if ( "right" in obj ) {
      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
    }
    if ( "top" in obj ) {
      this.offset.click.top = obj.top + this.margins.top;
    }
    if ( "bottom" in obj ) {
      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
    }
  },

  _getParentOffset: function() {

    //Get the offsetParent and cache its position
    this.offsetParent = this.helper.offsetParent();
    var po = this.offsetParent.offset();

    // This is a special case where we need to modify a offset calculated on start, since the
    // following happened:
    // 1. The position of the helper is absolute, so it's position is calculated based on the
    // next positioned parent
    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
    // the document, which means that the scroll is included in the initial calculation of the
    // offset of the parent, and never recalculated upon drag
    if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] &&
        $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
      po.left += this.scrollParent.scrollLeft();
      po.top += this.scrollParent.scrollTop();
    }

    // This needs to be actually done for all browsers, since pageX/pageY includes this
    // information with an ugly IE fix
    if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||
        ( this.offsetParent[ 0 ].tagName &&
        this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {
      po = { top: 0, left: 0 };
    }

    return {
      top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
      left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
    };

  },

  _getRelativeOffset: function() {

    if ( this.cssPosition === "relative" ) {
      var p = this.currentItem.position();
      return {
        top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
          this.scrollParent.scrollTop(),
        left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
          this.scrollParent.scrollLeft()
      };
    } else {
      return { top: 0, left: 0 };
    }

  },

  _cacheMargins: function() {
    this.margins = {
      left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),
      top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )
    };
  },

  _cacheHelperProportions: function() {
    this.helperProportions = {
      width: this.helper.outerWidth(),
      height: this.helper.outerHeight()
    };
  },

  _setContainment: function() {

    var ce, co, over,
      o = this.options;
    if ( o.containment === "parent" ) {
      o.containment = this.helper[ 0 ].parentNode;
    }
    if ( o.containment === "document" || o.containment === "window" ) {
      this.containment = [
        0 - this.offset.relative.left - this.offset.parent.left,
        0 - this.offset.relative.top - this.offset.parent.top,
        o.containment === "document" ?
          this.document.width() :
          this.window.width() - this.helperProportions.width - this.margins.left,
        ( o.containment === "document" ?
          ( this.document.height() || document.body.parentNode.scrollHeight ) :
          this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
        ) - this.helperProportions.height - this.margins.top
      ];
    }

    if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
      ce = $( o.containment )[ 0 ];
      co = $( o.containment ).offset();
      over = ( $( ce ).css( "overflow" ) !== "hidden" );

      this.containment = [
        co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +
          ( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,
        co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +
          ( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,
        co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
          ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -
          ( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -
          this.helperProportions.width - this.margins.left,
        co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
          ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -
          ( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -
          this.helperProportions.height - this.margins.top
      ];
    }

  },

  _convertPositionTo: function( d, pos ) {

    if ( !pos ) {
      pos = this.position;
    }
    var mod = d === "absolute" ? 1 : -1,
      scroll = this.cssPosition === "absolute" &&
        !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
        $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
          this.offsetParent :
          this.scrollParent,
      scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

    return {
      top: (

        // The absolute mouse position
        pos.top +

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.top * mod +

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.top * mod -
        ( ( this.cssPosition === "fixed" ?
          -this.scrollParent.scrollTop() :
          ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
      ),
      left: (

        // The absolute mouse position
        pos.left +

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.left * mod +

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.left * mod -
        ( ( this.cssPosition === "fixed" ?
          -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
          scroll.scrollLeft() ) * mod )
      )
    };

  },

  _generatePosition: function( event ) {

    var top, left,
      o = this.options,
      pageX = event.pageX,
      pageY = event.pageY,
      scroll = this.cssPosition === "absolute" &&
        !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
        $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
          this.offsetParent :
          this.scrollParent,
        scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

    // This is another very weird special case that only happens for relative elements:
    // 1. If the css position is relative
    // 2. and the scroll parent is the document or similar to the offset parent
    // we have to refresh the relative offset during the scroll so there are no jumps
    if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
        this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
      this.offset.relative = this._getRelativeOffset();
    }

    /*
     * - Position constraining -
     * Constrain the position to a mix of grid, containment.
     */

    if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options

      if ( this.containment ) {
        if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {
          pageX = this.containment[ 0 ] + this.offset.click.left;
        }
        if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {
          pageY = this.containment[ 1 ] + this.offset.click.top;
        }
        if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {
          pageX = this.containment[ 2 ] + this.offset.click.left;
        }
        if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {
          pageY = this.containment[ 3 ] + this.offset.click.top;
        }
      }

      if ( o.grid ) {
        top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
          o.grid[ 1 ] ) * o.grid[ 1 ];
        pageY = this.containment ?
          ( ( top - this.offset.click.top >= this.containment[ 1 ] &&
            top - this.offset.click.top <= this.containment[ 3 ] ) ?
              top :
              ( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?
                top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
                top;

        left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
          o.grid[ 0 ] ) * o.grid[ 0 ];
        pageX = this.containment ?
          ( ( left - this.offset.click.left >= this.containment[ 0 ] &&
            left - this.offset.click.left <= this.containment[ 2 ] ) ?
              left :
              ( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?
                left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
                left;
      }

    }

    return {
      top: (

        // The absolute mouse position
        pageY -

        // Click offset (relative to the element)
        this.offset.click.top -

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.top -

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.top +
        ( ( this.cssPosition === "fixed" ?
          -this.scrollParent.scrollTop() :
          ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
      ),
      left: (

        // The absolute mouse position
        pageX -

        // Click offset (relative to the element)
        this.offset.click.left -

        // Only for relative positioned nodes: Relative offset from element to offset parent
        this.offset.relative.left -

        // The offsetParent's offset without borders (offset + border)
        this.offset.parent.left +
        ( ( this.cssPosition === "fixed" ?
          -this.scrollParent.scrollLeft() :
          scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
      )
    };

  },

  _rearrange: function( event, i, a, hardRefresh ) {

    a ? a[ 0 ].appendChild( this.placeholder[ 0 ] ) :
      i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
        ( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );

    //Various things done here to improve the performance:
    // 1. we create a setTimeout, that calls refreshPositions
    // 2. on the instance, we have a counter variable, that get's higher after every append
    // 3. on the local scope, we copy the counter variable, and check in the timeout,
    // if it's still the same
    // 4. this lets only the last addition to the timeout stack through
    this.counter = this.counter ? ++this.counter : 1;
    var counter = this.counter;

    this._delay( function() {
      if ( counter === this.counter ) {

        //Precompute after each DOM insertion, NOT on mousemove
        this.refreshPositions( !hardRefresh );
      }
    } );

  },

  _clear: function( event, noPropagation ) {

    this.reverting = false;

    // We delay all events that have to be triggered to after the point where the placeholder
    // has been removed and everything else normalized again
    var i,
      delayedTriggers = [];

    // We first have to update the dom position of the actual currentItem
    // Note: don't do it if the current item is already removed (by a user), or it gets
    // reappended (see #4088)
    if ( !this._noFinalSort && this.currentItem.parent().length ) {
      this.placeholder.before( this.currentItem );
    }
    this._noFinalSort = null;

    if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
      for ( i in this._storedCSS ) {
        if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {
          this._storedCSS[ i ] = "";
        }
      }
      this.currentItem.css( this._storedCSS );
      this._removeClass( this.currentItem, "ui-sortable-helper" );
    } else {
      this.currentItem.show();
    }

    if ( this.fromOutside && !noPropagation ) {
      delayedTriggers.push( function( event ) {
        this._trigger( "receive", event, this._uiHash( this.fromOutside ) );
      } );
    }
    if ( ( this.fromOutside ||
        this.domPosition.prev !==
        this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||
        this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) {

      // Trigger update callback if the DOM position has changed
      delayedTriggers.push( function( event ) {
        this._trigger( "update", event, this._uiHash() );
      } );
    }

    // Check if the items Container has Changed and trigger appropriate
    // events.
    if ( this !== this.currentContainer ) {
      if ( !noPropagation ) {
        delayedTriggers.push( function( event ) {
          this._trigger( "remove", event, this._uiHash() );
        } );
        delayedTriggers.push( ( function( c ) {
          return function( event ) {
            c._trigger( "receive", event, this._uiHash( this ) );
          };
        } ).call( this, this.currentContainer ) );
        delayedTriggers.push( ( function( c ) {
          return function( event ) {
            c._trigger( "update", event, this._uiHash( this ) );
          };
        } ).call( this, this.currentContainer ) );
      }
    }

    //Post events to containers
    function delayEvent( type, instance, container ) {
      return function( event ) {
        container._trigger( type, event, instance._uiHash( instance ) );
      };
    }
    for ( i = this.containers.length - 1; i >= 0; i-- ) {
      if ( !noPropagation ) {
        delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
      }
      if ( this.containers[ i ].containerCache.over ) {
        delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
        this.containers[ i ].containerCache.over = 0;
      }
    }

    //Do what was originally in plugins
    if ( this.storedCursor ) {
      this.document.find( "body" ).css( "cursor", this.storedCursor );
      this.storedStylesheet.remove();
    }
    if ( this._storedOpacity ) {
      this.helper.css( "opacity", this._storedOpacity );
    }
    if ( this._storedZIndex ) {
      this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );
    }

    this.dragging = false;

    if ( !noPropagation ) {
      this._trigger( "beforeStop", event, this._uiHash() );
    }

    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
    // it unbinds ALL events from the original node!
    this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );

    if ( !this.cancelHelperRemoval ) {
      if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
        this.helper.remove();
      }
      this.helper = null;
    }

    if ( !noPropagation ) {
      for ( i = 0; i < delayedTriggers.length; i++ ) {

        // Trigger all delayed events
        delayedTriggers[ i ].call( this, event );
      }
      this._trigger( "stop", event, this._uiHash() );
    }

    this.fromOutside = false;
    return !this.cancelHelperRemoval;

  },

  _trigger: function() {
    if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
      this.cancel();
    }
  },

  _uiHash: function( _inst ) {
    var inst = _inst || this;
    return {
      helper: inst.helper,
      placeholder: inst.placeholder || $( [] ),
      position: inst.position,
      originalPosition: inst.originalPosition,
      offset: inst.positionAbs,
      item: inst.currentItem,
      sender: _inst ? _inst.element : null
    };
  }

} );


/*!
 * jQuery UI Spinner 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Spinner
//>>group: Widgets
//>>description: Displays buttons to easily input numbers via the keyboard or mouse.
//>>docs: http://api.jqueryui.com/spinner/
//>>demos: http://jqueryui.com/spinner/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/spinner.css
//>>css.theme: ../../themes/base/theme.css



function spinnerModifer( fn ) {
  return function() {
    var previous = this.element.val();
    fn.apply( this, arguments );
    this._refresh();
    if ( previous !== this.element.val() ) {
      this._trigger( "change" );
    }
  };
}

$.widget( "ui.spinner", {
  version: "1.12.1",
  defaultElement: "<input>",
  widgetEventPrefix: "spin",
  options: {
    classes: {
      "ui-spinner": "ui-corner-all",
      "ui-spinner-down": "ui-corner-br",
      "ui-spinner-up": "ui-corner-tr"
    },
    culture: null,
    icons: {
      down: "ui-icon-triangle-1-s",
      up: "ui-icon-triangle-1-n"
    },
    incremental: true,
    max: null,
    min: null,
    numberFormat: null,
    page: 10,
    step: 1,

    change: null,
    spin: null,
    start: null,
    stop: null
  },

  _create: function() {

    // handle string values that need to be parsed
    this._setOption( "max", this.options.max );
    this._setOption( "min", this.options.min );
    this._setOption( "step", this.options.step );

    // Only format if there is a value, prevents the field from being marked
    // as invalid in Firefox, see #9573.
    if ( this.value() !== "" ) {

      // Format the value, but don't constrain.
      this._value( this.element.val(), true );
    }

    this._draw();
    this._on( this._events );
    this._refresh();

    // Turning off autocomplete prevents the browser from remembering the
    // value when navigating through history, so we re-enable autocomplete
    // if the page is unloaded before the widget is destroyed. #7790
    this._on( this.window, {
      beforeunload: function() {
        this.element.removeAttr( "autocomplete" );
      }
    } );
  },

  _getCreateOptions: function() {
    var options = this._super();
    var element = this.element;

    $.each( [ "min", "max", "step" ], function( i, option ) {
      var value = element.attr( option );
      if ( value != null && value.length ) {
        options[ option ] = value;
      }
    } );

    return options;
  },

  _events: {
    keydown: function( event ) {
      if ( this._start( event ) && this._keydown( event ) ) {
        event.preventDefault();
      }
    },
    keyup: "_stop",
    focus: function() {
      this.previous = this.element.val();
    },
    blur: function( event ) {
      if ( this.cancelBlur ) {
        delete this.cancelBlur;
        return;
      }

      this._stop();
      this._refresh();
      if ( this.previous !== this.element.val() ) {
        this._trigger( "change", event );
      }
    },
    mousewheel: function( event, delta ) {
      if ( !delta ) {
        return;
      }
      if ( !this.spinning && !this._start( event ) ) {
        return false;
      }

      this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );
      clearTimeout( this.mousewheelTimer );
      this.mousewheelTimer = this._delay( function() {
        if ( this.spinning ) {
          this._stop( event );
        }
      }, 100 );
      event.preventDefault();
    },
    "mousedown .ui-spinner-button": function( event ) {
      var previous;

      // We never want the buttons to have focus; whenever the user is
      // interacting with the spinner, the focus should be on the input.
      // If the input is focused then this.previous is properly set from
      // when the input first received focus. If the input is not focused
      // then we need to set this.previous based on the value before spinning.
      previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?
        this.previous : this.element.val();
      function checkFocus() {
        var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );
        if ( !isActive ) {
          this.element.trigger( "focus" );
          this.previous = previous;

          // support: IE
          // IE sets focus asynchronously, so we need to check if focus
          // moved off of the input because the user clicked on the button.
          this._delay( function() {
            this.previous = previous;
          } );
        }
      }

      // Ensure focus is on (or stays on) the text field
      event.preventDefault();
      checkFocus.call( this );

      // Support: IE
      // IE doesn't prevent moving focus even with event.preventDefault()
      // so we set a flag to know when we should ignore the blur event
      // and check (again) if focus moved off of the input.
      this.cancelBlur = true;
      this._delay( function() {
        delete this.cancelBlur;
        checkFocus.call( this );
      } );

      if ( this._start( event ) === false ) {
        return;
      }

      this._repeat( null, $( event.currentTarget )
        .hasClass( "ui-spinner-up" ) ? 1 : -1, event );
    },
    "mouseup .ui-spinner-button": "_stop",
    "mouseenter .ui-spinner-button": function( event ) {

      // button will add ui-state-active if mouse was down while mouseleave and kept down
      if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
        return;
      }

      if ( this._start( event ) === false ) {
        return false;
      }
      this._repeat( null, $( event.currentTarget )
        .hasClass( "ui-spinner-up" ) ? 1 : -1, event );
    },

    // TODO: do we really want to consider this a stop?
    // shouldn't we just stop the repeater and wait until mouseup before
    // we trigger the stop event?
    "mouseleave .ui-spinner-button": "_stop"
  },

  // Support mobile enhanced option and make backcompat more sane
  _enhance: function() {
    this.uiSpinner = this.element
      .attr( "autocomplete", "off" )
      .wrap( "<span>" )
      .parent()

        // Add buttons
        .append(
          "<a></a><a></a>"
        );
  },

  _draw: function() {
    this._enhance();

    this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );
    this._addClass( "ui-spinner-input" );

    this.element.attr( "role", "spinbutton" );

    // Button bindings
    this.buttons = this.uiSpinner.children( "a" )
      .attr( "tabIndex", -1 )
      .attr( "aria-hidden", true )
      .button( {
        classes: {
          "ui-button": ""
        }
      } );

    // TODO: Right now button does not support classes this is already updated in button PR
    this._removeClass( this.buttons, "ui-corner-all" );

    this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );
    this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );
    this.buttons.first().button( {
      "icon": this.options.icons.up,
      "showLabel": false
    } );
    this.buttons.last().button( {
      "icon": this.options.icons.down,
      "showLabel": false
    } );

    // IE 6 doesn't understand height: 50% for the buttons
    // unless the wrapper has an explicit height
    if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&
        this.uiSpinner.height() > 0 ) {
      this.uiSpinner.height( this.uiSpinner.height() );
    }
  },

  _keydown: function( event ) {
    var options = this.options,
      keyCode = $.ui.keyCode;

    switch ( event.keyCode ) {
    case keyCode.UP:
      this._repeat( null, 1, event );
      return true;
    case keyCode.DOWN:
      this._repeat( null, -1, event );
      return true;
    case keyCode.PAGE_UP:
      this._repeat( null, options.page, event );
      return true;
    case keyCode.PAGE_DOWN:
      this._repeat( null, -options.page, event );
      return true;
    }

    return false;
  },

  _start: function( event ) {
    if ( !this.spinning && this._trigger( "start", event ) === false ) {
      return false;
    }

    if ( !this.counter ) {
      this.counter = 1;
    }
    this.spinning = true;
    return true;
  },

  _repeat: function( i, steps, event ) {
    i = i || 500;

    clearTimeout( this.timer );
    this.timer = this._delay( function() {
      this._repeat( 40, steps, event );
    }, i );

    this._spin( steps * this.options.step, event );
  },

  _spin: function( step, event ) {
    var value = this.value() || 0;

    if ( !this.counter ) {
      this.counter = 1;
    }

    value = this._adjustValue( value + step * this._increment( this.counter ) );

    if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false ) {
      this._value( value );
      this.counter++;
    }
  },

  _increment: function( i ) {
    var incremental = this.options.incremental;

    if ( incremental ) {
      return $.isFunction( incremental ) ?
        incremental( i ) :
        Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
    }

    return 1;
  },

  _precision: function() {
    var precision = this._precisionOf( this.options.step );
    if ( this.options.min !== null ) {
      precision = Math.max( precision, this._precisionOf( this.options.min ) );
    }
    return precision;
  },

  _precisionOf: function( num ) {
    var str = num.toString(),
      decimal = str.indexOf( "." );
    return decimal === -1 ? 0 : str.length - decimal - 1;
  },

  _adjustValue: function( value ) {
    var base, aboveMin,
      options = this.options;

    // Make sure we're at a valid step
    // - find out where we are relative to the base (min or 0)
    base = options.min !== null ? options.min : 0;
    aboveMin = value - base;

    // - round to the nearest step
    aboveMin = Math.round( aboveMin / options.step ) * options.step;

    // - rounding is based on 0, so adjust back to our base
    value = base + aboveMin;

    // Fix precision from bad JS floating point math
    value = parseFloat( value.toFixed( this._precision() ) );

    // Clamp the value
    if ( options.max !== null && value > options.max ) {
      return options.max;
    }
    if ( options.min !== null && value < options.min ) {
      return options.min;
    }

    return value;
  },

  _stop: function( event ) {
    if ( !this.spinning ) {
      return;
    }

    clearTimeout( this.timer );
    clearTimeout( this.mousewheelTimer );
    this.counter = 0;
    this.spinning = false;
    this._trigger( "stop", event );
  },

  _setOption: function( key, value ) {
    var prevValue, first, last;

    if ( key === "culture" || key === "numberFormat" ) {
      prevValue = this._parse( this.element.val() );
      this.options[ key ] = value;
      this.element.val( this._format( prevValue ) );
      return;
    }

    if ( key === "max" || key === "min" || key === "step" ) {
      if ( typeof value === "string" ) {
        value = this._parse( value );
      }
    }
    if ( key === "icons" ) {
      first = this.buttons.first().find( ".ui-icon" );
      this._removeClass( first, null, this.options.icons.up );
      this._addClass( first, null, value.up );
      last = this.buttons.last().find( ".ui-icon" );
      this._removeClass( last, null, this.options.icons.down );
      this._addClass( last, null, value.down );
    }

    this._super( key, value );
  },

  _setOptionDisabled: function( value ) {
    this._super( value );

    this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!value );
    this.element.prop( "disabled", !!value );
    this.buttons.button( value ? "disable" : "enable" );
  },

  _setOptions: spinnerModifer( function( options ) {
    this._super( options );
  } ),

  _parse: function( val ) {
    if ( typeof val === "string" && val !== "" ) {
      val = window.Globalize && this.options.numberFormat ?
        Globalize.parseFloat( val, 10, this.options.culture ) : +val;
    }
    return val === "" || isNaN( val ) ? null : val;
  },

  _format: function( value ) {
    if ( value === "" ) {
      return "";
    }
    return window.Globalize && this.options.numberFormat ?
      Globalize.format( value, this.options.numberFormat, this.options.culture ) :
      value;
  },

  _refresh: function() {
    this.element.attr( {
      "aria-valuemin": this.options.min,
      "aria-valuemax": this.options.max,

      // TODO: what should we do with values that can't be parsed?
      "aria-valuenow": this._parse( this.element.val() )
    } );
  },

  isValid: function() {
    var value = this.value();

    // Null is invalid
    if ( value === null ) {
      return false;
    }

    // If value gets adjusted, it's invalid
    return value === this._adjustValue( value );
  },

  // Update the value without triggering change
  _value: function( value, allowAny ) {
    var parsed;
    if ( value !== "" ) {
      parsed = this._parse( value );
      if ( parsed !== null ) {
        if ( !allowAny ) {
          parsed = this._adjustValue( parsed );
        }
        value = this._format( parsed );
      }
    }
    this.element.val( value );
    this._refresh();
  },

  _destroy: function() {
    this.element
      .prop( "disabled", false )
      .removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );

    this.uiSpinner.replaceWith( this.element );
  },

  stepUp: spinnerModifer( function( steps ) {
    this._stepUp( steps );
  } ),
  _stepUp: function( steps ) {
    if ( this._start() ) {
      this._spin( ( steps || 1 ) * this.options.step );
      this._stop();
    }
  },

  stepDown: spinnerModifer( function( steps ) {
    this._stepDown( steps );
  } ),
  _stepDown: function( steps ) {
    if ( this._start() ) {
      this._spin( ( steps || 1 ) * -this.options.step );
      this._stop();
    }
  },

  pageUp: spinnerModifer( function( pages ) {
    this._stepUp( ( pages || 1 ) * this.options.page );
  } ),

  pageDown: spinnerModifer( function( pages ) {
    this._stepDown( ( pages || 1 ) * this.options.page );
  } ),

  value: function( newVal ) {
    if ( !arguments.length ) {
      return this._parse( this.element.val() );
    }
    spinnerModifer( this._value ).call( this, newVal );
  },

  widget: function() {
    return this.uiSpinner;
  }
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

  // Backcompat for spinner html extension points
  $.widget( "ui.spinner", $.ui.spinner, {
    _enhance: function() {
      this.uiSpinner = this.element
        .attr( "autocomplete", "off" )
        .wrap( this._uiSpinnerHtml() )
        .parent()

          // Add buttons
          .append( this._buttonHtml() );
    },
    _uiSpinnerHtml: function() {
      return "<span>";
    },

    _buttonHtml: function() {
      return "<a></a><a></a>";
    }
  } );
}

var widgetsSpinner = $.ui.spinner;


/*!
 * jQuery UI Tabs 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tabs
//>>group: Widgets
//>>description: Transforms a set of container elements into a tab structure.
//>>docs: http://api.jqueryui.com/tabs/
//>>demos: http://jqueryui.com/tabs/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tabs.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tabs", {
  version: "1.12.1",
  delay: 300,
  options: {
    active: null,
    classes: {
      "ui-tabs": "ui-corner-all",
      "ui-tabs-nav": "ui-corner-all",
      "ui-tabs-panel": "ui-corner-bottom",
      "ui-tabs-tab": "ui-corner-top"
    },
    collapsible: false,
    event: "click",
    heightStyle: "content",
    hide: null,
    show: null,

    // Callbacks
    activate: null,
    beforeActivate: null,
    beforeLoad: null,
    load: null
  },

  _isLocal: ( function() {
    var rhash = /#.*$/;

    return function( anchor ) {
      var anchorUrl, locationUrl;

      anchorUrl = anchor.href.replace( rhash, "" );
      locationUrl = location.href.replace( rhash, "" );

      // Decoding may throw an error if the URL isn't UTF-8 (#9518)
      try {
        anchorUrl = decodeURIComponent( anchorUrl );
      } catch ( error ) {}
      try {
        locationUrl = decodeURIComponent( locationUrl );
      } catch ( error ) {}

      return anchor.hash.length > 1 && anchorUrl === locationUrl;
    };
  } )(),

  _create: function() {
    var that = this,
      options = this.options;

    this.running = false;

    this._addClass( "ui-tabs", "ui-widget ui-widget-content" );
    this._toggleClass( "ui-tabs-collapsible", null, options.collapsible );

    this._processTabs();
    options.active = this._initialActive();

    // Take disabling tabs via class attribute from HTML
    // into account and update option properly.
    if ( $.isArray( options.disabled ) ) {
      options.disabled = $.unique( options.disabled.concat(
        $.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
          return that.tabs.index( li );
        } )
      ) ).sort();
    }

    // Check for length avoids error when initializing empty list
    if ( this.options.active !== false && this.anchors.length ) {
      this.active = this._findActive( options.active );
    } else {
      this.active = $();
    }

    this._refresh();

    if ( this.active.length ) {
      this.load( options.active );
    }
  },

  _initialActive: function() {
    var active = this.options.active,
      collapsible = this.options.collapsible,
      locationHash = location.hash.substring( 1 );

    if ( active === null ) {

      // check the fragment identifier in the URL
      if ( locationHash ) {
        this.tabs.each( function( i, tab ) {
          if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
            active = i;
            return false;
          }
        } );
      }

      // Check for a tab marked active via a class
      if ( active === null ) {
        active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
      }

      // No active tab, set to false
      if ( active === null || active === -1 ) {
        active = this.tabs.length ? 0 : false;
      }
    }

    // Handle numbers: negative, out of range
    if ( active !== false ) {
      active = this.tabs.index( this.tabs.eq( active ) );
      if ( active === -1 ) {
        active = collapsible ? false : 0;
      }
    }

    // Don't allow collapsible: false and active: false
    if ( !collapsible && active === false && this.anchors.length ) {
      active = 0;
    }

    return active;
  },

  _getCreateEventData: function() {
    return {
      tab: this.active,
      panel: !this.active.length ? $() : this._getPanelForTab( this.active )
    };
  },

  _tabKeydown: function( event ) {
    var focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),
      selectedIndex = this.tabs.index( focusedTab ),
      goingForward = true;

    if ( this._handlePageNav( event ) ) {
      return;
    }

    switch ( event.keyCode ) {
    case $.ui.keyCode.RIGHT:
    case $.ui.keyCode.DOWN:
      selectedIndex++;
      break;
    case $.ui.keyCode.UP:
    case $.ui.keyCode.LEFT:
      goingForward = false;
      selectedIndex--;
      break;
    case $.ui.keyCode.END:
      selectedIndex = this.anchors.length - 1;
      break;
    case $.ui.keyCode.HOME:
      selectedIndex = 0;
      break;
    case $.ui.keyCode.SPACE:

      // Activate only, no collapsing
      event.preventDefault();
      clearTimeout( this.activating );
      this._activate( selectedIndex );
      return;
    case $.ui.keyCode.ENTER:

      // Toggle (cancel delayed activation, allow collapsing)
      event.preventDefault();
      clearTimeout( this.activating );

      // Determine if we should collapse or activate
      this._activate( selectedIndex === this.options.active ? false : selectedIndex );
      return;
    default:
      return;
    }

    // Focus the appropriate tab, based on which key was pressed
    event.preventDefault();
    clearTimeout( this.activating );
    selectedIndex = this._focusNextTab( selectedIndex, goingForward );

    // Navigating with control/command key will prevent automatic activation
    if ( !event.ctrlKey && !event.metaKey ) {

      // Update aria-selected immediately so that AT think the tab is already selected.
      // Otherwise AT may confuse the user by stating that they need to activate the tab,
      // but the tab will already be activated by the time the announcement finishes.
      focusedTab.attr( "aria-selected", "false" );
      this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

      this.activating = this._delay( function() {
        this.option( "active", selectedIndex );
      }, this.delay );
    }
  },

  _panelKeydown: function( event ) {
    if ( this._handlePageNav( event ) ) {
      return;
    }

    // Ctrl+up moves focus to the current tab
    if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
      event.preventDefault();
      this.active.trigger( "focus" );
    }
  },

  // Alt+page up/down moves focus to the previous/next tab (and activates)
  _handlePageNav: function( event ) {
    if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
      this._activate( this._focusNextTab( this.options.active - 1, false ) );
      return true;
    }
    if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
      this._activate( this._focusNextTab( this.options.active + 1, true ) );
      return true;
    }
  },

  _findNextTab: function( index, goingForward ) {
    var lastTabIndex = this.tabs.length - 1;

    function constrain() {
      if ( index > lastTabIndex ) {
        index = 0;
      }
      if ( index < 0 ) {
        index = lastTabIndex;
      }
      return index;
    }

    while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
      index = goingForward ? index + 1 : index - 1;
    }

    return index;
  },

  _focusNextTab: function( index, goingForward ) {
    index = this._findNextTab( index, goingForward );
    this.tabs.eq( index ).trigger( "focus" );
    return index;
  },

  _setOption: function( key, value ) {
    if ( key === "active" ) {

      // _activate() will handle invalid values and update this.options
      this._activate( value );
      return;
    }

    this._super( key, value );

    if ( key === "collapsible" ) {
      this._toggleClass( "ui-tabs-collapsible", null, value );

      // Setting collapsible: false while collapsed; open first panel
      if ( !value && this.options.active === false ) {
        this._activate( 0 );
      }
    }

    if ( key === "event" ) {
      this._setupEvents( value );
    }

    if ( key === "heightStyle" ) {
      this._setupHeightStyle( value );
    }
  },

  _sanitizeSelector: function( hash ) {
    return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
  },

  refresh: function() {
    var options = this.options,
      lis = this.tablist.children( ":has(a[href])" );

    // Get disabled tabs from class attribute from HTML
    // this will get converted to a boolean if needed in _refresh()
    options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
      return lis.index( tab );
    } );

    this._processTabs();

    // Was collapsed or no tabs
    if ( options.active === false || !this.anchors.length ) {
      options.active = false;
      this.active = $();

    // was active, but active tab is gone
    } else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {

      // all remaining tabs are disabled
      if ( this.tabs.length === options.disabled.length ) {
        options.active = false;
        this.active = $();

      // activate previous tab
      } else {
        this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
      }

    // was active, active tab still exists
    } else {

      // make sure active index is correct
      options.active = this.tabs.index( this.active );
    }

    this._refresh();
  },

  _refresh: function() {
    this._setOptionDisabled( this.options.disabled );
    this._setupEvents( this.options.event );
    this._setupHeightStyle( this.options.heightStyle );

    this.tabs.not( this.active ).attr( {
      "aria-selected": "false",
      "aria-expanded": "false",
      tabIndex: -1
    } );
    this.panels.not( this._getPanelForTab( this.active ) )
      .hide()
      .attr( {
        "aria-hidden": "true"
      } );

    // Make sure one tab is in the tab order
    if ( !this.active.length ) {
      this.tabs.eq( 0 ).attr( "tabIndex", 0 );
    } else {
      this.active
        .attr( {
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        } );
      this._addClass( this.active, "ui-tabs-active", "ui-state-active" );
      this._getPanelForTab( this.active )
        .show()
        .attr( {
          "aria-hidden": "false"
        } );
    }
  },

  _processTabs: function() {
    var that = this,
      prevTabs = this.tabs,
      prevAnchors = this.anchors,
      prevPanels = this.panels;

    this.tablist = this._getList().attr( "role", "tablist" );
    this._addClass( this.tablist, "ui-tabs-nav",
      "ui-helper-reset ui-helper-clearfix ui-widget-header" );

    // Prevent users from focusing disabled tabs via click
    this.tablist
      .on( "mousedown" + this.eventNamespace, "> li", function( event ) {
        if ( $( this ).is( ".ui-state-disabled" ) ) {
          event.preventDefault();
        }
      } )

      // Support: IE <9
      // Preventing the default action in mousedown doesn't prevent IE
      // from focusing the element, so if the anchor gets focused, blur.
      // We don't have to worry about focusing the previously focused
      // element since clicking on a non-focusable element should focus
      // the body anyway.
      .on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
        if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
          this.blur();
        }
      } );

    this.tabs = this.tablist.find( "> li:has(a[href])" )
      .attr( {
        role: "tab",
        tabIndex: -1
      } );
    this._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );

    this.anchors = this.tabs.map( function() {
      return $( "a", this )[ 0 ];
    } )
      .attr( {
        role: "presentation",
        tabIndex: -1
      } );
    this._addClass( this.anchors, "ui-tabs-anchor" );

    this.panels = $();

    this.anchors.each( function( i, anchor ) {
      var selector, panel, panelId,
        anchorId = $( anchor ).uniqueId().attr( "id" ),
        tab = $( anchor ).closest( "li" ),
        originalAriaControls = tab.attr( "aria-controls" );

      // Inline tab
      if ( that._isLocal( anchor ) ) {
        selector = anchor.hash;
        panelId = selector.substring( 1 );
        panel = that.element.find( that._sanitizeSelector( selector ) );

      // remote tab
      } else {

        // If the tab doesn't already have aria-controls,
        // generate an id by using a throw-away element
        panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
        selector = "#" + panelId;
        panel = that.element.find( selector );
        if ( !panel.length ) {
          panel = that._createPanel( panelId );
          panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
        }
        panel.attr( "aria-live", "polite" );
      }

      if ( panel.length ) {
        that.panels = that.panels.add( panel );
      }
      if ( originalAriaControls ) {
        tab.data( "ui-tabs-aria-controls", originalAriaControls );
      }
      tab.attr( {
        "aria-controls": panelId,
        "aria-labelledby": anchorId
      } );
      panel.attr( "aria-labelledby", anchorId );
    } );

    this.panels.attr( "role", "tabpanel" );
    this._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );

    // Avoid memory leaks (#10056)
    if ( prevTabs ) {
      this._off( prevTabs.not( this.tabs ) );
      this._off( prevAnchors.not( this.anchors ) );
      this._off( prevPanels.not( this.panels ) );
    }
  },

  // Allow overriding how to find the list for rare usage scenarios (#7715)
  _getList: function() {
    return this.tablist || this.element.find( "ol, ul" ).eq( 0 );
  },

  _createPanel: function( id ) {
    return $( "<div>" )
      .attr( "id", id )
      .data( "ui-tabs-destroy", true );
  },

  _setOptionDisabled: function( disabled ) {
    var currentItem, li, i;

    if ( $.isArray( disabled ) ) {
      if ( !disabled.length ) {
        disabled = false;
      } else if ( disabled.length === this.anchors.length ) {
        disabled = true;
      }
    }

    // Disable tabs
    for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {
      currentItem = $( li );
      if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
        currentItem.attr( "aria-disabled", "true" );
        this._addClass( currentItem, null, "ui-state-disabled" );
      } else {
        currentItem.removeAttr( "aria-disabled" );
        this._removeClass( currentItem, null, "ui-state-disabled" );
      }
    }

    this.options.disabled = disabled;

    this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,
      disabled === true );
  },

  _setupEvents: function( event ) {
    var events = {};
    if ( event ) {
      $.each( event.split( " " ), function( index, eventName ) {
        events[ eventName ] = "_eventHandler";
      } );
    }

    this._off( this.anchors.add( this.tabs ).add( this.panels ) );

    // Always prevent the default action, even when disabled
    this._on( true, this.anchors, {
      click: function( event ) {
        event.preventDefault();
      }
    } );
    this._on( this.anchors, events );
    this._on( this.tabs, { keydown: "_tabKeydown" } );
    this._on( this.panels, { keydown: "_panelKeydown" } );

    this._focusable( this.tabs );
    this._hoverable( this.tabs );
  },

  _setupHeightStyle: function( heightStyle ) {
    var maxHeight,
      parent = this.element.parent();

    if ( heightStyle === "fill" ) {
      maxHeight = parent.height();
      maxHeight -= this.element.outerHeight() - this.element.height();

      this.element.siblings( ":visible" ).each( function() {
        var elem = $( this ),
          position = elem.css( "position" );

        if ( position === "absolute" || position === "fixed" ) {
          return;
        }
        maxHeight -= elem.outerHeight( true );
      } );

      this.element.children().not( this.panels ).each( function() {
        maxHeight -= $( this ).outerHeight( true );
      } );

      this.panels.each( function() {
        $( this ).height( Math.max( 0, maxHeight -
          $( this ).innerHeight() + $( this ).height() ) );
      } )
        .css( "overflow", "auto" );
    } else if ( heightStyle === "auto" ) {
      maxHeight = 0;
      this.panels.each( function() {
        maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
      } ).height( maxHeight );
    }
  },

  _eventHandler: function( event ) {
    var options = this.options,
      active = this.active,
      anchor = $( event.currentTarget ),
      tab = anchor.closest( "li" ),
      clickedIsActive = tab[ 0 ] === active[ 0 ],
      collapsing = clickedIsActive && options.collapsible,
      toShow = collapsing ? $() : this._getPanelForTab( tab ),
      toHide = !active.length ? $() : this._getPanelForTab( active ),
      eventData = {
        oldTab: active,
        oldPanel: toHide,
        newTab: collapsing ? $() : tab,
        newPanel: toShow
      };

    event.preventDefault();

    if ( tab.hasClass( "ui-state-disabled" ) ||

        // tab is already loading
        tab.hasClass( "ui-tabs-loading" ) ||

        // can't switch durning an animation
        this.running ||

        // click on active header, but not collapsible
        ( clickedIsActive && !options.collapsible ) ||

        // allow canceling activation
        ( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
      return;
    }

    options.active = collapsing ? false : this.tabs.index( tab );

    this.active = clickedIsActive ? $() : tab;
    if ( this.xhr ) {
      this.xhr.abort();
    }

    if ( !toHide.length && !toShow.length ) {
      $.error( "jQuery UI Tabs: Mismatching fragment identifier." );
    }

    if ( toShow.length ) {
      this.load( this.tabs.index( tab ), event );
    }
    this._toggle( event, eventData );
  },

  // Handles show/hide for selecting tabs
  _toggle: function( event, eventData ) {
    var that = this,
      toShow = eventData.newPanel,
      toHide = eventData.oldPanel;

    this.running = true;

    function complete() {
      that.running = false;
      that._trigger( "activate", event, eventData );
    }

    function show() {
      that._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );

      if ( toShow.length && that.options.show ) {
        that._show( toShow, that.options.show, complete );
      } else {
        toShow.show();
        complete();
      }
    }

    // Start out by hiding, then showing, then completing
    if ( toHide.length && this.options.hide ) {
      this._hide( toHide, this.options.hide, function() {
        that._removeClass( eventData.oldTab.closest( "li" ),
          "ui-tabs-active", "ui-state-active" );
        show();
      } );
    } else {
      this._removeClass( eventData.oldTab.closest( "li" ),
        "ui-tabs-active", "ui-state-active" );
      toHide.hide();
      show();
    }

    toHide.attr( "aria-hidden", "true" );
    eventData.oldTab.attr( {
      "aria-selected": "false",
      "aria-expanded": "false"
    } );

    // If we're switching tabs, remove the old tab from the tab order.
    // If we're opening from collapsed state, remove the previous tab from the tab order.
    // If we're collapsing, then keep the collapsing tab in the tab order.
    if ( toShow.length && toHide.length ) {
      eventData.oldTab.attr( "tabIndex", -1 );
    } else if ( toShow.length ) {
      this.tabs.filter( function() {
        return $( this ).attr( "tabIndex" ) === 0;
      } )
        .attr( "tabIndex", -1 );
    }

    toShow.attr( "aria-hidden", "false" );
    eventData.newTab.attr( {
      "aria-selected": "true",
      "aria-expanded": "true",
      tabIndex: 0
    } );
  },

  _activate: function( index ) {
    var anchor,
      active = this._findActive( index );

    // Trying to activate the already active panel
    if ( active[ 0 ] === this.active[ 0 ] ) {
      return;
    }

    // Trying to collapse, simulate a click on the current active header
    if ( !active.length ) {
      active = this.active;
    }

    anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
    this._eventHandler( {
      target: anchor,
      currentTarget: anchor,
      preventDefault: $.noop
    } );
  },

  _findActive: function( index ) {
    return index === false ? $() : this.tabs.eq( index );
  },

  _getIndex: function( index ) {

    // meta-function to give users option to provide a href string instead of a numerical index.
    if ( typeof index === "string" ) {
      index = this.anchors.index( this.anchors.filter( "[href$='" +
        $.ui.escapeSelector( index ) + "']" ) );
    }

    return index;
  },

  _destroy: function() {
    if ( this.xhr ) {
      this.xhr.abort();
    }

    this.tablist
      .removeAttr( "role" )
      .off( this.eventNamespace );

    this.anchors
      .removeAttr( "role tabIndex" )
      .removeUniqueId();

    this.tabs.add( this.panels ).each( function() {
      if ( $.data( this, "ui-tabs-destroy" ) ) {
        $( this ).remove();
      } else {
        $( this ).removeAttr( "role tabIndex " +
          "aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );
      }
    } );

    this.tabs.each( function() {
      var li = $( this ),
        prev = li.data( "ui-tabs-aria-controls" );
      if ( prev ) {
        li
          .attr( "aria-controls", prev )
          .removeData( "ui-tabs-aria-controls" );
      } else {
        li.removeAttr( "aria-controls" );
      }
    } );

    this.panels.show();

    if ( this.options.heightStyle !== "content" ) {
      this.panels.css( "height", "" );
    }
  },

  enable: function( index ) {
    var disabled = this.options.disabled;
    if ( disabled === false ) {
      return;
    }

    if ( index === undefined ) {
      disabled = false;
    } else {
      index = this._getIndex( index );
      if ( $.isArray( disabled ) ) {
        disabled = $.map( disabled, function( num ) {
          return num !== index ? num : null;
        } );
      } else {
        disabled = $.map( this.tabs, function( li, num ) {
          return num !== index ? num : null;
        } );
      }
    }
    this._setOptionDisabled( disabled );
  },

  disable: function( index ) {
    var disabled = this.options.disabled;
    if ( disabled === true ) {
      return;
    }

    if ( index === undefined ) {
      disabled = true;
    } else {
      index = this._getIndex( index );
      if ( $.inArray( index, disabled ) !== -1 ) {
        return;
      }
      if ( $.isArray( disabled ) ) {
        disabled = $.merge( [ index ], disabled ).sort();
      } else {
        disabled = [ index ];
      }
    }
    this._setOptionDisabled( disabled );
  },

  load: function( index, event ) {
    index = this._getIndex( index );
    var that = this,
      tab = this.tabs.eq( index ),
      anchor = tab.find( ".ui-tabs-anchor" ),
      panel = this._getPanelForTab( tab ),
      eventData = {
        tab: tab,
        panel: panel
      },
      complete = function( jqXHR, status ) {
        if ( status === "abort" ) {
          that.panels.stop( false, true );
        }

        that._removeClass( tab, "ui-tabs-loading" );
        panel.removeAttr( "aria-busy" );

        if ( jqXHR === that.xhr ) {
          delete that.xhr;
        }
      };

    // Not remote
    if ( this._isLocal( anchor[ 0 ] ) ) {
      return;
    }

    this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

    // Support: jQuery <1.8
    // jQuery <1.8 returns false if the request is canceled in beforeSend,
    // but as of 1.8, $.ajax() always returns a jqXHR object.
    if ( this.xhr && this.xhr.statusText !== "canceled" ) {
      this._addClass( tab, "ui-tabs-loading" );
      panel.attr( "aria-busy", "true" );

      this.xhr
        .done( function( response, status, jqXHR ) {

          // support: jQuery <1.8
          // http://bugs.jquery.com/ticket/11778
          setTimeout( function() {
            panel.html( response );
            that._trigger( "load", event, eventData );

            complete( jqXHR, status );
          }, 1 );
        } )
        .fail( function( jqXHR, status ) {

          // support: jQuery <1.8
          // http://bugs.jquery.com/ticket/11778
          setTimeout( function() {
            complete( jqXHR, status );
          }, 1 );
        } );
    }
  },

  _ajaxSettings: function( anchor, event, eventData ) {
    var that = this;
    return {

      // Support: IE <11 only
      // Strip any hash that exists to prevent errors with the Ajax request
      url: anchor.attr( "href" ).replace( /#.*$/, "" ),
      beforeSend: function( jqXHR, settings ) {
        return that._trigger( "beforeLoad", event,
          $.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
      }
    };
  },

  _getPanelForTab: function( tab ) {
    var id = $( tab ).attr( "aria-controls" );
    return this.element.find( this._sanitizeSelector( "#" + id ) );
  }
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

  // Backcompat for ui-tab class (now ui-tabs-tab)
  $.widget( "ui.tabs", $.ui.tabs, {
    _processTabs: function() {
      this._superApply( arguments );
      this._addClass( this.tabs, "ui-tab" );
    }
  } );
}

var widgetsTabs = $.ui.tabs;


/*!
 * jQuery UI Tooltip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tooltip
//>>group: Widgets
//>>description: Shows additional information for any element on hover or focus.
//>>docs: http://api.jqueryui.com/tooltip/
//>>demos: http://jqueryui.com/tooltip/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tooltip.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tooltip", {
  version: "1.12.1",
  options: {
    classes: {
      "ui-tooltip": "ui-corner-all ui-widget-shadow"
    },
    content: function() {

      // support: IE<9, Opera in jQuery <1.7
      // .text() can't accept undefined, so coerce to a string
      var title = $( this ).attr( "title" ) || "";

      // Escape title, since we're going from an attribute to raw HTML
      return $( "<a>" ).text( title ).html();
    },
    hide: true,

    // Disabled elements have inconsistent behavior across browsers (#8661)
    items: "[title]:not([disabled])",
    position: {
      my: "left top+15",
      at: "left bottom",
      collision: "flipfit flip"
    },
    show: true,
    track: false,

    // Callbacks
    close: null,
    open: null
  },

  _addDescribedBy: function( elem, id ) {
    var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
    describedby.push( id );
    elem
      .data( "ui-tooltip-id", id )
      .attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
  },

  _removeDescribedBy: function( elem ) {
    var id = elem.data( "ui-tooltip-id" ),
      describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
      index = $.inArray( id, describedby );

    if ( index !== -1 ) {
      describedby.splice( index, 1 );
    }

    elem.removeData( "ui-tooltip-id" );
    describedby = $.trim( describedby.join( " " ) );
    if ( describedby ) {
      elem.attr( "aria-describedby", describedby );
    } else {
      elem.removeAttr( "aria-describedby" );
    }
  },

  _create: function() {
    this._on( {
      mouseover: "open",
      focusin: "open"
    } );

    // IDs of generated tooltips, needed for destroy
    this.tooltips = {};

    // IDs of parent tooltips where we removed the title attribute
    this.parents = {};

    // Append the aria-live region so tooltips announce correctly
    this.liveRegion = $( "<div>" )
      .attr( {
        role: "log",
        "aria-live": "assertive",
        "aria-relevant": "additions"
      } )
      .appendTo( this.document[ 0 ].body );
    this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

    this.disabledTitles = $( [] );
  },

  _setOption: function( key, value ) {
    var that = this;

    this._super( key, value );

    if ( key === "content" ) {
      $.each( this.tooltips, function( id, tooltipData ) {
        that._updateContent( tooltipData.element );
      } );
    }
  },

  _setOptionDisabled: function( value ) {
    this[ value ? "_disable" : "_enable" ]();
  },

  _disable: function() {
    var that = this;

    // Close open tooltips
    $.each( this.tooltips, function( id, tooltipData ) {
      var event = $.Event( "blur" );
      event.target = event.currentTarget = tooltipData.element[ 0 ];
      that.close( event, true );
    } );

    // Remove title attributes to prevent native tooltips
    this.disabledTitles = this.disabledTitles.add(
      this.element.find( this.options.items ).addBack()
        .filter( function() {
          var element = $( this );
          if ( element.is( "[title]" ) ) {
            return element
              .data( "ui-tooltip-title", element.attr( "title" ) )
              .removeAttr( "title" );
          }
        } )
    );
  },

  _enable: function() {

    // restore title attributes
    this.disabledTitles.each( function() {
      var element = $( this );
      if ( element.data( "ui-tooltip-title" ) ) {
        element.attr( "title", element.data( "ui-tooltip-title" ) );
      }
    } );
    this.disabledTitles = $( [] );
  },

  open: function( event ) {
    var that = this,
      target = $( event ? event.target : this.element )

        // we need closest here due to mouseover bubbling,
        // but always pointing at the same event target
        .closest( this.options.items );

    // No element to show a tooltip for or the tooltip is already open
    if ( !target.length || target.data( "ui-tooltip-id" ) ) {
      return;
    }

    if ( target.attr( "title" ) ) {
      target.data( "ui-tooltip-title", target.attr( "title" ) );
    }

    target.data( "ui-tooltip-open", true );

    // Kill parent tooltips, custom or native, for hover
    if ( event && event.type === "mouseover" ) {
      target.parents().each( function() {
        var parent = $( this ),
          blurEvent;
        if ( parent.data( "ui-tooltip-open" ) ) {
          blurEvent = $.Event( "blur" );
          blurEvent.target = blurEvent.currentTarget = this;
          that.close( blurEvent, true );
        }
        if ( parent.attr( "title" ) ) {
          parent.uniqueId();
          that.parents[ this.id ] = {
            element: this,
            title: parent.attr( "title" )
          };
          parent.attr( "title", "" );
        }
      } );
    }

    this._registerCloseHandlers( event, target );
    this._updateContent( target, event );
  },

  _updateContent: function( target, event ) {
    var content,
      contentOption = this.options.content,
      that = this,
      eventType = event ? event.type : null;

    if ( typeof contentOption === "string" || contentOption.nodeType ||
        contentOption.jquery ) {
      return this._open( event, target, contentOption );
    }

    content = contentOption.call( target[ 0 ], function( response ) {

      // IE may instantly serve a cached response for ajax requests
      // delay this call to _open so the other call to _open runs first
      that._delay( function() {

        // Ignore async response if tooltip was closed already
        if ( !target.data( "ui-tooltip-open" ) ) {
          return;
        }

        // JQuery creates a special event for focusin when it doesn't
        // exist natively. To improve performance, the native event
        // object is reused and the type is changed. Therefore, we can't
        // rely on the type being correct after the event finished
        // bubbling, so we set it back to the previous value. (#8740)
        if ( event ) {
          event.type = eventType;
        }
        this._open( event, target, response );
      } );
    } );
    if ( content ) {
      this._open( event, target, content );
    }
  },

  _open: function( event, target, content ) {
    var tooltipData, tooltip, delayedShow, a11yContent,
      positionOption = $.extend( {}, this.options.position );

    if ( !content ) {
      return;
    }

    // Content can be updated multiple times. If the tooltip already
    // exists, then just update the content and bail.
    tooltipData = this._find( target );
    if ( tooltipData ) {
      tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
      return;
    }

    // If we have a title, clear it to prevent the native tooltip
    // we have to check first to avoid defining a title if none exists
    // (we don't want to cause an element to start matching [title])
    //
    // We use removeAttr only for key events, to allow IE to export the correct
    // accessible attributes. For mouse events, set to empty string to avoid
    // native tooltip showing up (happens only when removing inside mouseover).
    if ( target.is( "[title]" ) ) {
      if ( event && event.type === "mouseover" ) {
        target.attr( "title", "" );
      } else {
        target.removeAttr( "title" );
      }
    }

    tooltipData = this._tooltip( target );
    tooltip = tooltipData.tooltip;
    this._addDescribedBy( target, tooltip.attr( "id" ) );
    tooltip.find( ".ui-tooltip-content" ).html( content );

    // Support: Voiceover on OS X, JAWS on IE <= 9
    // JAWS announces deletions even when aria-relevant="additions"
    // Voiceover will sometimes re-read the entire log region's contents from the beginning
    this.liveRegion.children().hide();
    a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
    a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
    a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
    a11yContent.appendTo( this.liveRegion );

    function position( event ) {
      positionOption.of = event;
      if ( tooltip.is( ":hidden" ) ) {
        return;
      }
      tooltip.position( positionOption );
    }
    if ( this.options.track && event && /^mouse/.test( event.type ) ) {
      this._on( this.document, {
        mousemove: position
      } );

      // trigger once to override element-relative positioning
      position( event );
    } else {
      tooltip.position( $.extend( {
        of: target
      }, this.options.position ) );
    }

    tooltip.hide();

    this._show( tooltip, this.options.show );

    // Handle tracking tooltips that are shown with a delay (#8644). As soon
    // as the tooltip is visible, position the tooltip using the most recent
    // event.
    // Adds the check to add the timers only when both delay and track options are set (#14682)
    if ( this.options.track && this.options.show && this.options.show.delay ) {
      delayedShow = this.delayedShow = setInterval( function() {
        if ( tooltip.is( ":visible" ) ) {
          position( positionOption.of );
          clearInterval( delayedShow );
        }
      }, $.fx.interval );
    }

    this._trigger( "open", event, { tooltip: tooltip } );
  },

  _registerCloseHandlers: function( event, target ) {
    var events = {
      keyup: function( event ) {
        if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
          var fakeEvent = $.Event( event );
          fakeEvent.currentTarget = target[ 0 ];
          this.close( fakeEvent, true );
        }
      }
    };

    // Only bind remove handler for delegated targets. Non-delegated
    // tooltips will handle this in destroy.
    if ( target[ 0 ] !== this.element[ 0 ] ) {
      events.remove = function() {
        this._removeTooltip( this._find( target ).tooltip );
      };
    }

    if ( !event || event.type === "mouseover" ) {
      events.mouseleave = "close";
    }
    if ( !event || event.type === "focusin" ) {
      events.focusout = "close";
    }
    this._on( true, target, events );
  },

  close: function( event ) {
    var tooltip,
      that = this,
      target = $( event ? event.currentTarget : this.element ),
      tooltipData = this._find( target );

    // The tooltip may already be closed
    if ( !tooltipData ) {

      // We set ui-tooltip-open immediately upon open (in open()), but only set the
      // additional data once there's actually content to show (in _open()). So even if the
      // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
      // the period between open() and _open().
      target.removeData( "ui-tooltip-open" );
      return;
    }

    tooltip = tooltipData.tooltip;

    // Disabling closes the tooltip, so we need to track when we're closing
    // to avoid an infinite loop in case the tooltip becomes disabled on close
    if ( tooltipData.closing ) {
      return;
    }

    // Clear the interval for delayed tracking tooltips
    clearInterval( this.delayedShow );

    // Only set title if we had one before (see comment in _open())
    // If the title attribute has changed since open(), don't restore
    if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
      target.attr( "title", target.data( "ui-tooltip-title" ) );
    }

    this._removeDescribedBy( target );

    tooltipData.hiding = true;
    tooltip.stop( true );
    this._hide( tooltip, this.options.hide, function() {
      that._removeTooltip( $( this ) );
    } );

    target.removeData( "ui-tooltip-open" );
    this._off( target, "mouseleave focusout keyup" );

    // Remove 'remove' binding only on delegated targets
    if ( target[ 0 ] !== this.element[ 0 ] ) {
      this._off( target, "remove" );
    }
    this._off( this.document, "mousemove" );

    if ( event && event.type === "mouseleave" ) {
      $.each( this.parents, function( id, parent ) {
        $( parent.element ).attr( "title", parent.title );
        delete that.parents[ id ];
      } );
    }

    tooltipData.closing = true;
    this._trigger( "close", event, { tooltip: tooltip } );
    if ( !tooltipData.hiding ) {
      tooltipData.closing = false;
    }
  },

  _tooltip: function( element ) {
    var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
      content = $( "<div>" ).appendTo( tooltip ),
      id = tooltip.uniqueId().attr( "id" );

    this._addClass( content, "ui-tooltip-content" );
    this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );

    tooltip.appendTo( this._appendTo( element ) );

    return this.tooltips[ id ] = {
      element: element,
      tooltip: tooltip
    };
  },

  _find: function( target ) {
    var id = target.data( "ui-tooltip-id" );
    return id ? this.tooltips[ id ] : null;
  },

  _removeTooltip: function( tooltip ) {
    tooltip.remove();
    delete this.tooltips[ tooltip.attr( "id" ) ];
  },

  _appendTo: function( target ) {
    var element = target.closest( ".ui-front, dialog" );

    if ( !element.length ) {
      element = this.document[ 0 ].body;
    }

    return element;
  },

  _destroy: function() {
    var that = this;

    // Close open tooltips
    $.each( this.tooltips, function( id, tooltipData ) {

      // Delegate to close method to handle common cleanup
      var event = $.Event( "blur" ),
        element = tooltipData.element;
      event.target = event.currentTarget = element[ 0 ];
      that.close( event, true );

      // Remove immediately; destroying an open tooltip doesn't use the
      // hide animation
      $( "#" + id ).remove();

      // Restore the title
      if ( element.data( "ui-tooltip-title" ) ) {

        // If the title attribute has changed since open(), don't restore
        if ( !element.attr( "title" ) ) {
          element.attr( "title", element.data( "ui-tooltip-title" ) );
        }
        element.removeData( "ui-tooltip-title" );
      }
    } );
    this.liveRegion.remove();
  }
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

  // Backcompat for tooltipClass option
  $.widget( "ui.tooltip", $.ui.tooltip, {
    options: {
      tooltipClass: null
    },
    _tooltip: function() {
      var tooltipData = this._superApply( arguments );
      if ( this.options.tooltipClass ) {
        tooltipData.tooltip.addClass( this.options.tooltipClass );
      }
      return tooltipData;
    }
  } );
}

var widgetsTooltip = $.ui.tooltip;




}));

